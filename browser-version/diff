diff --git a/.gitignore b/.gitignore
index 9bd15e5..8c2aa81 100755
--- a/.gitignore
+++ b/.gitignore
@@ -6,7 +6,7 @@ lib-cov
 *.out
 *.pid
 *.gz
-.idea
+
 pids
 logs
 results
diff --git a/README.md b/README.md
index bc30688..9da254c 100755
--- a/README.md
+++ b/README.md
@@ -7,10 +7,7 @@
 **IMPORTANT NOTE**: Please don't submit issues for questions regarding your code. Only actual bugs or feature requests will be answered, all others will be closed without comment. Also, please follow the <a href="#bug-reporting-guidelines">bug reporting guidelines</a> and check the <a href="https://github.com/louischatriot/nedb/wiki/Change-log" target="_blank">change log</a> before submitting an already fixed bug :)
 
 ## Support NeDB development
-
-<img src="http://i.imgur.com/mpwi4lf.jpg">
-
-No time to <a href="#pull-requests">help out</a>? You can support NeDB development by sending money or bitcoins!
+No time to <a href="#help-out">help out</a>? You can support NeDB development by sending money or bitcoins!
 
 Money: [![Donate to author](https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=louis%2echatriot%40gmail%2ecom&lc=US&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHostedGuest)
 
@@ -56,11 +53,6 @@ You can use NeDB as an in-memory only datastore or as a persistent datastore. On
 * `afterSerialization` (optional): hook you can use to transform data after it was serialized and before it is written to disk. Can be used for example to encrypt data before writing database to disk. This function takes a string as parameter (one line of an NeDB data file) and outputs the transformed string, **which must absolutely not contain a `\n` character** (or data will be lost).
 * `beforeDeserialization` (optional): inverse of `afterSerialization`. Make sure to include both and not just one or you risk data loss. For the same reason, make sure both functions are inverses of one another. Some failsafe mechanisms are in place to prevent data loss if you misuse the serialization hooks: NeDB checks that never one is declared without the other, and checks that they are reverse of one another by testing on random strings of various lengths. In addition, if too much data is detected as corrupt, NeDB will refuse to start as it could mean you're not using the deserialization hook corresponding to the serialization hook used before (see below).
 * `corruptAlertThreshold` (optional): between 0 and 1, defaults to 10%. NeDB will refuse to start if more than this percentage of the datafile is corrupt. 0 means you don't tolerate any corruption, 1 means you don't care.
-* `compareStrings` (optional): function compareStrings(a, b) compares
-  strings a and b and return -1, 0 or 1. If specified, it overrides
-default string comparison which is not well adapted to non-US characters
-in particular accented letters. Native `localCompare` will most of the
-time be the right choice
 * `nodeWebkitAppName` (optional, **DEPRECATED**): if you are using NeDB from whithin a Node Webkit app, specify its name (the same one you use in the `package.json`) in this field and the `filename` will be relative to the directory Node Webkit uses to store the rest of the application's data (local storage etc.). It works on Linux, OS X and Windows. Now that you can use `require('nw.gui').App.dataPath` in Node Webkit to get the path to the data directory for your application, you should not use this option anymore and it will be removed.
 
 If you use a persistent datastore without the `autoload` option, you need to call `loadDatabase` manually.
@@ -111,7 +103,7 @@ db.robots.loadDatabase();
 ### Persistence
 Under the hood, NeDB's persistence uses an append-only format, meaning that all updates and deletes actually result in lines added at the end of the datafile, for performance reasons. The database is automatically compacted (i.e. put back in the one-line-per-document format) every time you load each database within your application.
 
-You can manually call the compaction function with `yourDatabase.persistence.compactDatafile` which takes no argument. It queues a compaction of the datafile in the executor, to be executed sequentially after all pending operations. The datastore will fire a `compaction.done` event once compaction is finished.
+You can manually call the compaction function with `yourDatabase.persistence.compactDatafile` which takes no argument. It queues a compaction of the datafile in the executor, to be executed sequentially after all pending operations.
 
 You can also set automatic compaction at regular intervals with `yourDatabase.persistence.setAutocompactionInterval(interval)`, `interval` in milliseconds (a minimum of 5s is enforced), and stop automatic compaction with `yourDatabase.persistence.stopAutocompaction()`.
 
@@ -274,35 +266,11 @@ db.find({ planet: { $regex: /ar/, $nin: ['Jupiter', 'Earth'] } }, function (err,
 ```
 
 #### Array fields
-When a field in a document is an array, NeDB first tries to see if the query value is an array to perform an exact match, then whether there is an array-specific comparison function (for now there is only `$size` and `$elemMatch`) being used. If not, the query is treated as a query on every element and there is a match if at least one element matches.  
-
-* `$size`: match on the size of the array
-* `$elemMatch`: matches if at least one array element matches the query entirely
+When a field in a document is an array, NeDB first tries to see if there is an array-specific comparison function (for now there is only `$size`) being used
+and tries it first. If there isn't, the query is treated as a query on every element and there is a match if at least one element matches.
 
 ```javascript
-// Exact match
-db.find({ satellites: ['Phobos', 'Deimos'] }, function (err, docs) {
-  // docs contains Mars
-})
-db.find({ satellites: ['Deimos', 'Phobos'] }, function (err, docs) {
-  // docs is empty
-})
-
 // Using an array-specific comparison function
-// $elemMatch operator will provide match for a document, if an element from the array field satisfies all the conditions specified with the `$elemMatch` operator
-db.find({ completeData: { planets: { $elemMatch: { name: 'Earth', number: 3 } } } }, function (err, docs) {
-  // docs contains documents with id 5 (completeData)
-});
-
-db.find({ completeData: { planets: { $elemMatch: { name: 'Earth', number: 5 } } } }, function (err, docs) {
-  // docs is empty
-});
-
-// You can use inside #elemMatch query any known document query operator
-db.find({ completeData: { planets: { $elemMatch: { name: 'Earth', number: { $gt: 2 } } } } }, function (err, docs) {
-  // docs contains documents with id 5 (completeData)
-});
-
 // Note: you can't use nested comparison functions, e.g. { $size: { $lt: 5 } } will throw an error
 db.find({ satellites: { $size: 2 } }, function (err, docs) {
   // docs contains Mars
@@ -380,7 +348,7 @@ db.find({}).sort({ firstField: 1, secondField: -1 }) ...   // You understand how
 ```
 
 #### Projections
-You can give `find` and `findOne` an optional second argument, `projections`. The syntax is the same as MongoDB: `{ a: 1, b: 1 }` to return only the `a` and `b` fields, `{ a: 0, b: 0 }` to omit these two fields. You cannot use both modes at the time, except for `_id` which is by default always returned and which you can choose to omit. You can project on nested documents.
+You can give `find` and `findOne` an optional second argument, `projections`. The syntax is the same as MongoDB: `{ a: 1, b: 1 }` to return only the `a` and `b` fields, `{ a: 0, b: 0 }` to omit these two fields. You cannot use both modes at the time, except for `_id` which is by default always returned and which you can choose to omit.
 
 ```javascript
 // Same database as above
@@ -406,14 +374,10 @@ db.find({ planet: 'Mars' }, { planet: 0, system: 1 }, function (err, docs) {
 });
 
 // You can also use it in a Cursor way but this syntax is not compatible with MongoDB
+// If upstream compatibility is important don't use this method
 db.find({ planet: 'Mars' }).projection({ planet: 1, system: 1 }).exec(function (err, docs) {
   // docs is [{ planet: 'Mars', system: 'solar', _id: 'id1' }]
 });
-
-// Project on a nested document
-db.findOne({ planet: 'Earth' }).projection({ planet: 1, 'humans.genders': 1 }).exec(function (err, doc) {
-  // doc is { planet: 'Earth', _id: 'id2', humans: { genders: 2 } }
-});
 ```
 
 
@@ -439,16 +403,14 @@ db.count({}, function (err, count) {
 * `query` is the same kind of finding query you use with `find` and `findOne`
 * `update` specifies how the documents should be modified. It is either a new document or a set of modifiers (you cannot use both together, it doesn't make sense!)
   * A new document will replace the matched docs
-  * The modifiers create the fields they need to modify if they don't exist, and you can apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field, `$inc` to increment a field's value and `$min`/`$max` to change field's value, only if provided value is less/greater than current value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special `$each` and `$slice`. See examples below for the syntax.
+  * The modifiers create the fields they need to modify if they don't exist, and you can apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field and `$inc` to increment a field's value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special `$each`. See examples below for the syntax.
 * `options` is an object with two possible parameters
   * `multi` (defaults to `false`) which allows the modification of several documents if set to true
   * `upsert` (defaults to `false`) if you want to insert a new document corresponding to the `update` rules if your `query` doesn't match anything. If your `update` is a simple object with no modifiers, it is the inserted document. In the other case, the `query` is stripped from all operator recursively, and the `update` is applied to it.
-  * `returnUpdatedDocs` (defaults to `false`, not MongoDB-compatible) if set to true and update is not an upsert, will return the array of documents matched by the find query and updated. Updated documents will be returned even if the update did not actually modify them.
-* `callback` (optional) signature: `(err, numAffected, affectedDocuments, upsert)`. **Warning**: the API was changed between v1.7.4 and v1.8. Please refer to the <a href="https://github.com/louischatriot/nedb/wiki/Change-log" target="_blank">change log</a> to see the change.
-  * For an upsert, `affectedDocuments` contains the inserted document and the `upsert` flag is set to `true`.
-  * For a standard update with `returnUpdatedDocs` flag set to `false`, `affectedDocuments` is not set.
-  * For a standard update with `returnUpdatedDocs` flag set to `true` and `multi` to `false`, `affectedDocuments` is the updated document.
-  * For a standard update with `returnUpdatedDocs` flag set to `true` and `multi` to `true`, `affectedDocuments` is the array of updated documents.
+  * `returnUpdatedDocs` (defaults to `false`, not MongoDB-compatible) if set to true and update is not an upsert, will return the array of documents matched bu the find query and updated. Updated documents will be returned even if the update did not actually modify them
+* `callback` (optional) signature: `err`, `numReplaced`, `newDoc`
+  * `numReplaced` is the number of documents replaced
+  * `newDoc` is the created document if the upsert mode was chosen and a document was inserted
 
 **Note**: you can't change a document's _id.
 
@@ -536,30 +498,13 @@ db.update({ _id: 'id6' }, { $pull: { fruits: $in: ['apple', 'pear'] } }, {}, fun
   // Now the fruits array is ['orange']
 });
 
+
+
 // $each can be used to $push or $addToSet multiple values at once
 // This example works the same way with $addToSet
-db.update({ _id: 'id6' }, { $push: { fruits: { $each: ['banana', 'orange'] } } }, {}, function () {
+db.update({ _id: 'id6' }, { $push: { fruits: {$each: ['banana', 'orange'] } } }, {}, function () {
   // Now the fruits array is ['apple', 'orange', 'pear', 'banana', 'orange']
 });
-
-// $slice can be used in cunjunction with $push and $each to limit the size of the resulting array.
-// A value of 0 will update the array to an empty array. A positive value n will keep only the n first elements
-// A negative value -n will keep only the last n elements.
-// If $slice is specified but not $each, $each is set to []
-db.update({ _id: 'id6' }, { $push: { fruits: { $each: ['banana'], $slice: 2 } } }, {}, function () {
-  // Now the fruits array is ['apple', 'orange']
-});
-
-// $min/$max to update only if provided value is less/greater than current value
-// Let's say the database contains this document
-// doc = { _id: 'id', name: 'Name', value: 5 }
-db.update({ _id: 'id1' }, { $min: { value: 2 } }, {}, function () {
-  // The document will be updated to { _id: 'id', name: 'Name', value: 2 }
-});
-
-db.update({ _id: 'id1' }, { $min: { value: 8 } }, {}, function () {
-  // The document will not be modified
-});
 ```
 
 ### Removing documents
@@ -586,10 +531,6 @@ db.remove({ system: 'solar' }, { multi: true }, function (err, numRemoved) {
   // numRemoved = 3
   // All planets from the solar system were removed
 });
-
-// Removing all documents with the 'match-all' query
-db.remove({}, { multi: true }, function (err, numRemoved) {
-});
 ```
 
 ### Indexing
@@ -600,7 +541,6 @@ To create an index, use `datastore.ensureIndex(options, cb)`, where callback is
 * **fieldName** (required): name of the field to index. Use the dot notation to index a field in a nested document.
 * **unique** (optional, defaults to `false`): enforce field uniqueness. Note that a unique index will raise an error if you try to index two documents for which the field is not defined.
 * **sparse** (optional, defaults to `false`): don't index documents for which the field is not defined. Use this option along with "unique" if you want to accept multiple documents for which it is not defined.
-* **expireAfterSeconds** (number of seconds, optional): if set, the created index is a TTL (time to live) index, that will automatically remove documents when the system date becomes larger than the date on the indexed field plus `expireAfterSeconds`. Documents where the indexed field is not specified or not a `Date` object are ignored
 
 Note: the `_id` is automatically indexed with a unique constraint, no need to call `ensureIndex` on it.
 
@@ -635,18 +575,6 @@ db.insert({ somefield: 'nedb' }, function (err) {
 // Remove index on field somefield
 db.removeIndex('somefield', function (err) {
 });
-
-// Example of using expireAfterSeconds to remove documents 1 hour
-// after their creation (db's timestampData option is true here)
-db.ensureIndex({ fieldName: 'createdAt', expireAfterSeconds: 3600 }, function (err) {
-});
-
-// You can also use the option to set an expiration date like so
-db.ensureIndex({ fieldName: 'expirationDate', expireAfterSeconds: 0 }, function (err) {
-  // Now all documents will expire when system time reaches the date in their
-  // expirationDate field
-});
-
 ```
 
 **Note:** the `ensureIndex` function creates the index synchronously, so it's best to use it at application startup. It's quite fast so it doesn't increase startup time much (35 ms for a collection containing 10,000 documents).
@@ -697,18 +625,6 @@ Connect and Express, backed by nedb
 * If you've outgrown NeDB, switching to MongoDB won't be too hard as it is the same API. Use <a href="https://github.com/louischatriot/nedb-to-mongodb" target="_blank">this utility</a> to transfer the data from a NeDB database to a MongoDB collection
 * An ODM for NeDB: <a href="https://github.com/scottwrobinson/camo" target="_blank">Camo</a>
 
-## Pull requests
-**Important: I consider NeDB to be feature-complete, i.e. it does everything I think it should and nothing more. As a general rule I will not accept pull requests anymore, except for bugfixes (of course) or if I get convinced I overlook a strong usecase. Please make sure to open an issue before spending time on any PR.**
-
-If you submit a pull request, thanks! There are a couple rules to follow though to make it manageable:
-* The pull request should be atomic, i.e. contain only one feature. If it contains more, please submit multiple pull requests. Reviewing massive, 1000 loc+ pull requests is extremely hard.
-* Likewise, if for one unique feature the pull request grows too large (more than 200 loc tests not included), please get in touch first.
-* Please stick to the current coding style. It's important that the code uses a coherent style for readability.
-* Do not include sylistic improvements ("housekeeping"). If you think one part deserves lots of housekeeping, use a separate pull request so as not to pollute the code.
-* Don't forget tests for your new feature. Also don't forget to run the whole test suite before submitting to make sure you didn't introduce regressions.
-* Do not build the browser version in your branch, I'll take care of it once the code is merged.
-* Update the readme accordingly.
-* Last but not least: keep in mind what NeDB's mindset is! The goal is not to be a replacement for MongoDB, but to have a pure JS database, easy to use, cross platform, fast and expressive enough for the target projects (small and self contained apps on server/desktop/browser/mobile). Sometimes it's better to shoot for simplicity than for API completeness with regards to MongoDB.
 
 ## Bug reporting guidelines
 If you report a bug, thank you! That said for the process to be manageable please strictly adhere to the following guidelines. I'll not be able to handle bug reports that don't:
@@ -716,7 +632,6 @@ If you report a bug, thank you! That said for the process to be manageable pleas
 * It should use assertions to showcase the expected vs actual behavior and be hysteresis-proof. It's quite simple in fact, see this example: https://gist.github.com/louischatriot/220cf6bd29c7de06a486
 * Simplify as much as you can. Strip all your application-specific code. Most of the time you will see that there is no bug but an error in your code :)
 * 50 lines max. If you need more, read the above point and rework your bug report. If you're **really** convinced you need more, please explain precisely in the issue.
-* The code should be Javascript, not Coffeescript.
 
 ### Bitcoins
 You don't have time? You can support NeDB by sending bitcoins to this address: 1dDZLnWpBbodPiN8sizzYrgaz5iahFyb1
diff --git a/bower.json b/bower.json
index 54c4c3a..5a8e356 100755
--- a/bower.json
+++ b/bower.json
@@ -2,5 +2,5 @@
 "name": "nedb",
 "description": "The Javascript Database for Node, nwjs, Electron and the browser",
 "ignore": ["benchmarks", "lib", "test", "test_lac"],
-"main": ["browser-version/out/nedb.js", "browser-version/out/nedb.min.js"]
+"main": ["browser-version/nedb.js", "browser-version/nedb.min.js"]
 }
diff --git a/browser-version/browser-specific/lib/storage.js b/browser-version/browser-specific/lib/storage.js
index 71ad791..86b4640 100755
--- a/browser-version/browser-specific/lib/storage.js
+++ b/browser-version/browser-specific/lib/storage.js
@@ -13,7 +13,6 @@ localforage.config({
   name: 'NeDB'
 , storeName: 'nedbdata'
 });
-var noSerialize = false;
 
 
 function exists (filename, callback) {
@@ -51,14 +50,9 @@ function appendFile (filename, toAppend, options, callback) {
   // Options do not matter in browser setup
   if (typeof options === 'function') { callback = options; }
 
-  localforage.getItem(filename, function (err, contents) {    
-    if (noSerialize) {
-        contents = contents || []; 
-        contents = contents.concat(toAppend);
-    } else {
-        contents = contents || ''; 
-        contents += toAppend;
-    }    
+  localforage.getItem(filename, function (err, contents) {
+    contents = contents || '';
+    contents += toAppend;
     localforage.setItem(filename, contents, function () { return callback(); });
   });
 }
@@ -87,9 +81,6 @@ function ensureDatafileIntegrity (filename, callback) {
   return callback(null);
 }
 
-function setNoSerialize(status) {
-    noSerialize = status;
-}
 
 // Interface
 module.exports.exists = exists;
@@ -101,5 +92,4 @@ module.exports.readFile = readFile;
 module.exports.unlink = unlink;
 module.exports.mkdirp = mkdirp;
 module.exports.ensureDatafileIntegrity = ensureDatafileIntegrity;
-module.exports.forage = localforage;
-module.exports.setNoSerialize = setNoSerialize;
\ No newline at end of file
+
diff --git a/browser-version/out/nedb.js b/browser-version/out/nedb.js
index fb688ee..b7891e1 100755
--- a/browser-version/out/nedb.js
+++ b/browser-version/out/nedb.js
@@ -790,7 +790,7 @@ var model = require('./model')
  * Create a new cursor for this collection
  * @param {Datastore} db - The datastore this cursor is bound to
  * @param {Query} query - The query this cursor will operate on
- * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove
+ * @param {Function} execDn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove
  */
 function Cursor (db, query, execFn) {
   this.db = db;
@@ -862,19 +862,7 @@ Cursor.prototype.project = function (candidates) {
 
   // Do the actual projection
   candidates.forEach(function (candidate) {
-    var toPush;
-    if (action === 1) {   // pick-type projection
-      toPush = { $set: {} };
-      keys.forEach(function (k) {
-        toPush.$set[k] = model.getDotValue(candidate, k);
-        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
-      });
-      toPush = model.modify({}, toPush);
-    } else {   // omit-type projection
-      toPush = { $unset: {} };
-      keys.forEach(function (k) { toPush.$unset[k] = true });
-      toPush = model.modify(candidate, toPush);
-    }
+    var toPush = action === 1 ? _.pick(candidate, keys) : _.omit(candidate, keys);
     if (keepId) {
       toPush._id = candidate._id;
     } else {
@@ -894,83 +882,76 @@ Cursor.prototype.project = function (candidates) {
  *
  * @param {Function} callback - Signature: err, results
  */
-Cursor.prototype._exec = function(_callback) {
-  var res = [], added = 0, skipped = 0, self = this
+Cursor.prototype._exec = function(callback) {
+  var candidates = this.db.getCandidates(this.query)
+    , res = [], added = 0, skipped = 0, self = this
     , error = null
     , i, keys, key
     ;
 
-  function callback (error, res) {
-    if (self.execFn) {
-      return self.execFn(error, res, _callback);
-    } else {
-      return _callback(error, res);
-    }
-  }
-
-  this.db.getCandidates(this.query, function (err, candidates) {
-    if (err) { return callback(err); }
-
-    try {
-      for (i = 0; i < candidates.length; i += 1) {
-        if (model.match(candidates[i], self.query)) {
-          // If a sort is defined, wait for the results to be sorted before applying limit and skip
-          if (!self._sort) {
-            if (self._skip && self._skip > skipped) {
-              skipped += 1;
-            } else {
-              res.push(candidates[i]);
-              added += 1;
-              if (self._limit && self._limit <= added) { break; }
-            }
+  try {
+    for (i = 0; i < candidates.length; i += 1) {
+      if (model.match(candidates[i], this.query)) {
+        // If a sort is defined, wait for the results to be sorted before applying limit and skip
+        if (!this._sort) {
+          if (this._skip && this._skip > skipped) {
+            skipped += 1;
           } else {
             res.push(candidates[i]);
+            added += 1;
+            if (this._limit && this._limit <= added) { break; }
           }
+        } else {
+          res.push(candidates[i]);
         }
       }
-    } catch (err) {
-      return callback(err);
     }
+  } catch (err) {
+    return callback(err);
+  }
 
-    // Apply all sorts
-    if (self._sort) {
-      keys = Object.keys(self._sort);
+  // Apply all sorts
+  if (this._sort) {
+    keys = Object.keys(this._sort);
 
-      // Sorting
-      var criteria = [];
-      for (i = 0; i < keys.length; i++) {
-        key = keys[i];
-        criteria.push({ key: key, direction: self._sort[key] });
-      }
-      res.sort(function(a, b) {
-        var criterion, compare, i;
-        for (i = 0; i < criteria.length; i++) {
-          criterion = criteria[i];
-          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);
-          if (compare !== 0) {
-            return compare;
-          }
+    // Sorting
+    var criteria = [];
+    for (i = 0; i < keys.length; i++) {
+      key = keys[i];
+      criteria.push({ key: key, direction: self._sort[key] });
+    }
+    res.sort(function(a, b) {
+      var criterion, compare, i;
+      for (i = 0; i < criteria.length; i++) {
+        criterion = criteria[i];
+        compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key));
+        if (compare !== 0) {
+          return compare;
         }
-        return 0;
-      });
+      }
+      return 0;
+    });
 
-      // Applying limit and skip
-      var limit = self._limit || res.length
-        , skip = self._skip || 0;
+    // Applying limit and skip
+    var limit = this._limit || res.length
+      , skip = this._skip || 0;
 
-      res = res.slice(skip, skip + limit);
-    }
+    res = res.slice(skip, skip + limit);
+  }
 
-    // Apply projection
-    try {
-      res = self.project(res);
-    } catch (e) {
-      error = e;
-      res = undefined;
-    }
+  // Apply projection
+  try {
+    res = this.project(res);
+  } catch (e) {
+    error = e;
+    res = undefined;
+  }
 
+  if (this.execFn) {
+    return this.execFn(error, res, callback);
+  } else {
     return callback(error, res);
-  });
+  }
 };
 
 Cursor.prototype.exec = function () {
@@ -1086,10 +1067,6 @@ var customUtils = require('./customUtils')
  * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown
  * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks
  * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt
- * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting
- *
- * Event Emitter - Events
- * * compaction.done - Fired whenever a compaction operation was finished
  */
 function Datastore (options) {
   var filename;
@@ -1114,9 +1091,6 @@ function Datastore (options) {
     this.filename = filename;
   }
 
-  // String comparison function
-  this.compareStrings = options.compareStrings;
-
   // Persistence handling
   this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName
                                       , afterSerialization: options.afterSerialization
@@ -1134,7 +1108,6 @@ function Datastore (options) {
   // binary is always well-balanced
   this.indexes = {};
   this.indexes._id = new Index({ fieldName: '_id', unique: true });
-  this.ttlIndexes = {};
 
   // Queue a load of the database right away and call the onload handler
   // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception
@@ -1143,8 +1116,6 @@ function Datastore (options) {
   }); }
 }
 
-util.inherits(Datastore, require('events').EventEmitter);
-
 
 /**
  * Load the database from the datafile, and trigger the execution of buffered commands if any
@@ -1181,7 +1152,6 @@ Datastore.prototype.resetIndexes = function (newData) {
  * @param {String} options.fieldName
  * @param {Boolean} options.unique
  * @param {Boolean} options.sparse
- * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)
  * @param {Function} cb Optional callback, signature: err
  */
 Datastore.prototype.ensureIndex = function (options, cb) {
@@ -1198,7 +1168,6 @@ Datastore.prototype.ensureIndex = function (options, cb) {
   if (this.indexes[options.fieldName]) { return callback(null); }
 
   this.indexes[options.fieldName] = new Index(options);
-  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here
 
   try {
     this.indexes[options.fieldName].insert(this.getAllData());
@@ -1311,90 +1280,50 @@ Datastore.prototype.updateIndexes = function (oldDoc, newDoc) {
  * One way to make it better would be to enable the use of multiple indexes if the first usable index
  * returns too much data. I may do it in the future.
  *
- * Returned candidates will be scanned to find and remove all expired documents
- *
- * @param {Query} query
- * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations
- * @param {Function} callback Signature err, candidates
+ * TODO: needs to be moved to the Cursor module
  */
-Datastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {
+Datastore.prototype.getCandidates = function (query) {
   var indexNames = Object.keys(this.indexes)
-    , self = this
     , usableQueryKeys;
 
-  if (typeof dontExpireStaleDocs === 'function') {
-    callback = dontExpireStaleDocs;
-    dontExpireStaleDocs = false;
-  }
-
-
-  async.waterfall([
-  // STEP 1: get candidates list by checking indexes from most to least frequent usecase
-  function (cb) {
-    // For a basic match
-    usableQueryKeys = [];
-    Object.keys(query).forEach(function (k) {
-      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {
-        usableQueryKeys.push(k);
-      }
-    });
-    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
-    if (usableQueryKeys.length > 0) {
-      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));
+  // For a basic match
+  usableQueryKeys = [];
+  Object.keys(query).forEach(function (k) {
+    if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {
+      usableQueryKeys.push(k);
     }
+  });
+  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
+  if (usableQueryKeys.length > 0) {
+    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]);
+  }
 
-    // For a $in match
-    usableQueryKeys = [];
-    Object.keys(query).forEach(function (k) {
-      if (query[k] && query[k].hasOwnProperty('$in')) {
-        usableQueryKeys.push(k);
-      }
-    });
-    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
-    if (usableQueryKeys.length > 0) {
-      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));
+  // For a $in match
+  usableQueryKeys = [];
+  Object.keys(query).forEach(function (k) {
+    if (query[k] && query[k].hasOwnProperty('$in')) {
+      usableQueryKeys.push(k);
     }
+  });
+  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
+  if (usableQueryKeys.length > 0) {
+    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in);
+  }
 
-    // For a comparison match
-    usableQueryKeys = [];
-    Object.keys(query).forEach(function (k) {
-      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {
-        usableQueryKeys.push(k);
-      }
-    });
-    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
-    if (usableQueryKeys.length > 0) {
-      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));
+  // For a comparison match
+  usableQueryKeys = [];
+  Object.keys(query).forEach(function (k) {
+    if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {
+      usableQueryKeys.push(k);
     }
-
-    // By default, return all the DB data
-    return cb(null, self.getAllData());
+  });
+  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
+  if (usableQueryKeys.length > 0) {
+    return this.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]);
   }
-  // STEP 2: remove all expired documents
-  , function (docs) {
-    if (dontExpireStaleDocs) { return callback(null, docs); }
-
-    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);
-
-    docs.forEach(function (doc) {
-      var valid = true;
-      ttlIndexesFieldNames.forEach(function (i) {
-        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {
-          valid = false;
-        }
-      });
-      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }
-    });
 
-    async.eachSeries(expiredDocsIds, function (_id, cb) {
-      self._remove({ _id: _id }, {}, function (err) {
-        if (err) { return callback(err); }
-        return cb();
-      });
-    }, function (err) {
-      return callback(null, validDocs);
-    });
-  }]);
+  // By default, return all the DB data
+  return this.getAllData();
 };
 
 
@@ -1410,7 +1339,7 @@ Datastore.prototype._insert = function (newDoc, cb) {
     ;
 
   try {
-    preparedDoc = this.prepareDocumentForInsertion(newDoc);
+    preparedDoc = this.prepareDocumentForInsertion(newDoc)
     this._insertInCache(preparedDoc);
   } catch (e) {
     return callback(e);
@@ -1445,7 +1374,7 @@ Datastore.prototype.prepareDocumentForInsertion = function (newDoc) {
   if (util.isArray(newDoc)) {
     preparedDoc = [];
     newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });
-  } else {    
+  } else {
     preparedDoc = model.deepCopy(newDoc);
     if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }
     var now = new Date();
@@ -1604,20 +1533,7 @@ Datastore.prototype.findOne = function (query, projection, callback) {
  *                 options.multi If true, can update multiple documents (defaults to false)
  *                 options.upsert If true, document is inserted if the query doesn't match anything
  *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)
- * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)
- *                      If update was an upsert, upsert flag is set to true
- *                      affectedDocuments can be one of the following:
- *                        * For an upsert, the upserted document
- *                        * For an update with returnUpdatedDocs option false, null
- *                        * For an update with returnUpdatedDocs true and multi false, the updated document
- *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents
- *
- * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,
- *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert
- *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of
- *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the
- *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on
- *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.
+ * @param {Function} cb Optional callback, signature: err, numReplaced, upsert (set to true if the update was in fact an upsert)
  *
  * @api private Use Datastore.update which has the same signature
  */
@@ -1663,60 +1579,54 @@ Datastore.prototype._update = function (query, updateQuery, options, cb) {
 
         return self._insert(toBeInserted, function (err, newDoc) {
           if (err) { return callback(err); }
-          return callback(null, 1, newDoc, true);
+          return callback(null, 1, newDoc);
         });
       }
     });
   }
   , function () {   // Perform the update
-    var modifiedDoc , modifications = [], createdAt;
-
-    self.getCandidates(query, function (err, candidates) {
-      if (err) { return callback(err); }
+    var modifiedDoc
+      , candidates = self.getCandidates(query)
+      , modifications = []
+      ;
 
-      // Preparing update (if an error is thrown here neither the datafile nor
-      // the in-memory indexes are affected)
-      try {
-        for (i = 0; i < candidates.length; i += 1) {
-          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {
-            numReplaced += 1;
-            if (self.timestampData) { createdAt = candidates[i].createdAt; }
-            modifiedDoc = model.modify(candidates[i], updateQuery);
-            if (self.timestampData) {
-              modifiedDoc.createdAt = createdAt;
-              modifiedDoc.updatedAt = new Date();
-            }
-            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });
-          }
+    // Preparing update (if an error is thrown here neither the datafile nor
+    // the in-memory indexes are affected)
+    try {
+      for (i = 0; i < candidates.length; i += 1) {
+        if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {
+          numReplaced += 1;
+          modifiedDoc = model.modify(candidates[i], updateQuery);
+          if (self.timestampData) { modifiedDoc.updatedAt = new Date(); }
+          modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });
         }
-      } catch (err) {
-        return callback(err);
       }
+    } catch (err) {
+      return callback(err);
+    }
 
-      // Change the docs in memory
-      try {
+    // Change the docs in memory
+    try {
         self.updateIndexes(modifications);
-      } catch (err) {
-        return callback(err);
-      }
+    } catch (err) {
+      return callback(err);
+    }
 
-      // Update the datafile
-      var updatedDocs = _.pluck(modifications, 'newDoc');
-      self.persistence.persistNewState(updatedDocs, function (err) {
-        if (err) { return callback(err); }
-        if (!options.returnUpdatedDocs) {
-          return callback(null, numReplaced);
-        } else {
-          var updatedDocsDC = [];
-          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });
-          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }
-          return callback(null, numReplaced, updatedDocsDC);
-        }
-      });
+    // Update the datafile
+    var updatedDocs = _.pluck(modifications, 'newDoc');
+    self.persistence.persistNewState(updatedDocs, function (err) {
+      if (err) { return callback(err); }
+      if (!options.returnUpdatedDocs) {
+        return callback(null, numReplaced);
+      } else {
+        var updatedDocsDC = [];
+        updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });
+        return callback(null, numReplaced, updatedDocsDC);
+      }
     });
-  }]);
+  }
+  ]);
 };
-
 Datastore.prototype.update = function () {
   this.executor.push({ this: this, fn: this._update, arguments: arguments });
 };
@@ -1734,42 +1644,44 @@ Datastore.prototype.update = function () {
  */
 Datastore.prototype._remove = function (query, options, cb) {
   var callback
-    , self = this, numRemoved = 0, removedDocs = [], multi
+    , self = this
+    , numRemoved = 0
+    , multi
+    , removedDocs = []
+    , candidates = this.getCandidates(query)
     ;
 
   if (typeof options === 'function') { cb = options; options = {}; }
   callback = cb || function () {};
   multi = options.multi !== undefined ? options.multi : false;
 
-  this.getCandidates(query, true, function (err, candidates) {
-    if (err) { return callback(err); }
-
-    try {
-      candidates.forEach(function (d) {
-        if (model.match(d, query) && (multi || numRemoved === 0)) {
-          numRemoved += 1;
-          removedDocs.push({ $$deleted: true, _id: d._id });
-          self.removeFromIndexes(d);
-        }
-      });
-    } catch (err) { return callback(err); }
-
-    self.persistence.persistNewState(removedDocs, function (err) {
-      if (err) { return callback(err); }
-      return callback(null, numRemoved);
+  try {
+    candidates.forEach(function (d) {
+      if (model.match(d, query) && (multi || numRemoved === 0)) {
+        numRemoved += 1;
+        removedDocs.push({ $$deleted: true, _id: d._id });
+        self.removeFromIndexes(d);
+      }
     });
+  } catch (err) { return callback(err); }
+
+  self.persistence.persistNewState(removedDocs, function (err) {
+    if (err) { return callback(err); }
+    return callback(null, numRemoved);
   });
 };
-
 Datastore.prototype.remove = function () {
   this.executor.push({ this: this, fn: this._remove, arguments: arguments });
 };
 
 
 
+
+
+
 module.exports = Datastore;
 
-},{"./cursor":5,"./customUtils":6,"./executor":8,"./indexes":9,"./model":10,"./persistence":11,"async":13,"events":1,"underscore":19,"util":3}],8:[function(require,module,exports){
+},{"./cursor":5,"./customUtils":6,"./executor":8,"./indexes":9,"./model":10,"./persistence":11,"async":13,"underscore":19,"util":3}],8:[function(require,module,exports){
 var process=require("__browserify_process");/**
  * Responsible for sequentially executing actions on the database
  */
@@ -1783,16 +1695,17 @@ function Executor () {
 
   // This queue will execute all commands, one-by-one in order
   this.queue = async.queue(function (task, cb) {
-    var newArguments = [];
+    var callback
+      , lastArg = task.arguments[task.arguments.length - 1]
+      , i, newArguments = []
+      ;
 
     // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array
-    for (var i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
-    var lastArg = task.arguments[task.arguments.length - 1];
+    for (i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
 
     // Always tell the queue task is complete. Execute callback if any was given.
     if (typeof lastArg === 'function') {
-      // Callback was supplied
-      newArguments[newArguments.length - 1] = function () {
+      callback = function () {
         if (typeof setImmediate === 'function') {
            setImmediate(cb);
         } else {
@@ -1800,12 +1713,11 @@ function Executor () {
         }
         lastArg.apply(null, arguments);
       };
-    } else if (!lastArg && task.arguments.length !== 0) {
-      // false/undefined/null supplied as callbback
-      newArguments[newArguments.length - 1] = function () { cb(); };
+
+      newArguments[newArguments.length - 1] = callback;
     } else {
-      // Nothing supplied as callback
-      newArguments.push(function () { cb(); });
+      callback = function () { cb(); };
+      newArguments.push(callback);
     }
 
 
@@ -1820,8 +1732,7 @@ function Executor () {
  * @param {Object} task
  *                 task.this - Object to use as this
  *                 task.fn - Function to execute
- *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)
- *                                                                 and the last argument cannot be false/undefined/null
+ *                 task.arguments - Array of arguments
  * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready
  */
 Executor.prototype.push = function (task, forceQueuing) {
@@ -1940,12 +1851,12 @@ Index.prototype.insert = function (doc) {
         break;
       }
     }
-
+    
     if (error) {
       for (i = 0; i < failingI; i += 1) {
         this.tree.delete(keys[i], doc);
       }
-
+      
       throw error;
     }
   }
@@ -2272,24 +2183,6 @@ function deepCopy (obj, strictKeys) {
   }
 
   if (typeof obj === 'object') {
-    var toString = Object.prototype.toString;
-    switch(toString.call(obj)) {
-        case '[object Blob]':
-        case '[object ArrayBuffer]':
-        case '[object Int8Array]':
-        case '[object Uint8Array]':
-        case '[object Uint8ClampedArray]':
-        case '[object Int16Array]':
-        case '[object Uint16Array]':
-        case '[object Int32Array]':
-        case '[object Uint32Array]':
-        case '[object Float32Array]':
-        case '[object Float64Array]':
-        {
-            return obj;
-        }
-        break;
-    }
     res = {};
     Object.keys(obj).forEach(function (k) {
       if (!strictKeys || (k[0] !== '$' && k.indexOf('.') === -1)) {
@@ -2349,12 +2242,9 @@ function compareArrays (a, b) {
  * In the case of objects and arrays, we deep-compare
  * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects
  * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)
- *
- * @param {Function} _compareStrings String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)
  */
-function compareThings (a, b, _compareStrings) {
-  var aKeys, bKeys, comp, i
-    , compareStrings = _compareStrings || compareNSB;
+function compareThings (a, b) {
+  var aKeys, bKeys, comp, i;
 
   // undefined
   if (a === undefined) { return b === undefined ? 0 : -1; }
@@ -2369,8 +2259,8 @@ function compareThings (a, b, _compareStrings) {
   if (typeof b === 'number') { return typeof a === 'number' ? compareNSB(a, b) : 1; }
 
   // Strings
-  if (typeof a === 'string') { return typeof b === 'string' ? compareStrings(a, b) : -1; }
-  if (typeof b === 'string') { return typeof a === 'string' ? compareStrings(a, b) : 1; }
+  if (typeof a === 'string') { return typeof b === 'string' ? compareNSB(a, b) : -1; }
+  if (typeof b === 'string') { return typeof a === 'string' ? compareNSB(a, b) : 1; }
 
   // Booleans
   if (typeof a === 'boolean') { return typeof b === 'boolean' ? compareNSB(a, b) : -1; }
@@ -2430,9 +2320,6 @@ lastStepModifierFunctions.$unset = function (obj, field, value) {
 
 /**
  * Push an element to the end of an array field
- * Optional modifier $each instead of value to push several values
- * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/
- * Différeence with MongoDB: if $slice is specified and not $each, we act as if value is an empty array
  */
 lastStepModifierFunctions.$push = function (obj, field, value) {
   // Create the array if it doesn't exist
@@ -2440,33 +2327,13 @@ lastStepModifierFunctions.$push = function (obj, field, value) {
 
   if (!util.isArray(obj[field])) { throw new Error("Can't $push an element on non-array values"); }
 
-  if (value !== null && typeof value === 'object' && value.$slice && value.$each === undefined) {
-    value.$each = [];
-  }
-
   if (value !== null && typeof value === 'object' && value.$each) {
-    if (Object.keys(value).length >= 3 || (Object.keys(value).length === 2 && value.$slice === undefined)) { throw new Error("Can only use $slice in cunjunction with $each when $push to array"); }
+    if (Object.keys(value).length > 1) { throw new Error("Can't use another field in conjunction with $each"); }
     if (!util.isArray(value.$each)) { throw new Error("$each requires an array value"); }
 
     value.$each.forEach(function (v) {
       obj[field].push(v);
     });
-
-    if (value.$slice === undefined || typeof value.$slice !== 'number') { return; }
-
-    if (value.$slice === 0) {
-      obj[field] = [];
-    } else {
-      var start, end, n = obj[field].length;
-      if (value.$slice < 0) {
-        start = Math.max(0, n + value.$slice);
-        end = n;
-      } else if (value.$slice > 0) {
-        start = 0;
-        end = Math.min(n, value.$slice);
-      }
-      obj[field] = obj[field].slice(start, end);
-    }
   } else {
     obj[field].push(value);
   }
@@ -2552,28 +2419,6 @@ lastStepModifierFunctions.$inc = function (obj, field, value) {
   }
 };
 
-/**
- * Updates the value of the field, only if specified field is greater than the current value of the field
- */
-lastStepModifierFunctions.$max = function (obj, field, value) {
-  if (typeof obj[field] === 'undefined') {
-    obj[field] = value;
-  } else if (value > obj[field]) {
-    obj[field] = value;
-  }
-};
-
-/**
- * Updates the value of the field, only if specified field is smaller than the current value of the field
- */
-lastStepModifierFunctions.$min = function (obj, field, value) {
-  if (typeof obj[field] === 'undefined') { 
-    obj[field] = value;
-  } else if (value < obj[field]) {
-    obj[field] = value;
-  }
-};
-
 // Given its name, create the complete modifier function
 function createModifierFunction (modifier) {
   return function (obj, field, value) {
@@ -2582,10 +2427,7 @@ function createModifierFunction (modifier) {
     if (fieldParts.length === 1) {
       lastStepModifierFunctions[modifier](obj, field, value);
     } else {
-      if (obj[fieldParts[0]] === undefined) {
-        if (modifier === '$unset') { return; }   // Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented
-        obj[fieldParts[0]] = {};
-      }
+      obj[fieldParts[0]] = obj[fieldParts[0]] || {};
       modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);
     }
   };
@@ -2626,7 +2468,7 @@ function modify (obj, updateQuery) {
 
       if (!modifierFunctions[m]) { throw new Error("Unknown modifier " + m); }
 
-      // Can't rely on Object.keys throwing on non objects since ES6
+      // Can't rely on Object.keys throwing on non objects since ES6{
       // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it
       if (typeof updateQuery[m] !== 'object') {
         throw new Error("Modifier " + m + "'s argument must be an object");
@@ -2703,7 +2545,7 @@ function areThingsEqual (a, b) {
 
   // Arrays (no match since arrays are used as a $in)
   // undefined (no match since they mean field doesn't exist and can't be serialized)
-  if ((!(util.isArray(a) && util.isArray(b)) && (util.isArray(a) || util.isArray(b))) || a === undefined || b === undefined) { return false; }
+  if (util.isArray(a) || util.isArray(b) || a === undefined || b === undefined) { return false; }
 
   // General objects (check for deep equality)
   // a and b should be objects at this point
@@ -2813,20 +2655,7 @@ comparisonFunctions.$size = function (obj, value) {
 
     return (obj.length == value);
 };
-comparisonFunctions.$elemMatch = function (obj, value) {
-  if (!util.isArray(obj)) { return false; }
-  var i = obj.length;
-  var result = false;   // Initialize result
-  while (i--) {
-    if (match(obj[i], value)) {   // If match for array element, return true
-      result = true;
-      break;
-    }
-  }
-  return result;
-};
 arrayComparisonFunctions.$size = true;
-arrayComparisonFunctions.$elemMatch = true;
 
 
 /**
@@ -2935,11 +2764,6 @@ function matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {
 
   // Check if the value is an array if we don't force a treatment as value
   if (util.isArray(objValue) && !treatObjAsValue) {
-    // If the queryValue is an array, try to perform an exact match
-    if (util.isArray(queryValue)) {
-      return matchQueryPart(obj, queryKey, queryValue, true);
-    }
-
     // Check if we are using an array-specific comparison function
     if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {
       keys = Object.keys(queryValue);
@@ -2957,7 +2781,7 @@ function matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {
 
   // queryValue is an actual object. Determine whether it contains comparison operators
   // or only normal fields. Mixed objects are not allowed
-  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue) && !util.isArray(queryValue)) {
+  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {
     keys = Object.keys(queryValue);
     firstChars = _.map(keys, function (item) { return item[0]; });
     dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; });
@@ -3016,20 +2840,7 @@ var storage = require('./storage')
   , Index = require('./indexes')
   ;
 
-if (storage.forage && storage.forage.supports('asyncStorage')) {   
-    model.serialize = function(d) {return d;};
-    oldDeserialize = model.deserialize;
-    model.deserialize = function(d) {
-        if (typeof(d) == 'string') {
-            return oldDeserialize(d);
-        }
-        return d;
-    };
-    if (storage) {
-        model.noSerialize = true;
-        storage.setNoSerialize(true);
-    }
-}
+
 /**
  * Create a new Persistence object for database options.db
  * @param {Datastore} options.db
@@ -3126,14 +2937,6 @@ Persistence.getNWAppFilename = function (appName, relativeFilename) {
   return path.join(home, 'nedb-data', relativeFilename);
 }
 
-Persistence.prototype.addToPersist = function(persist, data) {
-    if (model.noSerialize) {
-        persist.push(data);
-    } else {
-        persist += data + '\n';
-    }
-    return persist;
-};
 
 /**
  * Persist cached database
@@ -3144,26 +2947,21 @@ Persistence.prototype.addToPersist = function(persist, data) {
 Persistence.prototype.persistCachedDatabase = function (cb) {
   var callback = cb || function () {}
     , toPersist = ''
-    , self = this;
+    , self = this
+    ;
 
   if (this.inMemoryOnly) { return callback(null); }
-  if (!!model.noSerialize) {
-    toPersist = [];
-  }
+
   this.db.getAllData().forEach(function (doc) {
-    toPersist = self.addToPersist(toPersist, self.afterSerialization(model.serialize(doc)));
+    toPersist += self.afterSerialization(model.serialize(doc)) + '\n';
   });
   Object.keys(this.db.indexes).forEach(function (fieldName) {
     if (fieldName != "_id") {   // The special _id index is managed by datastore.js, the others need to be persisted
-      toPersist = self.addToPersist(toPersist, self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})));
+      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})) + '\n';
     }
   });
-  
-  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {
-    if (err) { return callback(err); }
-    self.db.emit('compaction.done');
-    return callback(null);
-  });
+
+  storage.crashSafeWriteFile(this.filename, toPersist, callback);
 };
 
 
@@ -3215,14 +3013,11 @@ Persistence.prototype.persistNewState = function (newDocs, cb) {
 
   // In-memory only datastore
   if (self.inMemoryOnly) { return callback(null); }
-  if (!!model.noSerialize) {
-    toPersist = [];
-  }
 
   newDocs.forEach(function (doc) {
-    toPersist = self.addToPersist(toPersist, self.afterSerialization(model.serialize(doc)));
+    toPersist += self.afterSerialization(model.serialize(doc)) + '\n';
   });
-  
+
   if (toPersist.length === 0) { return callback(null); }
 
   storage.appendFile(self.filename, toPersist, 'utf8', function (err) {
@@ -3230,28 +3025,13 @@ Persistence.prototype.persistNewState = function (newDocs, cb) {
   });
 };
 
-Persistence.prototype.split = function (data) {
-    if (model.noSerialize) {
-        if (typeof(data) == 'string') {
-            return data.split('\n');
-        }
-
-        return data;
-    }
-
-    if (typeof(data) == 'string') {
-        return data.split('\n');
-    }
-
-    return data;
-};
 
 /**
  * From a database's raw data, return the corresponding
  * machine understandable collection
  */
 Persistence.prototype.treatRawData = function (rawData) {
-  var data = this.split(rawData)
+  var data = rawData.split('\n')
     , dataById = {}
     , tdata = []
     , i
@@ -3372,7 +3152,6 @@ localforage.config({
   name: 'NeDB'
 , storeName: 'nedbdata'
 });
-var noSerialize = false;
 
 
 function exists (filename, callback) {
@@ -3410,14 +3189,9 @@ function appendFile (filename, toAppend, options, callback) {
   // Options do not matter in browser setup
   if (typeof options === 'function') { callback = options; }
 
-  localforage.getItem(filename, function (err, contents) {    
-    if (noSerialize) {
-        contents = contents || []; 
-        contents = contents.concat(toAppend);
-    } else {
-        contents = contents || ''; 
-        contents += toAppend;
-    }    
+  localforage.getItem(filename, function (err, contents) {
+    contents = contents || '';
+    contents += toAppend;
     localforage.setItem(filename, contents, function () { return callback(); });
   });
 }
@@ -3446,9 +3220,6 @@ function ensureDatafileIntegrity (filename, callback) {
   return callback(null);
 }
 
-function setNoSerialize(status) {
-    noSerialize = status;
-}
 
 // Interface
 module.exports.exists = exists;
@@ -3460,8 +3231,8 @@ module.exports.readFile = readFile;
 module.exports.unlink = unlink;
 module.exports.mkdirp = mkdirp;
 module.exports.ensureDatafileIntegrity = ensureDatafileIntegrity;
-module.exports.forage = localforage;
-module.exports.setNoSerialize = setNoSerialize;
+
+
 },{"localforage":18}],13:[function(require,module,exports){
 var process=require("__browserify_process");/*global setImmediate: false, setTimeout: false, console: false */
 (function () {
@@ -5472,2805 +5243,2788 @@ function defaultCheckValueEquality (a, b) {
 module.exports.defaultCheckValueEquality = defaultCheckValueEquality;
 
 },{}],18:[function(require,module,exports){
-var global=self;/*!
+var process=require("__browserify_process"),global=self;/*!
     localForage -- Offline Storage, Improved
-    Version 1.7.1
-    https://localforage.github.io/localForage
-    (c) 2013-2017 Mozilla, Apache License 2.0
+    Version 1.3.0
+    https://mozilla.github.io/localForage
+    (c) 2013-2015 Mozilla, Apache License 2.0
 */
-(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
-(function (global){
-'use strict';
-var Mutation = global.MutationObserver || global.WebKitMutationObserver;
-
-var scheduleDrain;
-
-{
-  if (Mutation) {
-    var called = 0;
-    var observer = new Mutation(nextTick);
-    var element = global.document.createTextNode('');
-    observer.observe(element, {
-      characterData: true
-    });
-    scheduleDrain = function () {
-      element.data = (called = ++called % 2);
-    };
-  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
-    var channel = new global.MessageChannel();
-    channel.port1.onmessage = nextTick;
-    scheduleDrain = function () {
-      channel.port2.postMessage(0);
-    };
-  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
-    scheduleDrain = function () {
-
-      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
-      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
-      var scriptEl = global.document.createElement('script');
-      scriptEl.onreadystatechange = function () {
-        nextTick();
-
-        scriptEl.onreadystatechange = null;
-        scriptEl.parentNode.removeChild(scriptEl);
-        scriptEl = null;
-      };
-      global.document.documentElement.appendChild(scriptEl);
-    };
-  } else {
-    scheduleDrain = function () {
-      setTimeout(nextTick, 0);
-    };
-  }
-}
+(function() {
+var define, requireModule, require, requirejs;
 
-var draining;
-var queue = [];
-//named nextTick for less confusing stack traces
-function nextTick() {
-  draining = true;
-  var i, oldQueue;
-  var len = queue.length;
-  while (len) {
-    oldQueue = queue;
-    queue = [];
-    i = -1;
-    while (++i < len) {
-      oldQueue[i]();
-    }
-    len = queue.length;
-  }
-  draining = false;
-}
+(function() {
+  var registry = {}, seen = {};
 
-module.exports = immediate;
-function immediate(task) {
-  if (queue.push(task) === 1 && !draining) {
-    scheduleDrain();
-  }
-}
+  define = function(name, deps, callback) {
+    registry[name] = { deps: deps, callback: callback };
+  };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{}],2:[function(_dereq_,module,exports){
-'use strict';
-var immediate = _dereq_(1);
+  requirejs = require = requireModule = function(name) {
+  requirejs._eak_seen = registry;
 
-/* istanbul ignore next */
-function INTERNAL() {}
+    if (seen[name]) { return seen[name]; }
+    seen[name] = {};
 
-var handlers = {};
+    if (!registry[name]) {
+      throw new Error("Could not find module " + name);
+    }
+
+    var mod = registry[name],
+        deps = mod.deps,
+        callback = mod.callback,
+        reified = [],
+        exports;
 
-var REJECTED = ['REJECTED'];
-var FULFILLED = ['FULFILLED'];
-var PENDING = ['PENDING'];
+    for (var i=0, l=deps.length; i<l; i++) {
+      if (deps[i] === 'exports') {
+        reified.push(exports = {});
+      } else {
+        reified.push(requireModule(resolve(deps[i])));
+      }
+    }
 
-module.exports = Promise;
+    var value = callback.apply(this, reified);
+    return seen[name] = exports || value;
 
-function Promise(resolver) {
-  if (typeof resolver !== 'function') {
-    throw new TypeError('resolver must be a function');
-  }
-  this.state = PENDING;
-  this.queue = [];
-  this.outcome = void 0;
-  if (resolver !== INTERNAL) {
-    safelyResolveThenable(this, resolver);
-  }
-}
+    function resolve(child) {
+      if (child.charAt(0) !== '.') { return child; }
+      var parts = child.split("/");
+      var parentBase = name.split("/").slice(0, -1);
 
-Promise.prototype["catch"] = function (onRejected) {
-  return this.then(null, onRejected);
-};
-Promise.prototype.then = function (onFulfilled, onRejected) {
-  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
-    typeof onRejected !== 'function' && this.state === REJECTED) {
-    return this;
-  }
-  var promise = new this.constructor(INTERNAL);
-  if (this.state !== PENDING) {
-    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
-    unwrap(promise, resolver, this.outcome);
-  } else {
-    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
-  }
+      for (var i=0, l=parts.length; i<l; i++) {
+        var part = parts[i];
 
-  return promise;
-};
-function QueueItem(promise, onFulfilled, onRejected) {
-  this.promise = promise;
-  if (typeof onFulfilled === 'function') {
-    this.onFulfilled = onFulfilled;
-    this.callFulfilled = this.otherCallFulfilled;
-  }
-  if (typeof onRejected === 'function') {
-    this.onRejected = onRejected;
-    this.callRejected = this.otherCallRejected;
-  }
-}
-QueueItem.prototype.callFulfilled = function (value) {
-  handlers.resolve(this.promise, value);
-};
-QueueItem.prototype.otherCallFulfilled = function (value) {
-  unwrap(this.promise, this.onFulfilled, value);
-};
-QueueItem.prototype.callRejected = function (value) {
-  handlers.reject(this.promise, value);
-};
-QueueItem.prototype.otherCallRejected = function (value) {
-  unwrap(this.promise, this.onRejected, value);
-};
+        if (part === '..') { parentBase.pop(); }
+        else if (part === '.') { continue; }
+        else { parentBase.push(part); }
+      }
 
-function unwrap(promise, func, value) {
-  immediate(function () {
-    var returnValue;
-    try {
-      returnValue = func(value);
-    } catch (e) {
-      return handlers.reject(promise, e);
+      return parentBase.join("/");
     }
-    if (returnValue === promise) {
-      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
-    } else {
-      handlers.resolve(promise, returnValue);
-    }
-  });
-}
+  };
+})();
 
-handlers.resolve = function (self, value) {
-  var result = tryCatch(getThen, value);
-  if (result.status === 'error') {
-    return handlers.reject(self, result.value);
-  }
-  var thenable = result.value;
+define("promise/all", 
+  ["./utils","exports"],
+  function(__dependency1__, __exports__) {
+    "use strict";
+    /* global toString */
 
-  if (thenable) {
-    safelyResolveThenable(self, thenable);
-  } else {
-    self.state = FULFILLED;
-    self.outcome = value;
-    var i = -1;
-    var len = self.queue.length;
-    while (++i < len) {
-      self.queue[i].callFulfilled(value);
-    }
-  }
-  return self;
-};
-handlers.reject = function (self, error) {
-  self.state = REJECTED;
-  self.outcome = error;
-  var i = -1;
-  var len = self.queue.length;
-  while (++i < len) {
-    self.queue[i].callRejected(error);
-  }
-  return self;
-};
+    var isArray = __dependency1__.isArray;
+    var isFunction = __dependency1__.isFunction;
 
-function getThen(obj) {
-  // Make sure we only access the accessor once as required by the spec
-  var then = obj && obj.then;
-  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
-    return function appyThen() {
-      then.apply(obj, arguments);
-    };
-  }
-}
+    /**
+      Returns a promise that is fulfilled when all the given promises have been
+      fulfilled, or rejected if any of them become rejected. The return promise
+      is fulfilled with an array that gives all the values in the order they were
+      passed in the `promises` array argument.
 
-function safelyResolveThenable(self, thenable) {
-  // Either fulfill, reject or reject with error
-  var called = false;
-  function onError(value) {
-    if (called) {
-      return;
-    }
-    called = true;
-    handlers.reject(self, value);
-  }
+      Example:
 
-  function onSuccess(value) {
-    if (called) {
-      return;
-    }
-    called = true;
-    handlers.resolve(self, value);
-  }
+      ```javascript
+      var promise1 = RSVP.resolve(1);
+      var promise2 = RSVP.resolve(2);
+      var promise3 = RSVP.resolve(3);
+      var promises = [ promise1, promise2, promise3 ];
 
-  function tryToUnwrap() {
-    thenable(onSuccess, onError);
-  }
+      RSVP.all(promises).then(function(array){
+        // The array here would be [ 1, 2, 3 ];
+      });
+      ```
 
-  var result = tryCatch(tryToUnwrap);
-  if (result.status === 'error') {
-    onError(result.value);
-  }
-}
+      If any of the `promises` given to `RSVP.all` are rejected, the first promise
+      that is rejected will be given as an argument to the returned promises's
+      rejection handler. For example:
 
-function tryCatch(func, value) {
-  var out = {};
-  try {
-    out.value = func(value);
-    out.status = 'success';
-  } catch (e) {
-    out.status = 'error';
-    out.value = e;
-  }
-  return out;
-}
+      Example:
 
-Promise.resolve = resolve;
-function resolve(value) {
-  if (value instanceof this) {
-    return value;
-  }
-  return handlers.resolve(new this(INTERNAL), value);
-}
+      ```javascript
+      var promise1 = RSVP.resolve(1);
+      var promise2 = RSVP.reject(new Error("2"));
+      var promise3 = RSVP.reject(new Error("3"));
+      var promises = [ promise1, promise2, promise3 ];
 
-Promise.reject = reject;
-function reject(reason) {
-  var promise = new this(INTERNAL);
-  return handlers.reject(promise, reason);
-}
+      RSVP.all(promises).then(function(array){
+        // Code here never runs because there are rejected promises!
+      }, function(error) {
+        // error.message === "2"
+      });
+      ```
+
+      @method all
+      @for RSVP
+      @param {Array} promises
+      @param {String} label
+      @return {Promise} promise that is fulfilled when all `promises` have been
+      fulfilled, or rejected if any of them become rejected.
+    */
+    function all(promises) {
+      /*jshint validthis:true */
+      var Promise = this;
+
+      if (!isArray(promises)) {
+        throw new TypeError('You must pass an array to all.');
+      }
 
-Promise.all = all;
-function all(iterable) {
-  var self = this;
-  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
-    return this.reject(new TypeError('must be an array'));
-  }
+      return new Promise(function(resolve, reject) {
+        var results = [], remaining = promises.length,
+        promise;
 
-  var len = iterable.length;
-  var called = false;
-  if (!len) {
-    return this.resolve([]);
-  }
+        if (remaining === 0) {
+          resolve([]);
+        }
 
-  var values = new Array(len);
-  var resolved = 0;
-  var i = -1;
-  var promise = new this(INTERNAL);
+        function resolver(index) {
+          return function(value) {
+            resolveAll(index, value);
+          };
+        }
 
-  while (++i < len) {
-    allResolver(iterable[i], i);
-  }
-  return promise;
-  function allResolver(value, i) {
-    self.resolve(value).then(resolveFromAll, function (error) {
-      if (!called) {
-        called = true;
-        handlers.reject(promise, error);
-      }
-    });
-    function resolveFromAll(outValue) {
-      values[i] = outValue;
-      if (++resolved === len && !called) {
-        called = true;
-        handlers.resolve(promise, values);
-      }
-    }
-  }
-}
-
-Promise.race = race;
-function race(iterable) {
-  var self = this;
-  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
-    return this.reject(new TypeError('must be an array'));
-  }
-
-  var len = iterable.length;
-  var called = false;
-  if (!len) {
-    return this.resolve([]);
-  }
-
-  var i = -1;
-  var promise = new this(INTERNAL);
-
-  while (++i < len) {
-    resolver(iterable[i]);
-  }
-  return promise;
-  function resolver(value) {
-    self.resolve(value).then(function (response) {
-      if (!called) {
-        called = true;
-        handlers.resolve(promise, response);
-      }
-    }, function (error) {
-      if (!called) {
-        called = true;
-        handlers.reject(promise, error);
-      }
-    });
-  }
-}
-
-},{"1":1}],3:[function(_dereq_,module,exports){
-(function (global){
-'use strict';
-if (typeof global.Promise !== 'function') {
-  global.Promise = _dereq_(2);
-}
-
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"2":2}],4:[function(_dereq_,module,exports){
-'use strict';
-
-var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
-
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
-
-function getIDB() {
-    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
-    try {
-        if (typeof indexedDB !== 'undefined') {
-            return indexedDB;
-        }
-        if (typeof webkitIndexedDB !== 'undefined') {
-            return webkitIndexedDB;
-        }
-        if (typeof mozIndexedDB !== 'undefined') {
-            return mozIndexedDB;
-        }
-        if (typeof OIndexedDB !== 'undefined') {
-            return OIndexedDB;
-        }
-        if (typeof msIndexedDB !== 'undefined') {
-            return msIndexedDB;
+        function resolveAll(index, value) {
+          results[index] = value;
+          if (--remaining === 0) {
+            resolve(results);
+          }
         }
-    } catch (e) {
-        return;
-    }
-}
 
-var idb = getIDB();
+        for (var i = 0; i < promises.length; i++) {
+          promise = promises[i];
 
-function isIndexedDBValid() {
-    try {
-        // Initialize IndexedDB; fall back to vendor-prefixed versions
-        // if needed.
-        if (!idb) {
-            return false;
+          if (promise && isFunction(promise.then)) {
+            promise.then(resolver(i), reject);
+          } else {
+            resolveAll(i, promise);
+          }
         }
-        // We mimic PouchDB here;
-        //
-        // We test for openDatabase because IE Mobile identifies itself
-        // as Safari. Oh the lulz...
-        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
-
-        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;
-
-        // Safari <10.1 does not meet our requirements for IDB support (#5572)
-        // since Safari 10.1 shipped with fetch, we can use that to detect it
-        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
-        // some outdated implementations of IDB that appear on Samsung
-        // and HTC Android devices <4.4 are missing IDBKeyRange
-        // See: https://github.com/mozilla/localForage/issues/128
-        // See: https://github.com/mozilla/localForage/issues/272
-        typeof IDBKeyRange !== 'undefined';
-    } catch (e) {
-        return false;
+      });
     }
-}
 
-// Abstracts constructing a Blob object, so it also works in older
-// browsers that don't support the native Blob constructor. (i.e.
-// old QtWebKit versions, at least).
-// Abstracts constructing a Blob object, so it also works in older
-// browsers that don't support the native Blob constructor. (i.e.
-// old QtWebKit versions, at least).
-function createBlob(parts, properties) {
-    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
-    parts = parts || [];
-    properties = properties || {};
-    try {
-        return new Blob(parts, properties);
-    } catch (e) {
-        if (e.name !== 'TypeError') {
-            throw e;
-        }
-        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
-        var builder = new Builder();
-        for (var i = 0; i < parts.length; i += 1) {
-            builder.append(parts[i]);
-        }
-        return builder.getBlob(properties.type);
+    __exports__.all = all;
+  });
+define("promise/asap", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    var browserGlobal = (typeof window !== 'undefined') ? window : {};
+    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
+    var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);
+
+    // node
+    function useNextTick() {
+      return function() {
+        process.nextTick(flush);
+      };
     }
-}
 
-// This is CommonJS because lie is an external dependency, so Rollup
-// can just ignore it.
-if (typeof Promise === 'undefined') {
-    // In the "nopromises" build this will just throw if you don't have
-    // a global promise object, but it would throw anyway later.
-    _dereq_(3);
-}
-var Promise$1 = Promise;
-
-function executeCallback(promise, callback) {
-    if (callback) {
-        promise.then(function (result) {
-            callback(null, result);
-        }, function (error) {
-            callback(error);
-        });
-    }
-}
+    function useMutationObserver() {
+      var iterations = 0;
+      var observer = new BrowserMutationObserver(flush);
+      var node = document.createTextNode('');
+      observer.observe(node, { characterData: true });
 
-function executeTwoCallbacks(promise, callback, errorCallback) {
-    if (typeof callback === 'function') {
-        promise.then(callback);
+      return function() {
+        node.data = (iterations = ++iterations % 2);
+      };
     }
 
-    if (typeof errorCallback === 'function') {
-        promise["catch"](errorCallback);
+    function useSetTimeout() {
+      return function() {
+        local.setTimeout(flush, 1);
+      };
     }
-}
 
-function normalizeKey(key) {
-    // Cast the key to a string, as that's all we can set as a key.
-    if (typeof key !== 'string') {
-        console.warn(key + ' used as a key, but it is not a string.');
-        key = String(key);
+    var queue = [];
+    function flush() {
+      for (var i = 0; i < queue.length; i++) {
+        var tuple = queue[i];
+        var callback = tuple[0], arg = tuple[1];
+        callback(arg);
+      }
+      queue = [];
     }
 
-    return key;
-}
+    var scheduleFlush;
 
-function getCallback() {
-    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
-        return arguments[arguments.length - 1];
+    // Decide what async method to use to triggering processing of queued callbacks:
+    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
+      scheduleFlush = useNextTick();
+    } else if (BrowserMutationObserver) {
+      scheduleFlush = useMutationObserver();
+    } else {
+      scheduleFlush = useSetTimeout();
     }
-}
 
-// Some code originally from async_storage.js in
-// [Gaia](https://github.com/mozilla-b2g/gaia).
-
-var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
-var supportsBlobs = void 0;
-var dbContexts = {};
-var toString = Object.prototype.toString;
-
-// Transaction Modes
-var READ_ONLY = 'readonly';
-var READ_WRITE = 'readwrite';
-
-// Transform a binary string to an array buffer, because otherwise
-// weird stuff happens when you try to work with the binary string directly.
-// It is known.
-// From http://stackoverflow.com/questions/14967647/ (continues on next line)
-// encode-decode-image-with-base64-breaks-image (2013-04-21)
-function _binStringToArrayBuffer(bin) {
-    var length = bin.length;
-    var buf = new ArrayBuffer(length);
-    var arr = new Uint8Array(buf);
-    for (var i = 0; i < length; i++) {
-        arr[i] = bin.charCodeAt(i);
+    function asap(callback, arg) {
+      var length = queue.push([callback, arg]);
+      if (length === 1) {
+        // If length is 1, that means that we need to schedule an async flush.
+        // If additional callbacks are queued before the queue is flushed, they
+        // will be processed by this flush that we are scheduling.
+        scheduleFlush();
+      }
     }
-    return buf;
-}
-
-//
-// Blobs are not supported in all versions of IndexedDB, notably
-// Chrome <37 and Android <5. In those versions, storing a blob will throw.
-//
-// Various other blob bugs exist in Chrome v37-42 (inclusive).
-// Detecting them is expensive and confusing to users, and Chrome 37-42
-// is at very low usage worldwide, so we do a hacky userAgent check instead.
-//
-// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
-// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
-// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
-//
-// Code borrowed from PouchDB. See:
-// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
-//
-function _checkBlobSupportWithoutCaching(idb) {
-    return new Promise$1(function (resolve) {
-        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
-        var blob = createBlob(['']);
-        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
-
-        txn.onabort = function (e) {
-            // If the transaction aborts now its due to not being able to
-            // write to the database, likely due to the disk being full
-            e.preventDefault();
-            e.stopPropagation();
-            resolve(false);
-        };
 
-        txn.oncomplete = function () {
-            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
-            var matchedEdge = navigator.userAgent.match(/Edge\//);
-            // MS Edge pretends to be Chrome 42:
-            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
-            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
-        };
-    })["catch"](function () {
-        return false; // error, so assume unsupported
-    });
-}
+    __exports__.asap = asap;
+  });
+define("promise/config", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    var config = {
+      instrument: false
+    };
 
-function _checkBlobSupport(idb) {
-    if (typeof supportsBlobs === 'boolean') {
-        return Promise$1.resolve(supportsBlobs);
+    function configure(name, value) {
+      if (arguments.length === 2) {
+        config[name] = value;
+      } else {
+        return config[name];
+      }
     }
-    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
-        supportsBlobs = value;
-        return supportsBlobs;
-    });
-}
-
-function _deferReadiness(dbInfo) {
-    var dbContext = dbContexts[dbInfo.name];
 
-    // Create a deferred object representing the current database operation.
-    var deferredOperation = {};
-
-    deferredOperation.promise = new Promise$1(function (resolve, reject) {
-        deferredOperation.resolve = resolve;
-        deferredOperation.reject = reject;
-    });
-
-    // Enqueue the deferred operation.
-    dbContext.deferredOperations.push(deferredOperation);
+    __exports__.config = config;
+    __exports__.configure = configure;
+  });
+define("promise/polyfill", 
+  ["./promise","./utils","exports"],
+  function(__dependency1__, __dependency2__, __exports__) {
+    "use strict";
+    /*global self*/
+    var RSVPPromise = __dependency1__.Promise;
+    var isFunction = __dependency2__.isFunction;
+
+    function polyfill() {
+      var local;
+
+      if (typeof global !== 'undefined') {
+        local = global;
+      } else if (typeof window !== 'undefined' && window.document) {
+        local = window;
+      } else {
+        local = self;
+      }
 
-    // Chain its promise to the database readiness.
-    if (!dbContext.dbReady) {
-        dbContext.dbReady = deferredOperation.promise;
-    } else {
-        dbContext.dbReady = dbContext.dbReady.then(function () {
-            return deferredOperation.promise;
-        });
+      var es6PromiseSupport = 
+        "Promise" in local &&
+        // Some of these methods are missing from
+        // Firefox/Chrome experimental implementations
+        "resolve" in local.Promise &&
+        "reject" in local.Promise &&
+        "all" in local.Promise &&
+        "race" in local.Promise &&
+        // Older version of the spec had a resolver object
+        // as the arg rather than a function
+        (function() {
+          var resolve;
+          new local.Promise(function(r) { resolve = r; });
+          return isFunction(resolve);
+        }());
+
+      if (!es6PromiseSupport) {
+        local.Promise = RSVPPromise;
+      }
     }
-}
 
-function _advanceReadiness(dbInfo) {
-    var dbContext = dbContexts[dbInfo.name];
+    __exports__.polyfill = polyfill;
+  });
+define("promise/promise", 
+  ["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],
+  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
+    "use strict";
+    var config = __dependency1__.config;
+    var configure = __dependency1__.configure;
+    var objectOrFunction = __dependency2__.objectOrFunction;
+    var isFunction = __dependency2__.isFunction;
+    var now = __dependency2__.now;
+    var all = __dependency3__.all;
+    var race = __dependency4__.race;
+    var staticResolve = __dependency5__.resolve;
+    var staticReject = __dependency6__.reject;
+    var asap = __dependency7__.asap;
+
+    var counter = 0;
+
+    config.async = asap; // default async is asap;
+
+    function Promise(resolver) {
+      if (!isFunction(resolver)) {
+        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
+      }
+
+      if (!(this instanceof Promise)) {
+        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
+      }
 
-    // Dequeue a deferred operation.
-    var deferredOperation = dbContext.deferredOperations.pop();
+      this._subscribers = [];
 
-    // Resolve its promise (which is part of the database readiness
-    // chain of promises).
-    if (deferredOperation) {
-        deferredOperation.resolve();
-        return deferredOperation.promise;
+      invokeResolver(resolver, this);
     }
-}
 
-function _rejectReadiness(dbInfo, err) {
-    var dbContext = dbContexts[dbInfo.name];
+    function invokeResolver(resolver, promise) {
+      function resolvePromise(value) {
+        resolve(promise, value);
+      }
 
-    // Dequeue a deferred operation.
-    var deferredOperation = dbContext.deferredOperations.pop();
+      function rejectPromise(reason) {
+        reject(promise, reason);
+      }
 
-    // Reject its promise (which is part of the database readiness
-    // chain of promises).
-    if (deferredOperation) {
-        deferredOperation.reject(err);
-        return deferredOperation.promise;
+      try {
+        resolver(resolvePromise, rejectPromise);
+      } catch(e) {
+        rejectPromise(e);
+      }
     }
-}
 
-function _getConnection(dbInfo, upgradeNeeded) {
-    return new Promise$1(function (resolve, reject) {
-        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
+    function invokeCallback(settled, promise, callback, detail) {
+      var hasCallback = isFunction(callback),
+          value, error, succeeded, failed;
 
-        if (dbInfo.db) {
-            if (upgradeNeeded) {
-                _deferReadiness(dbInfo);
-                dbInfo.db.close();
-            } else {
-                return resolve(dbInfo.db);
-            }
+      if (hasCallback) {
+        try {
+          value = callback(detail);
+          succeeded = true;
+        } catch(e) {
+          failed = true;
+          error = e;
         }
+      } else {
+        value = detail;
+        succeeded = true;
+      }
 
-        var dbArgs = [dbInfo.name];
-
-        if (upgradeNeeded) {
-            dbArgs.push(dbInfo.version);
-        }
+      if (handleThenable(promise, value)) {
+        return;
+      } else if (hasCallback && succeeded) {
+        resolve(promise, value);
+      } else if (failed) {
+        reject(promise, error);
+      } else if (settled === FULFILLED) {
+        resolve(promise, value);
+      } else if (settled === REJECTED) {
+        reject(promise, value);
+      }
+    }
 
-        var openreq = idb.open.apply(idb, dbArgs);
+    var PENDING   = void 0;
+    var SEALED    = 0;
+    var FULFILLED = 1;
+    var REJECTED  = 2;
 
-        if (upgradeNeeded) {
-            openreq.onupgradeneeded = function (e) {
-                var db = openreq.result;
-                try {
-                    db.createObjectStore(dbInfo.storeName);
-                    if (e.oldVersion <= 1) {
-                        // Added when support for blob shims was added
-                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
-                    }
-                } catch (ex) {
-                    if (ex.name === 'ConstraintError') {
-                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
-                    } else {
-                        throw ex;
-                    }
-                }
-            };
-        }
+    function subscribe(parent, child, onFulfillment, onRejection) {
+      var subscribers = parent._subscribers;
+      var length = subscribers.length;
 
-        openreq.onerror = function (e) {
-            e.preventDefault();
-            reject(openreq.error);
-        };
+      subscribers[length] = child;
+      subscribers[length + FULFILLED] = onFulfillment;
+      subscribers[length + REJECTED]  = onRejection;
+    }
 
-        openreq.onsuccess = function () {
-            resolve(openreq.result);
-            _advanceReadiness(dbInfo);
-        };
-    });
-}
+    function publish(promise, settled) {
+      var child, callback, subscribers = promise._subscribers, detail = promise._detail;
 
-function _getOriginalConnection(dbInfo) {
-    return _getConnection(dbInfo, false);
-}
+      for (var i = 0; i < subscribers.length; i += 3) {
+        child = subscribers[i];
+        callback = subscribers[i + settled];
 
-function _getUpgradedConnection(dbInfo) {
-    return _getConnection(dbInfo, true);
-}
+        invokeCallback(settled, child, callback, detail);
+      }
 
-function _isUpgradeNeeded(dbInfo, defaultVersion) {
-    if (!dbInfo.db) {
-        return true;
+      promise._subscribers = null;
     }
 
-    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
-    var isDowngrade = dbInfo.version < dbInfo.db.version;
-    var isUpgrade = dbInfo.version > dbInfo.db.version;
+    Promise.prototype = {
+      constructor: Promise,
 
-    if (isDowngrade) {
-        // If the version is not the default one
-        // then warn for impossible downgrade.
-        if (dbInfo.version !== defaultVersion) {
-            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
-        }
-        // Align the versions to prevent errors.
-        dbInfo.version = dbInfo.db.version;
-    }
-
-    if (isUpgrade || isNewStore) {
-        // If the store is new then increment the version (if needed).
-        // This will trigger an "upgradeneeded" event which is required
-        // for creating a store.
-        if (isNewStore) {
-            var incVersion = dbInfo.db.version + 1;
-            if (incVersion > dbInfo.version) {
-                dbInfo.version = incVersion;
-            }
-        }
+      _state: undefined,
+      _detail: undefined,
+      _subscribers: undefined,
 
-        return true;
-    }
+      then: function(onFulfillment, onRejection) {
+        var promise = this;
 
-    return false;
-}
+        var thenPromise = new this.constructor(function() {});
 
-// encode a blob for indexeddb engines that don't support blobs
-function _encodeBlob(blob) {
-    return new Promise$1(function (resolve, reject) {
-        var reader = new FileReader();
-        reader.onerror = reject;
-        reader.onloadend = function (e) {
-            var base64 = btoa(e.target.result || '');
-            resolve({
-                __local_forage_encoded_blob: true,
-                data: base64,
-                type: blob.type
-            });
-        };
-        reader.readAsBinaryString(blob);
-    });
-}
+        if (this._state) {
+          var callbacks = arguments;
+          config.async(function invokePromiseCallback() {
+            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
+          });
+        } else {
+          subscribe(this, thenPromise, onFulfillment, onRejection);
+        }
 
-// decode an encoded blob
-function _decodeBlob(encodedBlob) {
-    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
-    return createBlob([arrayBuff], { type: encodedBlob.type });
-}
+        return thenPromise;
+      },
 
-// is this one of our fancy encoded blobs?
-function _isEncodedBlob(value) {
-    return value && value.__local_forage_encoded_blob;
-}
+      'catch': function(onRejection) {
+        return this.then(null, onRejection);
+      }
+    };
 
-// Specialize the default `ready()` function by making it dependent
-// on the current database operations. Thus, the driver will be actually
-// ready when it's been initialized (default) *and* there are no pending
-// operations on the database (initiated by some other instances).
-function _fullyReady(callback) {
-    var self = this;
+    Promise.all = all;
+    Promise.race = race;
+    Promise.resolve = staticResolve;
+    Promise.reject = staticReject;
 
-    var promise = self._initReady().then(function () {
-        var dbContext = dbContexts[self._dbInfo.name];
+    function handleThenable(promise, value) {
+      var then = null,
+      resolved;
 
-        if (dbContext && dbContext.dbReady) {
-            return dbContext.dbReady;
+      try {
+        if (promise === value) {
+          throw new TypeError("A promises callback cannot return that same promise.");
         }
-    });
 
-    executeTwoCallbacks(promise, callback, callback);
-    return promise;
-}
-
-// Try to establish a new db connection to replace the
-// current one which is broken (i.e. experiencing
-// InvalidStateError while creating a transaction).
-function _tryReconnect(dbInfo) {
-    _deferReadiness(dbInfo);
+        if (objectOrFunction(value)) {
+          then = value.then;
 
-    var dbContext = dbContexts[dbInfo.name];
-    var forages = dbContext.forages;
-
-    for (var i = 0; i < forages.length; i++) {
-        var forage = forages[i];
-        if (forage._dbInfo.db) {
-            forage._dbInfo.db.close();
-            forage._dbInfo.db = null;
-        }
-    }
-    dbInfo.db = null;
+          if (isFunction(then)) {
+            then.call(value, function(val) {
+              if (resolved) { return true; }
+              resolved = true;
 
-    return _getOriginalConnection(dbInfo).then(function (db) {
-        dbInfo.db = db;
-        if (_isUpgradeNeeded(dbInfo)) {
-            // Reopen the database for upgrading.
-            return _getUpgradedConnection(dbInfo);
-        }
-        return db;
-    }).then(function (db) {
-        // store the latest db reference
-        // in case the db was upgraded
-        dbInfo.db = dbContext.db = db;
-        for (var i = 0; i < forages.length; i++) {
-            forages[i]._dbInfo.db = db;
-        }
-    })["catch"](function (err) {
-        _rejectReadiness(dbInfo, err);
-        throw err;
-    });
-}
+              if (value !== val) {
+                resolve(promise, val);
+              } else {
+                fulfill(promise, val);
+              }
+            }, function(val) {
+              if (resolved) { return true; }
+              resolved = true;
 
-// FF doesn't like Promises (micro-tasks) and IDDB store operations,
-// so we have to do it with callbacks
-function createTransaction(dbInfo, mode, callback, retries) {
-    if (retries === undefined) {
-        retries = 1;
-    }
+              reject(promise, val);
+            });
 
-    try {
-        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
-        callback(null, tx);
-    } catch (err) {
-        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
-            return Promise$1.resolve().then(function () {
-                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
-                    // increase the db version, to create the new ObjectStore
-                    if (dbInfo.db) {
-                        dbInfo.version = dbInfo.db.version + 1;
-                    }
-                    // Reopen the database for upgrading.
-                    return _getUpgradedConnection(dbInfo);
-                }
-            }).then(function () {
-                return _tryReconnect(dbInfo).then(function () {
-                    createTransaction(dbInfo, mode, callback, retries - 1);
-                });
-            })["catch"](callback);
+            return true;
+          }
         }
+      } catch (error) {
+        if (resolved) { return true; }
+        reject(promise, error);
+        return true;
+      }
 
-        callback(err);
+      return false;
     }
-}
-
-function createDbContext() {
-    return {
-        // Running localForages sharing a database.
-        forages: [],
-        // Shared database.
-        db: null,
-        // Database readiness (promise).
-        dbReady: null,
-        // Deferred operations on the database.
-        deferredOperations: []
-    };
-}
 
-// Open the IndexedDB database (automatically creates one if one didn't
-// previously exist), using any options set in the config.
-function _initStorage(options) {
-    var self = this;
-    var dbInfo = {
-        db: null
-    };
-
-    if (options) {
-        for (var i in options) {
-            dbInfo[i] = options[i];
-        }
+    function resolve(promise, value) {
+      if (promise === value) {
+        fulfill(promise, value);
+      } else if (!handleThenable(promise, value)) {
+        fulfill(promise, value);
+      }
     }
 
-    // Get the current context of the database;
-    var dbContext = dbContexts[dbInfo.name];
+    function fulfill(promise, value) {
+      if (promise._state !== PENDING) { return; }
+      promise._state = SEALED;
+      promise._detail = value;
 
-    // ...or create a new context.
-    if (!dbContext) {
-        dbContext = createDbContext();
-        // Register the new context in the global container.
-        dbContexts[dbInfo.name] = dbContext;
+      config.async(publishFulfillment, promise);
     }
 
-    // Register itself as a running localForage in the current context.
-    dbContext.forages.push(self);
+    function reject(promise, reason) {
+      if (promise._state !== PENDING) { return; }
+      promise._state = SEALED;
+      promise._detail = reason;
 
-    // Replace the default `ready()` function with the specialized one.
-    if (!self._initReady) {
-        self._initReady = self.ready;
-        self.ready = _fullyReady;
+      config.async(publishRejection, promise);
     }
 
-    // Create an array of initialization states of the related localForages.
-    var initPromises = [];
-
-    function ignoreErrors() {
-        // Don't handle errors here,
-        // just makes sure related localForages aren't pending.
-        return Promise$1.resolve();
+    function publishFulfillment(promise) {
+      publish(promise, promise._state = FULFILLED);
     }
 
-    for (var j = 0; j < dbContext.forages.length; j++) {
-        var forage = dbContext.forages[j];
-        if (forage !== self) {
-            // Don't wait for itself...
-            initPromises.push(forage._initReady()["catch"](ignoreErrors));
-        }
+    function publishRejection(promise) {
+      publish(promise, promise._state = REJECTED);
     }
 
-    // Take a snapshot of the related localForages.
-    var forages = dbContext.forages.slice(0);
-
-    // Initialize the connection process only when
-    // all the related localForages aren't pending.
-    return Promise$1.all(initPromises).then(function () {
-        dbInfo.db = dbContext.db;
-        // Get the connection or open a new one without upgrade.
-        return _getOriginalConnection(dbInfo);
-    }).then(function (db) {
-        dbInfo.db = db;
-        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
-            // Reopen the database for upgrading.
-            return _getUpgradedConnection(dbInfo);
-        }
-        return db;
-    }).then(function (db) {
-        dbInfo.db = dbContext.db = db;
-        self._dbInfo = dbInfo;
-        // Share the final connection amongst related localForages.
-        for (var k = 0; k < forages.length; k++) {
-            var forage = forages[k];
-            if (forage !== self) {
-                // Self is already up-to-date.
-                forage._dbInfo.db = dbInfo.db;
-                forage._dbInfo.version = dbInfo.version;
-            }
-        }
-    });
-}
-
-function getItem(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.get(key);
-
-                    req.onsuccess = function () {
-                        var value = req.result;
-                        if (value === undefined) {
-                            value = null;
-                        }
-                        if (_isEncodedBlob(value)) {
-                            value = _decodeBlob(value);
-                        }
-                        resolve(value);
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Iterate over all items stored in database.
-function iterate(iterator, callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
+    __exports__.Promise = Promise;
+  });
+define("promise/race", 
+  ["./utils","exports"],
+  function(__dependency1__, __exports__) {
+    "use strict";
+    /* global toString */
+    var isArray = __dependency1__.isArray;
+
+    /**
+      `RSVP.race` allows you to watch a series of promises and act as soon as the
+      first promise given to the `promises` argument fulfills or rejects.
+
+      Example:
+
+      ```javascript
+      var promise1 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          resolve("promise 1");
+        }, 200);
+      });
 
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.openCursor();
-                    var iterationNumber = 1;
+      var promise2 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          resolve("promise 2");
+        }, 100);
+      });
 
-                    req.onsuccess = function () {
-                        var cursor = req.result;
+      RSVP.race([promise1, promise2]).then(function(result){
+        // result === "promise 2" because it was resolved before promise1
+        // was resolved.
+      });
+      ```
+
+      `RSVP.race` is deterministic in that only the state of the first completed
+      promise matters. For example, even if other promises given to the `promises`
+      array argument are resolved, but the first completed promise has become
+      rejected before the other promises became fulfilled, the returned promise
+      will become rejected:
+
+      ```javascript
+      var promise1 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          resolve("promise 1");
+        }, 200);
+      });
 
-                        if (cursor) {
-                            var value = cursor.value;
-                            if (_isEncodedBlob(value)) {
-                                value = _decodeBlob(value);
-                            }
-                            var result = iterator(value, cursor.key, iterationNumber++);
-
-                            // when the iterator callback retuns any
-                            // (non-`undefined`) value, then we stop
-                            // the iteration immediately
-                            if (result !== void 0) {
-                                resolve(result);
-                            } else {
-                                cursor["continue"]();
-                            }
-                        } else {
-                            resolve();
-                        }
-                    };
+      var promise2 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          reject(new Error("promise 2"));
+        }, 100);
+      });
 
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
+      RSVP.race([promise1, promise2]).then(function(result){
+        // Code here never runs because there are rejected promises!
+      }, function(reason){
+        // reason.message === "promise2" because promise 2 became rejected before
+        // promise 1 became fulfilled
+      });
+      ```
+
+      @method race
+      @for RSVP
+      @param {Array} promises array of promises to observe
+      @param {String} label optional string for describing the promise returned.
+      Useful for tooling.
+      @return {Promise} a promise that becomes fulfilled with the value the first
+      completed promises is resolved with if the first completed promise was
+      fulfilled, or rejected with the reason that the first completed promise
+      was rejected with.
+    */
+    function race(promises) {
+      /*jshint validthis:true */
+      var Promise = this;
+
+      if (!isArray(promises)) {
+        throw new TypeError('You must pass an array to race.');
+      }
+      return new Promise(function(resolve, reject) {
+        var results = [], promise;
 
-    executeCallback(promise, callback);
+        for (var i = 0; i < promises.length; i++) {
+          promise = promises[i];
 
-    return promise;
-}
+          if (promise && typeof promise.then === 'function') {
+            promise.then(resolve, reject);
+          } else {
+            resolve(promise);
+          }
+        }
+      });
+    }
 
-function setItem(key, value, callback) {
-    var self = this;
+    __exports__.race = race;
+  });
+define("promise/reject", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    /**
+      `RSVP.reject` returns a promise that will become rejected with the passed
+      `reason`. `RSVP.reject` is essentially shorthand for the following:
+
+      ```javascript
+      var promise = new RSVP.Promise(function(resolve, reject){
+        reject(new Error('WHOOPS'));
+      });
 
-    key = normalizeKey(key);
+      promise.then(function(value){
+        // Code here doesn't run because the promise is rejected!
+      }, function(reason){
+        // reason.message === 'WHOOPS'
+      });
+      ```
 
-    var promise = new Promise$1(function (resolve, reject) {
-        var dbInfo;
-        self.ready().then(function () {
-            dbInfo = self._dbInfo;
-            if (toString.call(value) === '[object Blob]') {
-                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
-                    if (blobSupport) {
-                        return value;
-                    }
-                    return _encodeBlob(value);
-                });
-            }
-            return value;
-        }).then(function (value) {
-            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
+      Instead of writing the above, your code now simply becomes the following:
 
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
+      ```javascript
+      var promise = RSVP.reject(new Error('WHOOPS'));
 
-                    // The reason we don't _save_ null is because IE 10 does
-                    // not support saving the `null` type in IndexedDB. How
-                    // ironic, given the bug below!
-                    // See: https://github.com/mozilla/localForage/issues/161
-                    if (value === null) {
-                        value = undefined;
-                    }
+      promise.then(function(value){
+        // Code here doesn't run because the promise is rejected!
+      }, function(reason){
+        // reason.message === 'WHOOPS'
+      });
+      ```
+
+      @method reject
+      @for RSVP
+      @param {Any} reason value that the returned promise will be rejected with.
+      @param {String} label optional string for identifying the returned promise.
+      Useful for tooling.
+      @return {Promise} a promise that will become rejected with the given
+      `reason`.
+    */
+    function reject(reason) {
+      /*jshint validthis:true */
+      var Promise = this;
+
+      return new Promise(function (resolve, reject) {
+        reject(reason);
+      });
+    }
 
-                    var req = store.put(value, key);
-
-                    transaction.oncomplete = function () {
-                        // Cast to undefined so the value passed to
-                        // callback/promise is the same as what one would get out
-                        // of `getItem()` later. This leads to some weirdness
-                        // (setItem('foo', undefined) will return `null`), but
-                        // it's not my fault localStorage is our baseline and that
-                        // it's weird.
-                        if (value === undefined) {
-                            value = null;
-                        }
+    __exports__.reject = reject;
+  });
+define("promise/resolve", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    function resolve(value) {
+      /*jshint validthis:true */
+      if (value && typeof value === 'object' && value.constructor === this) {
+        return value;
+      }
 
-                        resolve(value);
-                    };
-                    transaction.onabort = transaction.onerror = function () {
-                        var err = req.error ? req.error : req.transaction.error;
-                        reject(err);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
+      var Promise = this;
 
-    executeCallback(promise, callback);
-    return promise;
-}
+      return new Promise(function(resolve) {
+        resolve(value);
+      });
+    }
 
-function removeItem(key, callback) {
-    var self = this;
+    __exports__.resolve = resolve;
+  });
+define("promise/utils", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    function objectOrFunction(x) {
+      return isFunction(x) || (typeof x === "object" && x !== null);
+    }
 
-    key = normalizeKey(key);
+    function isFunction(x) {
+      return typeof x === "function";
+    }
 
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
+    function isArray(x) {
+      return Object.prototype.toString.call(x) === "[object Array]";
+    }
 
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    // We use a Grunt task to make this safe for IE and some
-                    // versions of Android (including those used by Cordova).
-                    // Normally IE won't like `.delete()` and will insist on
-                    // using `['delete']()`, but we have a build step that
-                    // fixes this for us now.
-                    var req = store["delete"](key);
-                    transaction.oncomplete = function () {
-                        resolve();
-                    };
+    // Date.now is not available in browsers < IE9
+    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
+    var now = Date.now || function() { return new Date().getTime(); };
 
-                    transaction.onerror = function () {
-                        reject(req.error);
-                    };
 
-                    // The request will be also be aborted if we've exceeded our storage
-                    // space.
-                    transaction.onabort = function () {
-                        var err = req.error ? req.error : req.transaction.error;
-                        reject(err);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function clear(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.clear();
-
-                    transaction.oncomplete = function () {
-                        resolve();
-                    };
-
-                    transaction.onabort = transaction.onerror = function () {
-                        var err = req.error ? req.error : req.transaction.error;
-                        reject(err);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function length(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.count();
-
-                    req.onsuccess = function () {
-                        resolve(req.result);
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function key(n, callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        if (n < 0) {
-            resolve(null);
-
-            return;
-        }
-
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var advanced = false;
-                    var req = store.openCursor();
-
-                    req.onsuccess = function () {
-                        var cursor = req.result;
-                        if (!cursor) {
-                            // this means there weren't enough keys
-                            resolve(null);
-
-                            return;
-                        }
-
-                        if (n === 0) {
-                            // We have the first key, return it if that's what they
-                            // wanted.
-                            resolve(cursor.key);
-                        } else {
-                            if (!advanced) {
-                                // Otherwise, ask the cursor to skip ahead n
-                                // records.
-                                advanced = true;
-                                cursor.advance(n);
-                            } else {
-                                // When we get here, we've got the nth key.
-                                resolve(cursor.key);
-                            }
-                        }
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function keys(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.openCursor();
-                    var keys = [];
-
-                    req.onsuccess = function () {
-                        var cursor = req.result;
-
-                        if (!cursor) {
-                            resolve(keys);
-                            return;
-                        }
-
-                        keys.push(cursor.key);
-                        cursor["continue"]();
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function dropInstance(options, callback) {
-    callback = getCallback.apply(this, arguments);
-
-    var currentConfig = this.config();
-    options = typeof options !== 'function' && options || {};
-    if (!options.name) {
-        options.name = options.name || currentConfig.name;
-        options.storeName = options.storeName || currentConfig.storeName;
-    }
-
-    var self = this;
-    var promise;
-    if (!options.name) {
-        promise = Promise$1.reject('Invalid arguments');
-    } else {
-        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;
-
-        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
-            var dbContext = dbContexts[options.name];
-            var forages = dbContext.forages;
-            dbContext.db = db;
-            for (var i = 0; i < forages.length; i++) {
-                forages[i]._dbInfo.db = db;
-            }
-            return db;
-        });
-
-        if (!options.storeName) {
-            promise = dbPromise.then(function (db) {
-                _deferReadiness(options);
-
-                var dbContext = dbContexts[options.name];
-                var forages = dbContext.forages;
-
-                db.close();
-                for (var i = 0; i < forages.length; i++) {
-                    var forage = forages[i];
-                    forage._dbInfo.db = null;
-                }
-
-                var dropDBPromise = new Promise$1(function (resolve, reject) {
-                    var req = idb.deleteDatabase(options.name);
-
-                    req.onerror = req.onblocked = function (err) {
-                        var db = req.result;
-                        if (db) {
-                            db.close();
-                        }
-                        reject(err);
-                    };
-
-                    req.onsuccess = function () {
-                        var db = req.result;
-                        if (db) {
-                            db.close();
-                        }
-                        resolve(db);
-                    };
-                });
-
-                return dropDBPromise.then(function (db) {
-                    dbContext.db = db;
-                    for (var i = 0; i < forages.length; i++) {
-                        var _forage = forages[i];
-                        _advanceReadiness(_forage._dbInfo);
-                    }
-                })["catch"](function (err) {
-                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
-                    throw err;
-                });
-            });
-        } else {
-            promise = dbPromise.then(function (db) {
-                if (!db.objectStoreNames.contains(options.storeName)) {
-                    return;
-                }
-
-                var newVersion = db.version + 1;
-
-                _deferReadiness(options);
-
-                var dbContext = dbContexts[options.name];
-                var forages = dbContext.forages;
-
-                db.close();
-                for (var i = 0; i < forages.length; i++) {
-                    var forage = forages[i];
-                    forage._dbInfo.db = null;
-                    forage._dbInfo.version = newVersion;
-                }
-
-                var dropObjectPromise = new Promise$1(function (resolve, reject) {
-                    var req = idb.open(options.name, newVersion);
-
-                    req.onerror = function (err) {
-                        var db = req.result;
-                        db.close();
-                        reject(err);
-                    };
-
-                    req.onupgradeneeded = function () {
-                        var db = req.result;
-                        db.deleteObjectStore(options.storeName);
-                    };
-
-                    req.onsuccess = function () {
-                        var db = req.result;
-                        db.close();
-                        resolve(db);
-                    };
-                });
-
-                return dropObjectPromise.then(function (db) {
-                    dbContext.db = db;
-                    for (var j = 0; j < forages.length; j++) {
-                        var _forage2 = forages[j];
-                        _forage2._dbInfo.db = db;
-                        _advanceReadiness(_forage2._dbInfo);
-                    }
-                })["catch"](function (err) {
-                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
-                    throw err;
-                });
-            });
-        }
-    }
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-var asyncStorage = {
-    _driver: 'asyncStorage',
-    _initStorage: _initStorage,
-    _support: isIndexedDBValid(),
-    iterate: iterate,
-    getItem: getItem,
-    setItem: setItem,
-    removeItem: removeItem,
-    clear: clear,
-    length: length,
-    key: key,
-    keys: keys,
-    dropInstance: dropInstance
-};
-
-function isWebSQLValid() {
-    return typeof openDatabase === 'function';
-}
-
-// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
-// it to Base64, so this is how we store it to prevent very strange errors with less
-// verbose ways of binary <-> string data storage.
-var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
-
-var BLOB_TYPE_PREFIX = '~~local_forage_type~';
-var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
-
-var SERIALIZED_MARKER = '__lfsc__:';
-var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
-
-// OMG the serializations!
-var TYPE_ARRAYBUFFER = 'arbf';
-var TYPE_BLOB = 'blob';
-var TYPE_INT8ARRAY = 'si08';
-var TYPE_UINT8ARRAY = 'ui08';
-var TYPE_UINT8CLAMPEDARRAY = 'uic8';
-var TYPE_INT16ARRAY = 'si16';
-var TYPE_INT32ARRAY = 'si32';
-var TYPE_UINT16ARRAY = 'ur16';
-var TYPE_UINT32ARRAY = 'ui32';
-var TYPE_FLOAT32ARRAY = 'fl32';
-var TYPE_FLOAT64ARRAY = 'fl64';
-var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
-
-var toString$1 = Object.prototype.toString;
-
-function stringToBuffer(serializedString) {
-    // Fill the string into a ArrayBuffer.
-    var bufferLength = serializedString.length * 0.75;
-    var len = serializedString.length;
-    var i;
-    var p = 0;
-    var encoded1, encoded2, encoded3, encoded4;
-
-    if (serializedString[serializedString.length - 1] === '=') {
-        bufferLength--;
-        if (serializedString[serializedString.length - 2] === '=') {
-            bufferLength--;
-        }
-    }
-
-    var buffer = new ArrayBuffer(bufferLength);
-    var bytes = new Uint8Array(buffer);
-
-    for (i = 0; i < len; i += 4) {
-        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
-        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
-        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
-        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
-
-        /*jslint bitwise: true */
-        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
-        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
-        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
-    }
-    return buffer;
-}
-
-// Converts a buffer to a string to store, serialized, in the backend
-// storage library.
-function bufferToString(buffer) {
-    // base64-arraybuffer
-    var bytes = new Uint8Array(buffer);
-    var base64String = '';
-    var i;
-
-    for (i = 0; i < bytes.length; i += 3) {
-        /*jslint bitwise: true */
-        base64String += BASE_CHARS[bytes[i] >> 2];
-        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
-        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
-        base64String += BASE_CHARS[bytes[i + 2] & 63];
-    }
-
-    if (bytes.length % 3 === 2) {
-        base64String = base64String.substring(0, base64String.length - 1) + '=';
-    } else if (bytes.length % 3 === 1) {
-        base64String = base64String.substring(0, base64String.length - 2) + '==';
-    }
-
-    return base64String;
-}
-
-// Serialize a value, afterwards executing a callback (which usually
-// instructs the `setItem()` callback/promise to be executed). This is how
-// we store binary data with localStorage.
-function serialize(value, callback) {
-    var valueType = '';
-    if (value) {
-        valueType = toString$1.call(value);
-    }
-
-    // Cannot use `value instanceof ArrayBuffer` or such here, as these
-    // checks fail when running the tests using casper.js...
-    //
-    // TODO: See why those tests fail and use a better solution.
-    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
-        // Convert binary arrays to a string and prefix the string with
-        // a special marker.
-        var buffer;
-        var marker = SERIALIZED_MARKER;
-
-        if (value instanceof ArrayBuffer) {
-            buffer = value;
-            marker += TYPE_ARRAYBUFFER;
-        } else {
-            buffer = value.buffer;
-
-            if (valueType === '[object Int8Array]') {
-                marker += TYPE_INT8ARRAY;
-            } else if (valueType === '[object Uint8Array]') {
-                marker += TYPE_UINT8ARRAY;
-            } else if (valueType === '[object Uint8ClampedArray]') {
-                marker += TYPE_UINT8CLAMPEDARRAY;
-            } else if (valueType === '[object Int16Array]') {
-                marker += TYPE_INT16ARRAY;
-            } else if (valueType === '[object Uint16Array]') {
-                marker += TYPE_UINT16ARRAY;
-            } else if (valueType === '[object Int32Array]') {
-                marker += TYPE_INT32ARRAY;
-            } else if (valueType === '[object Uint32Array]') {
-                marker += TYPE_UINT32ARRAY;
-            } else if (valueType === '[object Float32Array]') {
-                marker += TYPE_FLOAT32ARRAY;
-            } else if (valueType === '[object Float64Array]') {
-                marker += TYPE_FLOAT64ARRAY;
-            } else {
-                callback(new Error('Failed to get type for BinaryArray'));
-            }
-        }
-
-        callback(marker + bufferToString(buffer));
-    } else if (valueType === '[object Blob]') {
-        // Conver the blob to a binaryArray and then to a string.
-        var fileReader = new FileReader();
-
-        fileReader.onload = function () {
-            // Backwards-compatible prefix for the blob type.
-            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);
-
-            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
-        };
-
-        fileReader.readAsArrayBuffer(value);
-    } else {
-        try {
-            callback(JSON.stringify(value));
-        } catch (e) {
-            console.error("Couldn't convert value into a JSON string: ", value);
-
-            callback(null, e);
-        }
-    }
-}
-
-// Deserialize data we've inserted into a value column/field. We place
-// special markers into our strings to mark them as encoded; this isn't
-// as nice as a meta field, but it's the only sane thing we can do whilst
-// keeping localStorage support intact.
-//
-// Oftentimes this will just deserialize JSON content, but if we have a
-// special marker (SERIALIZED_MARKER, defined above), we will extract
-// some kind of arraybuffer/binary data/typed array out of the string.
-function deserialize(value) {
-    // If we haven't marked this string as being specially serialized (i.e.
-    // something other than serialized JSON), we can just return it and be
-    // done with it.
-    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
-        return JSON.parse(value);
-    }
-
-    // The following code deals with deserializing some kind of Blob or
-    // TypedArray. First we separate out the type of data we're dealing
-    // with from the data itself.
-    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
-    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
-
-    var blobType;
-    // Backwards-compatible blob type serialization strategy.
-    // DBs created with older versions of localForage will simply not have the blob type.
-    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
-        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
-        blobType = matcher[1];
-        serializedString = serializedString.substring(matcher[0].length);
-    }
-    var buffer = stringToBuffer(serializedString);
-
-    // Return the right type based on the code/type set during
-    // serialization.
-    switch (type) {
-        case TYPE_ARRAYBUFFER:
-            return buffer;
-        case TYPE_BLOB:
-            return createBlob([buffer], { type: blobType });
-        case TYPE_INT8ARRAY:
-            return new Int8Array(buffer);
-        case TYPE_UINT8ARRAY:
-            return new Uint8Array(buffer);
-        case TYPE_UINT8CLAMPEDARRAY:
-            return new Uint8ClampedArray(buffer);
-        case TYPE_INT16ARRAY:
-            return new Int16Array(buffer);
-        case TYPE_UINT16ARRAY:
-            return new Uint16Array(buffer);
-        case TYPE_INT32ARRAY:
-            return new Int32Array(buffer);
-        case TYPE_UINT32ARRAY:
-            return new Uint32Array(buffer);
-        case TYPE_FLOAT32ARRAY:
-            return new Float32Array(buffer);
-        case TYPE_FLOAT64ARRAY:
-            return new Float64Array(buffer);
-        default:
-            throw new Error('Unkown type: ' + type);
-    }
-}
-
-var localforageSerializer = {
-    serialize: serialize,
-    deserialize: deserialize,
-    stringToBuffer: stringToBuffer,
-    bufferToString: bufferToString
-};
-
-/*
- * Includes code from:
- *
- * base64-arraybuffer
- * https://github.com/niklasvh/base64-arraybuffer
- *
- * Copyright (c) 2012 Niklas von Hertzen
- * Licensed under the MIT license.
- */
-
-function createDbTable(t, dbInfo, callback, errorCallback) {
-    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
-}
-
-// Open the WebSQL database (automatically creates one if one didn't
-// previously exist), using any options set in the config.
-function _initStorage$1(options) {
-    var self = this;
-    var dbInfo = {
-        db: null
-    };
-
-    if (options) {
-        for (var i in options) {
-            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
-        }
-    }
-
-    var dbInfoPromise = new Promise$1(function (resolve, reject) {
-        // Open the database; the openDatabase API will automatically
-        // create it for us if it doesn't exist.
-        try {
-            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
-        } catch (e) {
-            return reject(e);
-        }
-
-        // Create our key/value table if it doesn't exist.
-        dbInfo.db.transaction(function (t) {
-            createDbTable(t, dbInfo, function () {
-                self._dbInfo = dbInfo;
-                resolve();
-            }, function (t, error) {
-                reject(error);
-            });
-        }, reject);
-    });
-
-    dbInfo.serializer = localforageSerializer;
-    return dbInfoPromise;
-}
-
-function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
-    t.executeSql(sqlStatement, args, callback, function (t, error) {
-        if (error.code === error.SYNTAX_ERR) {
-            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [name], function (t, results) {
-                if (!results.rows.length) {
-                    // if the table is missing (was deleted)
-                    // re-create it table and retry
-                    createDbTable(t, dbInfo, function () {
-                        t.executeSql(sqlStatement, args, callback, errorCallback);
-                    }, errorCallback);
-                } else {
-                    errorCallback(t, error);
-                }
-            }, errorCallback);
-        } else {
-            errorCallback(t, error);
-        }
-    }, errorCallback);
-}
-
-function getItem$1(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
-                    var result = results.rows.length ? results.rows.item(0).value : null;
-
-                    // Check to see if this is serialized content we need to
-                    // unpack.
-                    if (result) {
-                        result = dbInfo.serializer.deserialize(result);
-                    }
-
-                    resolve(result);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function iterate$1(iterator, callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
-                    var rows = results.rows;
-                    var length = rows.length;
-
-                    for (var i = 0; i < length; i++) {
-                        var item = rows.item(i);
-                        var result = item.value;
-
-                        // Check to see if this is serialized content
-                        // we need to unpack.
-                        if (result) {
-                            result = dbInfo.serializer.deserialize(result);
-                        }
-
-                        result = iterator(result, item.key, i + 1);
-
-                        // void(0) prevents problems with redefinition
-                        // of `undefined`.
-                        if (result !== void 0) {
-                            resolve(result);
-                            return;
-                        }
-                    }
-
-                    resolve();
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function _setItem(key, value, callback, retriesLeft) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            // The localStorage API doesn't return undefined values in an
-            // "expected" way, so undefined is always cast to null in all
-            // drivers. See: https://github.com/mozilla/localForage/pull/42
-            if (value === undefined) {
-                value = null;
-            }
-
-            // Save the original value to pass to the callback.
-            var originalValue = value;
-
-            var dbInfo = self._dbInfo;
-            dbInfo.serializer.serialize(value, function (value, error) {
-                if (error) {
-                    reject(error);
-                } else {
-                    dbInfo.db.transaction(function (t) {
-                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
-                            resolve(originalValue);
-                        }, function (t, error) {
-                            reject(error);
-                        });
-                    }, function (sqlError) {
-                        // The transaction failed; check
-                        // to see if it's a quota error.
-                        if (sqlError.code === sqlError.QUOTA_ERR) {
-                            // We reject the callback outright for now, but
-                            // it's worth trying to re-run the transaction.
-                            // Even if the user accepts the prompt to use
-                            // more storage on Safari, this error will
-                            // be called.
-                            //
-                            // Try to re-run the transaction.
-                            if (retriesLeft > 0) {
-                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
-                                return;
-                            }
-                            reject(sqlError);
-                        }
-                    });
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function setItem$1(key, value, callback) {
-    return _setItem.apply(this, [key, value, callback, 1]);
-}
-
-function removeItem$1(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
-                    resolve();
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Deletes every item in the table.
-// TODO: Find out if this resets the AUTO_INCREMENT number.
-function clear$1(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
-                    resolve();
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Does a simple `COUNT(key)` to get the number of items stored in
-// localForage.
-function length$1(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                // Ahhh, SQL makes this one soooooo easy.
-                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
-                    var result = results.rows.item(0).c;
-                    resolve(result);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Return the key located at key index X; essentially gets the key from a
-// `WHERE id = ?`. This is the most efficient way I can think to implement
-// this rarely-used (in my experience) part of the API, but it can seem
-// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
-// the ID of each key will change every time it's updated. Perhaps a stored
-// procedure for the `setItem()` SQL would solve this problem?
-// TODO: Don't change ID on `setItem()`.
-function key$1(n, callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
-                    var result = results.rows.length ? results.rows.item(0).key : null;
-                    resolve(result);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function keys$1(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
-                    var keys = [];
-
-                    for (var i = 0; i < results.rows.length; i++) {
-                        keys.push(results.rows.item(i).key);
-                    }
-
-                    resolve(keys);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// https://www.w3.org/TR/webdatabase/#databases
-// > There is no way to enumerate or delete the databases available for an origin from this API.
-function getAllStoreNames(db) {
-    return new Promise$1(function (resolve, reject) {
-        db.transaction(function (t) {
-            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
-                var storeNames = [];
-
-                for (var i = 0; i < results.rows.length; i++) {
-                    storeNames.push(results.rows.item(i).name);
-                }
-
-                resolve({
-                    db: db,
-                    storeNames: storeNames
-                });
-            }, function (t, error) {
-                reject(error);
-            });
-        }, function (sqlError) {
-            reject(sqlError);
-        });
-    });
-}
-
-function dropInstance$1(options, callback) {
-    callback = getCallback.apply(this, arguments);
-
-    var currentConfig = this.config();
-    options = typeof options !== 'function' && options || {};
-    if (!options.name) {
-        options.name = options.name || currentConfig.name;
-        options.storeName = options.storeName || currentConfig.storeName;
-    }
-
-    var self = this;
-    var promise;
-    if (!options.name) {
-        promise = Promise$1.reject('Invalid arguments');
-    } else {
-        promise = new Promise$1(function (resolve) {
-            var db;
-            if (options.name === currentConfig.name) {
-                // use the db reference of the current instance
-                db = self._dbInfo.db;
-            } else {
-                db = openDatabase(options.name, '', '', 0);
-            }
-
-            if (!options.storeName) {
-                // drop all database tables
-                resolve(getAllStoreNames(db));
-            } else {
-                resolve({
-                    db: db,
-                    storeNames: [options.storeName]
-                });
-            }
-        }).then(function (operationInfo) {
-            return new Promise$1(function (resolve, reject) {
-                operationInfo.db.transaction(function (t) {
-                    function dropTable(storeName) {
-                        return new Promise$1(function (resolve, reject) {
-                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
-                                resolve();
-                            }, function (t, error) {
-                                reject(error);
-                            });
-                        });
-                    }
-
-                    var operations = [];
-                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
-                        operations.push(dropTable(operationInfo.storeNames[i]));
-                    }
-
-                    Promise$1.all(operations).then(function () {
-                        resolve();
-                    })["catch"](function (e) {
-                        reject(e);
-                    });
-                }, function (sqlError) {
-                    reject(sqlError);
-                });
-            });
-        });
-    }
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-var webSQLStorage = {
-    _driver: 'webSQLStorage',
-    _initStorage: _initStorage$1,
-    _support: isWebSQLValid(),
-    iterate: iterate$1,
-    getItem: getItem$1,
-    setItem: setItem$1,
-    removeItem: removeItem$1,
-    clear: clear$1,
-    length: length$1,
-    key: key$1,
-    keys: keys$1,
-    dropInstance: dropInstance$1
-};
-
-function isLocalStorageValid() {
-    try {
-        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
-        // in IE8 typeof localStorage.setItem === 'object'
-        !!localStorage.setItem;
-    } catch (e) {
-        return false;
-    }
-}
-
-function _getKeyPrefix(options, defaultConfig) {
-    var keyPrefix = options.name + '/';
-
-    if (options.storeName !== defaultConfig.storeName) {
-        keyPrefix += options.storeName + '/';
-    }
-    return keyPrefix;
-}
-
-// Check if localStorage throws when saving an item
-function checkIfLocalStorageThrows() {
-    var localStorageTestKey = '_localforage_support_test';
-
-    try {
-        localStorage.setItem(localStorageTestKey, true);
-        localStorage.removeItem(localStorageTestKey);
-
-        return false;
-    } catch (e) {
-        return true;
-    }
-}
-
-// Check if localStorage is usable and allows to save an item
-// This method checks if localStorage is usable in Safari Private Browsing
-// mode, or in any other case where the available quota for localStorage
-// is 0 and there wasn't any saved items yet.
-function _isLocalStorageUsable() {
-    return !checkIfLocalStorageThrows() || localStorage.length > 0;
-}
-
-// Config the localStorage backend, using options set in the config.
-function _initStorage$2(options) {
-    var self = this;
-    var dbInfo = {};
-    if (options) {
-        for (var i in options) {
-            dbInfo[i] = options[i];
-        }
-    }
-
-    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);
-
-    if (!_isLocalStorageUsable()) {
-        return Promise$1.reject();
-    }
-
-    self._dbInfo = dbInfo;
-    dbInfo.serializer = localforageSerializer;
-
-    return Promise$1.resolve();
-}
-
-// Remove all keys from the datastore, effectively destroying all data in
-// the app's key/value store!
-function clear$2(callback) {
-    var self = this;
-    var promise = self.ready().then(function () {
-        var keyPrefix = self._dbInfo.keyPrefix;
-
-        for (var i = localStorage.length - 1; i >= 0; i--) {
-            var key = localStorage.key(i);
-
-            if (key.indexOf(keyPrefix) === 0) {
-                localStorage.removeItem(key);
-            }
-        }
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Retrieve an item from the store. Unlike the original async_storage
-// library in Gaia, we don't modify return values at all. If a key's value
-// is `undefined`, we pass that value to the callback function.
-function getItem$2(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var result = localStorage.getItem(dbInfo.keyPrefix + key);
-
-        // If a result was found, parse it from the serialized
-        // string into a JS object. If result isn't truthy, the key
-        // is likely undefined and we'll pass it straight to the
-        // callback.
-        if (result) {
-            result = dbInfo.serializer.deserialize(result);
-        }
-
-        return result;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Iterate over all items in the store.
-function iterate$2(iterator, callback) {
-    var self = this;
-
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var keyPrefix = dbInfo.keyPrefix;
-        var keyPrefixLength = keyPrefix.length;
-        var length = localStorage.length;
-
-        // We use a dedicated iterator instead of the `i` variable below
-        // so other keys we fetch in localStorage aren't counted in
-        // the `iterationNumber` argument passed to the `iterate()`
-        // callback.
-        //
-        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
-        var iterationNumber = 1;
-
-        for (var i = 0; i < length; i++) {
-            var key = localStorage.key(i);
-            if (key.indexOf(keyPrefix) !== 0) {
-                continue;
-            }
-            var value = localStorage.getItem(key);
-
-            // If a result was found, parse it from the serialized
-            // string into a JS object. If result isn't truthy, the
-            // key is likely undefined and we'll pass it straight
-            // to the iterator.
-            if (value) {
-                value = dbInfo.serializer.deserialize(value);
-            }
-
-            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);
-
-            if (value !== void 0) {
-                return value;
-            }
-        }
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Same as localStorage's key() method, except takes a callback.
-function key$2(n, callback) {
-    var self = this;
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var result;
-        try {
-            result = localStorage.key(n);
-        } catch (error) {
-            result = null;
-        }
-
-        // Remove the prefix from the key, if a key is found.
-        if (result) {
-            result = result.substring(dbInfo.keyPrefix.length);
-        }
-
-        return result;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function keys$2(callback) {
-    var self = this;
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var length = localStorage.length;
-        var keys = [];
-
-        for (var i = 0; i < length; i++) {
-            var itemKey = localStorage.key(i);
-            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
-                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
-            }
-        }
-
-        return keys;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Supply the number of keys in the datastore to the callback function.
-function length$2(callback) {
-    var self = this;
-    var promise = self.keys().then(function (keys) {
-        return keys.length;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Remove an item from the store, nice and simple.
-function removeItem$2(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        localStorage.removeItem(dbInfo.keyPrefix + key);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Set a key's value and run an optional callback once the value is set.
-// Unlike Gaia's implementation, the callback function is passed the value,
-// in case you want to operate on that value only after you're sure it
-// saved, or something like that.
-function setItem$2(key, value, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = self.ready().then(function () {
-        // Convert undefined values to null.
-        // https://github.com/mozilla/localForage/pull/42
-        if (value === undefined) {
-            value = null;
-        }
-
-        // Save the original value to pass to the callback.
-        var originalValue = value;
-
-        return new Promise$1(function (resolve, reject) {
-            var dbInfo = self._dbInfo;
-            dbInfo.serializer.serialize(value, function (value, error) {
-                if (error) {
-                    reject(error);
-                } else {
-                    try {
-                        localStorage.setItem(dbInfo.keyPrefix + key, value);
-                        resolve(originalValue);
-                    } catch (e) {
-                        // localStorage capacity exceeded.
-                        // TODO: Make this a specific error/event.
-                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
-                            reject(e);
-                        }
-                        reject(e);
-                    }
-                }
-            });
-        });
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function dropInstance$2(options, callback) {
-    callback = getCallback.apply(this, arguments);
-
-    options = typeof options !== 'function' && options || {};
-    if (!options.name) {
-        var currentConfig = this.config();
-        options.name = options.name || currentConfig.name;
-        options.storeName = options.storeName || currentConfig.storeName;
-    }
-
-    var self = this;
-    var promise;
-    if (!options.name) {
-        promise = Promise$1.reject('Invalid arguments');
-    } else {
-        promise = new Promise$1(function (resolve) {
-            if (!options.storeName) {
-                resolve(options.name + '/');
-            } else {
-                resolve(_getKeyPrefix(options, self._defaultConfig));
-            }
-        }).then(function (keyPrefix) {
-            for (var i = localStorage.length - 1; i >= 0; i--) {
-                var key = localStorage.key(i);
-
-                if (key.indexOf(keyPrefix) === 0) {
-                    localStorage.removeItem(key);
-                }
-            }
-        });
-    }
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-var localStorageWrapper = {
-    _driver: 'localStorageWrapper',
-    _initStorage: _initStorage$2,
-    _support: isLocalStorageValid(),
-    iterate: iterate$2,
-    getItem: getItem$2,
-    setItem: setItem$2,
-    removeItem: removeItem$2,
-    clear: clear$2,
-    length: length$2,
-    key: key$2,
-    keys: keys$2,
-    dropInstance: dropInstance$2
-};
-
-var sameValue = function sameValue(x, y) {
-    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
-};
-
-var includes = function includes(array, searchElement) {
-    var len = array.length;
-    var i = 0;
-    while (i < len) {
-        if (sameValue(array[i], searchElement)) {
-            return true;
-        }
-        i++;
-    }
-
-    return false;
-};
-
-var isArray = Array.isArray || function (arg) {
-    return Object.prototype.toString.call(arg) === '[object Array]';
-};
-
-// Drivers are stored here when `defineDriver()` is called.
-// They are shared across all instances of localForage.
-var DefinedDrivers = {};
-
-var DriverSupport = {};
-
-var DefaultDrivers = {
-    INDEXEDDB: asyncStorage,
-    WEBSQL: webSQLStorage,
-    LOCALSTORAGE: localStorageWrapper
-};
-
-var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
-
-var OptionalDriverMethods = ['dropInstance'];
-
-var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);
-
-var DefaultConfig = {
-    description: '',
-    driver: DefaultDriverOrder.slice(),
-    name: 'localforage',
-    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
-    // we can use without a prompt.
-    size: 4980736,
-    storeName: 'keyvaluepairs',
-    version: 1.0
-};
-
-function callWhenReady(localForageInstance, libraryMethod) {
-    localForageInstance[libraryMethod] = function () {
-        var _args = arguments;
-        return localForageInstance.ready().then(function () {
-            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
-        });
-    };
-}
-
-function extend() {
-    for (var i = 1; i < arguments.length; i++) {
-        var arg = arguments[i];
-
-        if (arg) {
-            for (var _key in arg) {
-                if (arg.hasOwnProperty(_key)) {
-                    if (isArray(arg[_key])) {
-                        arguments[0][_key] = arg[_key].slice();
-                    } else {
-                        arguments[0][_key] = arg[_key];
-                    }
-                }
-            }
-        }
-    }
-
-    return arguments[0];
-}
-
-var LocalForage = function () {
-    function LocalForage(options) {
-        _classCallCheck(this, LocalForage);
-
-        for (var driverTypeKey in DefaultDrivers) {
-            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
-                var driver = DefaultDrivers[driverTypeKey];
-                var driverName = driver._driver;
-                this[driverTypeKey] = driverName;
-
-                if (!DefinedDrivers[driverName]) {
-                    // we don't need to wait for the promise,
-                    // since the default drivers can be defined
-                    // in a blocking manner
-                    this.defineDriver(driver);
-                }
-            }
-        }
-
-        this._defaultConfig = extend({}, DefaultConfig);
-        this._config = extend({}, this._defaultConfig, options);
-        this._driverSet = null;
-        this._initDriver = null;
-        this._ready = false;
-        this._dbInfo = null;
-
-        this._wrapLibraryMethodsWithReady();
-        this.setDriver(this._config.driver)["catch"](function () {});
-    }
-
-    // Set any config values for localForage; can be called anytime before
-    // the first API call (e.g. `getItem`, `setItem`).
-    // We loop through options so we don't overwrite existing config
-    // values.
-
-
-    LocalForage.prototype.config = function config(options) {
-        // If the options argument is an object, we use it to set values.
-        // Otherwise, we return either a specified config value or all
-        // config values.
-        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
-            // If localforage is ready and fully initialized, we can't set
-            // any new configuration values. Instead, we return an error.
-            if (this._ready) {
-                return new Error("Can't call config() after localforage " + 'has been used.');
-            }
-
-            for (var i in options) {
-                if (i === 'storeName') {
-                    options[i] = options[i].replace(/\W/g, '_');
-                }
-
-                if (i === 'version' && typeof options[i] !== 'number') {
-                    return new Error('Database version must be a number.');
-                }
-
-                this._config[i] = options[i];
-            }
-
-            // after all config options are set and
-            // the driver option is used, try setting it
-            if ('driver' in options && options.driver) {
-                return this.setDriver(this._config.driver);
-            }
-
-            return true;
-        } else if (typeof options === 'string') {
-            return this._config[options];
-        } else {
-            return this._config;
-        }
-    };
-
-    // Used to define a custom driver, shared across all instances of
-    // localForage.
-
-
-    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
-        var promise = new Promise$1(function (resolve, reject) {
-            try {
-                var driverName = driverObject._driver;
-                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');
-
-                // A driver name should be defined and not overlap with the
-                // library-defined, default drivers.
-                if (!driverObject._driver) {
-                    reject(complianceError);
-                    return;
-                }
-
-                var driverMethods = LibraryMethods.concat('_initStorage');
-                for (var i = 0, len = driverMethods.length; i < len; i++) {
-                    var driverMethodName = driverMethods[i];
-
-                    // when the property is there,
-                    // it should be a method even when optional
-                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
-                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
-                        reject(complianceError);
-                        return;
-                    }
-                }
-
-                var configureMissingMethods = function configureMissingMethods() {
-                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
-                        return function () {
-                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
-                            var promise = Promise$1.reject(error);
-                            executeCallback(promise, arguments[arguments.length - 1]);
-                            return promise;
-                        };
-                    };
-
-                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
-                        var optionalDriverMethod = OptionalDriverMethods[_i];
-                        if (!driverObject[optionalDriverMethod]) {
-                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
-                        }
-                    }
-                };
-
-                configureMissingMethods();
-
-                var setDriverSupport = function setDriverSupport(support) {
-                    if (DefinedDrivers[driverName]) {
-                        console.info('Redefining LocalForage driver: ' + driverName);
-                    }
-                    DefinedDrivers[driverName] = driverObject;
-                    DriverSupport[driverName] = support;
-                    // don't use a then, so that we can define
-                    // drivers that have simple _support methods
-                    // in a blocking manner
-                    resolve();
-                };
-
-                if ('_support' in driverObject) {
-                    if (driverObject._support && typeof driverObject._support === 'function') {
-                        driverObject._support().then(setDriverSupport, reject);
-                    } else {
-                        setDriverSupport(!!driverObject._support);
-                    }
-                } else {
-                    setDriverSupport(true);
-                }
-            } catch (e) {
-                reject(e);
-            }
-        });
-
-        executeTwoCallbacks(promise, callback, errorCallback);
-        return promise;
-    };
-
-    LocalForage.prototype.driver = function driver() {
-        return this._driver || null;
-    };
-
-    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
-        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));
-
-        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
-        return getDriverPromise;
-    };
-
-    LocalForage.prototype.getSerializer = function getSerializer(callback) {
-        var serializerPromise = Promise$1.resolve(localforageSerializer);
-        executeTwoCallbacks(serializerPromise, callback);
-        return serializerPromise;
-    };
-
-    LocalForage.prototype.ready = function ready(callback) {
-        var self = this;
-
-        var promise = self._driverSet.then(function () {
-            if (self._ready === null) {
-                self._ready = self._initDriver();
-            }
-
-            return self._ready;
-        });
-
-        executeTwoCallbacks(promise, callback, callback);
-        return promise;
-    };
-
-    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
-        var self = this;
-
-        if (!isArray(drivers)) {
-            drivers = [drivers];
-        }
-
-        var supportedDrivers = this._getSupportedDrivers(drivers);
-
-        function setDriverToConfig() {
-            self._config.driver = self.driver();
-        }
-
-        function extendSelfWithDriver(driver) {
-            self._extend(driver);
-            setDriverToConfig();
-
-            self._ready = self._initStorage(self._config);
-            return self._ready;
-        }
-
-        function initDriver(supportedDrivers) {
-            return function () {
-                var currentDriverIndex = 0;
-
-                function driverPromiseLoop() {
-                    while (currentDriverIndex < supportedDrivers.length) {
-                        var driverName = supportedDrivers[currentDriverIndex];
-                        currentDriverIndex++;
-
-                        self._dbInfo = null;
-                        self._ready = null;
-
-                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
-                    }
-
-                    setDriverToConfig();
-                    var error = new Error('No available storage method found.');
-                    self._driverSet = Promise$1.reject(error);
-                    return self._driverSet;
-                }
-
-                return driverPromiseLoop();
-            };
-        }
-
-        // There might be a driver initialization in progress
-        // so wait for it to finish in order to avoid a possible
-        // race condition to set _dbInfo
-        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
-            return Promise$1.resolve();
-        }) : Promise$1.resolve();
-
-        this._driverSet = oldDriverSetDone.then(function () {
-            var driverName = supportedDrivers[0];
-            self._dbInfo = null;
-            self._ready = null;
-
-            return self.getDriver(driverName).then(function (driver) {
-                self._driver = driver._driver;
-                setDriverToConfig();
-                self._wrapLibraryMethodsWithReady();
-                self._initDriver = initDriver(supportedDrivers);
-            });
-        })["catch"](function () {
-            setDriverToConfig();
-            var error = new Error('No available storage method found.');
-            self._driverSet = Promise$1.reject(error);
-            return self._driverSet;
-        });
-
-        executeTwoCallbacks(this._driverSet, callback, errorCallback);
-        return this._driverSet;
-    };
-
-    LocalForage.prototype.supports = function supports(driverName) {
-        return !!DriverSupport[driverName];
-    };
-
-    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
-        extend(this, libraryMethodsAndProperties);
-    };
-
-    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
-        var supportedDrivers = [];
-        for (var i = 0, len = drivers.length; i < len; i++) {
-            var driverName = drivers[i];
-            if (this.supports(driverName)) {
-                supportedDrivers.push(driverName);
-            }
-        }
-        return supportedDrivers;
-    };
-
-    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
-        // Add a stub for each driver API method that delays the call to the
-        // corresponding driver method until localForage is ready. These stubs
-        // will be replaced by the driver methods as soon as the driver is
-        // loaded, so there is no performance impact.
-        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
-            callWhenReady(this, LibraryMethods[i]);
-        }
-    };
-
-    LocalForage.prototype.createInstance = function createInstance(options) {
-        return new LocalForage(options);
-    };
-
-    return LocalForage;
-}();
-
-// The actual localForage object that we expose as a module or via a
-// global. It's extended by pulling in one of our other libraries.
-
-
-var localforage_js = new LocalForage();
-
-module.exports = localforage_js;
-
-},{"3":3}]},{},[4])(4)
+    __exports__.objectOrFunction = objectOrFunction;
+    __exports__.isFunction = isFunction;
+    __exports__.isArray = isArray;
+    __exports__.now = now;
+  });
+requireModule('promise/polyfill').polyfill();
+}());(function webpackUniversalModuleDefinition(root, factory) {
+	if(typeof exports === 'object' && typeof module === 'object')
+		module.exports = factory();
+	else if(typeof define === 'function' && define.amd)
+		define([], factory);
+	else if(typeof exports === 'object')
+		exports["localforage"] = factory();
+	else
+		root["localforage"] = factory();
+})(this, function() {
+return /******/ (function(modules) { // webpackBootstrap
+/******/ 	// The module cache
+/******/ 	var installedModules = {};
+
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+
+/******/ 		// Check if module is in cache
+/******/ 		if(installedModules[moduleId])
+/******/ 			return installedModules[moduleId].exports;
+
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = installedModules[moduleId] = {
+/******/ 			exports: {},
+/******/ 			id: moduleId,
+/******/ 			loaded: false
+/******/ 		};
+
+/******/ 		// Execute the module function
+/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
+
+/******/ 		// Flag the module as loaded
+/******/ 		module.loaded = true;
+
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+
+
+/******/ 	// expose the modules object (__webpack_modules__)
+/******/ 	__webpack_require__.m = modules;
+
+/******/ 	// expose the module cache
+/******/ 	__webpack_require__.c = installedModules;
+
+/******/ 	// __webpack_public_path__
+/******/ 	__webpack_require__.p = "";
+
+/******/ 	// Load entry module and return exports
+/******/ 	return __webpack_require__(0);
+/******/ })
+/************************************************************************/
+/******/ ([
+/* 0 */
+/***/ function(module, exports, __webpack_require__) {
+
+	'use strict';
+
+	exports.__esModule = true;
+
+	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
+
+	(function () {
+	    'use strict';
+
+	    // Custom drivers are stored here when `defineDriver()` is called.
+	    // They are shared across all instances of localForage.
+	    var CustomDrivers = {};
+
+	    var DriverType = {
+	        INDEXEDDB: 'asyncStorage',
+	        LOCALSTORAGE: 'localStorageWrapper',
+	        WEBSQL: 'webSQLStorage'
+	    };
+
+	    var DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];
+
+	    var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];
+
+	    var DefaultConfig = {
+	        description: '',
+	        driver: DefaultDriverOrder.slice(),
+	        name: 'localforage',
+	        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
+	        // we can use without a prompt.
+	        size: 4980736,
+	        storeName: 'keyvaluepairs',
+	        version: 1.0
+	    };
+
+	    // Check to see if IndexedDB is available and if it is the latest
+	    // implementation; it's our preferred backend library. We use "_spec_test"
+	    // as the name of the database because it's not the one we'll operate on,
+	    // but it's useful to make sure its using the right spec.
+	    // See: https://github.com/mozilla/localForage/issues/128
+	    var driverSupport = (function (self) {
+	        // Initialize IndexedDB; fall back to vendor-prefixed versions
+	        // if needed.
+	        var indexedDB = indexedDB || self.indexedDB || self.webkitIndexedDB || self.mozIndexedDB || self.OIndexedDB || self.msIndexedDB;
+
+	        var result = {};
+
+	        result[DriverType.WEBSQL] = !!self.openDatabase;
+	        result[DriverType.INDEXEDDB] = !!(function () {
+	            // We mimic PouchDB here; just UA test for Safari (which, as of
+	            // iOS 8/Yosemite, doesn't properly support IndexedDB).
+	            // IndexedDB support is broken and different from Blink's.
+	            // This is faster than the test case (and it's sync), so we just
+	            // do this. *SIGH*
+	            // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/
+	            //
+	            // We test for openDatabase because IE Mobile identifies itself
+	            // as Safari. Oh the lulz...
+	            if (typeof self.openDatabase !== 'undefined' && self.navigator && self.navigator.userAgent && /Safari/.test(self.navigator.userAgent) && !/Chrome/.test(self.navigator.userAgent)) {
+	                return false;
+	            }
+	            try {
+	                return indexedDB && typeof indexedDB.open === 'function' &&
+	                // Some Samsung/HTC Android 4.0-4.3 devices
+	                // have older IndexedDB specs; if this isn't available
+	                // their IndexedDB is too old for us to use.
+	                // (Replaces the onupgradeneeded test.)
+	                typeof self.IDBKeyRange !== 'undefined';
+	            } catch (e) {
+	                return false;
+	            }
+	        })();
+
+	        result[DriverType.LOCALSTORAGE] = !!(function () {
+	            try {
+	                return self.localStorage && 'setItem' in self.localStorage && self.localStorage.setItem;
+	            } catch (e) {
+	                return false;
+	            }
+	        })();
+
+	        return result;
+	    })(this);
+
+	    var isArray = Array.isArray || function (arg) {
+	        return Object.prototype.toString.call(arg) === '[object Array]';
+	    };
+
+	    function callWhenReady(localForageInstance, libraryMethod) {
+	        localForageInstance[libraryMethod] = function () {
+	            var _args = arguments;
+	            return localForageInstance.ready().then(function () {
+	                return localForageInstance[libraryMethod].apply(localForageInstance, _args);
+	            });
+	        };
+	    }
+
+	    function extend() {
+	        for (var i = 1; i < arguments.length; i++) {
+	            var arg = arguments[i];
+
+	            if (arg) {
+	                for (var key in arg) {
+	                    if (arg.hasOwnProperty(key)) {
+	                        if (isArray(arg[key])) {
+	                            arguments[0][key] = arg[key].slice();
+	                        } else {
+	                            arguments[0][key] = arg[key];
+	                        }
+	                    }
+	                }
+	            }
+	        }
+
+	        return arguments[0];
+	    }
+
+	    function isLibraryDriver(driverName) {
+	        for (var driver in DriverType) {
+	            if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {
+	                return true;
+	            }
+	        }
+
+	        return false;
+	    }
+
+	    var LocalForage = (function () {
+	        function LocalForage(options) {
+	            _classCallCheck(this, LocalForage);
+
+	            this.INDEXEDDB = DriverType.INDEXEDDB;
+	            this.LOCALSTORAGE = DriverType.LOCALSTORAGE;
+	            this.WEBSQL = DriverType.WEBSQL;
+
+	            this._defaultConfig = extend({}, DefaultConfig);
+	            this._config = extend({}, this._defaultConfig, options);
+	            this._driverSet = null;
+	            this._initDriver = null;
+	            this._ready = false;
+	            this._dbInfo = null;
+
+	            this._wrapLibraryMethodsWithReady();
+	            this.setDriver(this._config.driver);
+	        }
+
+	        // The actual localForage object that we expose as a module or via a
+	        // global. It's extended by pulling in one of our other libraries.
+
+	        // Set any config values for localForage; can be called anytime before
+	        // the first API call (e.g. `getItem`, `setItem`).
+	        // We loop through options so we don't overwrite existing config
+	        // values.
+
+	        LocalForage.prototype.config = function config(options) {
+	            // If the options argument is an object, we use it to set values.
+	            // Otherwise, we return either a specified config value or all
+	            // config values.
+	            if (typeof options === 'object') {
+	                // If localforage is ready and fully initialized, we can't set
+	                // any new configuration values. Instead, we return an error.
+	                if (this._ready) {
+	                    return new Error("Can't call config() after localforage " + 'has been used.');
+	                }
+
+	                for (var i in options) {
+	                    if (i === 'storeName') {
+	                        options[i] = options[i].replace(/\W/g, '_');
+	                    }
+
+	                    this._config[i] = options[i];
+	                }
+
+	                // after all config options are set and
+	                // the driver option is used, try setting it
+	                if ('driver' in options && options.driver) {
+	                    this.setDriver(this._config.driver);
+	                }
+
+	                return true;
+	            } else if (typeof options === 'string') {
+	                return this._config[options];
+	            } else {
+	                return this._config;
+	            }
+	        };
+
+	        // Used to define a custom driver, shared across all instances of
+	        // localForage.
+
+	        LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
+	            var promise = new Promise(function (resolve, reject) {
+	                try {
+	                    var driverName = driverObject._driver;
+	                    var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');
+	                    var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);
+
+	                    // A driver name should be defined and not overlap with the
+	                    // library-defined, default drivers.
+	                    if (!driverObject._driver) {
+	                        reject(complianceError);
+	                        return;
+	                    }
+	                    if (isLibraryDriver(driverObject._driver)) {
+	                        reject(namingError);
+	                        return;
+	                    }
+
+	                    var customDriverMethods = LibraryMethods.concat('_initStorage');
+	                    for (var i = 0; i < customDriverMethods.length; i++) {
+	                        var customDriverMethod = customDriverMethods[i];
+	                        if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {
+	                            reject(complianceError);
+	                            return;
+	                        }
+	                    }
+
+	                    var supportPromise = Promise.resolve(true);
+	                    if ('_support' in driverObject) {
+	                        if (driverObject._support && typeof driverObject._support === 'function') {
+	                            supportPromise = driverObject._support();
+	                        } else {
+	                            supportPromise = Promise.resolve(!!driverObject._support);
+	                        }
+	                    }
+
+	                    supportPromise.then(function (supportResult) {
+	                        driverSupport[driverName] = supportResult;
+	                        CustomDrivers[driverName] = driverObject;
+	                        resolve();
+	                    }, reject);
+	                } catch (e) {
+	                    reject(e);
+	                }
+	            });
+
+	            promise.then(callback, errorCallback);
+	            return promise;
+	        };
+
+	        LocalForage.prototype.driver = function driver() {
+	            return this._driver || null;
+	        };
+
+	        LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
+	            var self = this;
+	            var getDriverPromise = (function () {
+	                if (isLibraryDriver(driverName)) {
+	                    switch (driverName) {
+	                        case self.INDEXEDDB:
+	                            return new Promise(function (resolve, reject) {
+	                                resolve(__webpack_require__(1));
+	                            });
+	                        case self.LOCALSTORAGE:
+	                            return new Promise(function (resolve, reject) {
+	                                resolve(__webpack_require__(2));
+	                            });
+	                        case self.WEBSQL:
+	                            return new Promise(function (resolve, reject) {
+	                                resolve(__webpack_require__(4));
+	                            });
+	                    }
+	                } else if (CustomDrivers[driverName]) {
+	                    return Promise.resolve(CustomDrivers[driverName]);
+	                }
+
+	                return Promise.reject(new Error('Driver not found.'));
+	            })();
+
+	            getDriverPromise.then(callback, errorCallback);
+	            return getDriverPromise;
+	        };
+
+	        LocalForage.prototype.getSerializer = function getSerializer(callback) {
+	            var serializerPromise = new Promise(function (resolve, reject) {
+	                resolve(__webpack_require__(3));
+	            });
+	            if (callback && typeof callback === 'function') {
+	                serializerPromise.then(function (result) {
+	                    callback(result);
+	                });
+	            }
+	            return serializerPromise;
+	        };
+
+	        LocalForage.prototype.ready = function ready(callback) {
+	            var self = this;
+
+	            var promise = self._driverSet.then(function () {
+	                if (self._ready === null) {
+	                    self._ready = self._initDriver();
+	                }
+
+	                return self._ready;
+	            });
+
+	            promise.then(callback, callback);
+	            return promise;
+	        };
+
+	        LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
+	            var self = this;
+
+	            if (!isArray(drivers)) {
+	                drivers = [drivers];
+	            }
+
+	            var supportedDrivers = this._getSupportedDrivers(drivers);
+
+	            function setDriverToConfig() {
+	                self._config.driver = self.driver();
+	            }
+
+	            function initDriver(supportedDrivers) {
+	                return function () {
+	                    var currentDriverIndex = 0;
+
+	                    function driverPromiseLoop() {
+	                        while (currentDriverIndex < supportedDrivers.length) {
+	                            var driverName = supportedDrivers[currentDriverIndex];
+	                            currentDriverIndex++;
+
+	                            self._dbInfo = null;
+	                            self._ready = null;
+
+	                            return self.getDriver(driverName).then(function (driver) {
+	                                self._extend(driver);
+	                                setDriverToConfig();
+
+	                                self._ready = self._initStorage(self._config);
+	                                return self._ready;
+	                            })['catch'](driverPromiseLoop);
+	                        }
+
+	                        setDriverToConfig();
+	                        var error = new Error('No available storage method found.');
+	                        self._driverSet = Promise.reject(error);
+	                        return self._driverSet;
+	                    }
+
+	                    return driverPromiseLoop();
+	                };
+	            }
+
+	            // There might be a driver initialization in progress
+	            // so wait for it to finish in order to avoid a possible
+	            // race condition to set _dbInfo
+	            var oldDriverSetDone = this._driverSet !== null ? this._driverSet['catch'](function () {
+	                return Promise.resolve();
+	            }) : Promise.resolve();
+
+	            this._driverSet = oldDriverSetDone.then(function () {
+	                var driverName = supportedDrivers[0];
+	                self._dbInfo = null;
+	                self._ready = null;
+
+	                return self.getDriver(driverName).then(function (driver) {
+	                    self._driver = driver._driver;
+	                    setDriverToConfig();
+	                    self._wrapLibraryMethodsWithReady();
+	                    self._initDriver = initDriver(supportedDrivers);
+	                });
+	            })['catch'](function () {
+	                setDriverToConfig();
+	                var error = new Error('No available storage method found.');
+	                self._driverSet = Promise.reject(error);
+	                return self._driverSet;
+	            });
+
+	            this._driverSet.then(callback, errorCallback);
+	            return this._driverSet;
+	        };
+
+	        LocalForage.prototype.supports = function supports(driverName) {
+	            return !!driverSupport[driverName];
+	        };
+
+	        LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
+	            extend(this, libraryMethodsAndProperties);
+	        };
+
+	        LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
+	            var supportedDrivers = [];
+	            for (var i = 0, len = drivers.length; i < len; i++) {
+	                var driverName = drivers[i];
+	                if (this.supports(driverName)) {
+	                    supportedDrivers.push(driverName);
+	                }
+	            }
+	            return supportedDrivers;
+	        };
+
+	        LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
+	            // Add a stub for each driver API method that delays the call to the
+	            // corresponding driver method until localForage is ready. These stubs
+	            // will be replaced by the driver methods as soon as the driver is
+	            // loaded, so there is no performance impact.
+	            for (var i = 0; i < LibraryMethods.length; i++) {
+	                callWhenReady(this, LibraryMethods[i]);
+	            }
+	        };
+
+	        LocalForage.prototype.createInstance = function createInstance(options) {
+	            return new LocalForage(options);
+	        };
+
+	        return LocalForage;
+	    })();
+
+	    var localForage = new LocalForage();
+
+	    exports['default'] = localForage;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 1 */
+/***/ function(module, exports) {
+
+	// Some code originally from async_storage.js in
+	// [Gaia](https://github.com/mozilla-b2g/gaia).
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    var globalObject = this;
+	    // Initialize IndexedDB; fall back to vendor-prefixed versions if needed.
+	    var indexedDB = indexedDB || this.indexedDB || this.webkitIndexedDB || this.mozIndexedDB || this.OIndexedDB || this.msIndexedDB;
+
+	    // If IndexedDB isn't available, we get outta here!
+	    if (!indexedDB) {
+	        return;
+	    }
+
+	    var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
+	    var supportsBlobs;
+	    var dbContexts;
+
+	    // Abstracts constructing a Blob object, so it also works in older
+	    // browsers that don't support the native Blob constructor. (i.e.
+	    // old QtWebKit versions, at least).
+	    function _createBlob(parts, properties) {
+	        parts = parts || [];
+	        properties = properties || {};
+	        try {
+	            return new Blob(parts, properties);
+	        } catch (e) {
+	            if (e.name !== 'TypeError') {
+	                throw e;
+	            }
+	            var BlobBuilder = globalObject.BlobBuilder || globalObject.MSBlobBuilder || globalObject.MozBlobBuilder || globalObject.WebKitBlobBuilder;
+	            var builder = new BlobBuilder();
+	            for (var i = 0; i < parts.length; i += 1) {
+	                builder.append(parts[i]);
+	            }
+	            return builder.getBlob(properties.type);
+	        }
+	    }
+
+	    // Transform a binary string to an array buffer, because otherwise
+	    // weird stuff happens when you try to work with the binary string directly.
+	    // It is known.
+	    // From http://stackoverflow.com/questions/14967647/ (continues on next line)
+	    // encode-decode-image-with-base64-breaks-image (2013-04-21)
+	    function _binStringToArrayBuffer(bin) {
+	        var length = bin.length;
+	        var buf = new ArrayBuffer(length);
+	        var arr = new Uint8Array(buf);
+	        for (var i = 0; i < length; i++) {
+	            arr[i] = bin.charCodeAt(i);
+	        }
+	        return buf;
+	    }
+
+	    // Fetch a blob using ajax. This reveals bugs in Chrome < 43.
+	    // For details on all this junk:
+	    // https://github.com/nolanlawson/state-of-binary-data-in-the-browser#readme
+	    function _blobAjax(url) {
+	        return new Promise(function (resolve, reject) {
+	            var xhr = new XMLHttpRequest();
+	            xhr.open('GET', url);
+	            xhr.withCredentials = true;
+	            xhr.responseType = 'arraybuffer';
+
+	            xhr.onreadystatechange = function () {
+	                if (xhr.readyState !== 4) {
+	                    return;
+	                }
+	                if (xhr.status === 200) {
+	                    return resolve({
+	                        response: xhr.response,
+	                        type: xhr.getResponseHeader('Content-Type')
+	                    });
+	                }
+	                reject({ status: xhr.status, response: xhr.response });
+	            };
+	            xhr.send();
+	        });
+	    }
+
+	    //
+	    // Detect blob support. Chrome didn't support it until version 38.
+	    // In version 37 they had a broken version where PNGs (and possibly
+	    // other binary types) aren't stored correctly, because when you fetch
+	    // them, the content type is always null.
+	    //
+	    // Furthermore, they have some outstanding bugs where blobs occasionally
+	    // are read by FileReader as null, or by ajax as 404s.
+	    //
+	    // Sadly we use the 404 bug to detect the FileReader bug, so if they
+	    // get fixed independently and released in different versions of Chrome,
+	    // then the bug could come back. So it's worthwhile to watch these issues:
+	    // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
+	    // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
+	    //
+	    function _checkBlobSupportWithoutCaching(idb) {
+	        return new Promise(function (resolve, reject) {
+	            var blob = _createBlob([''], { type: 'image/png' });
+	            var txn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');
+	            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
+	            txn.oncomplete = function () {
+	                // have to do it in a separate transaction, else the correct
+	                // content type is always returned
+	                var blobTxn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');
+	                var getBlobReq = blobTxn.objectStore(DETECT_BLOB_SUPPORT_STORE).get('key');
+	                getBlobReq.onerror = reject;
+	                getBlobReq.onsuccess = function (e) {
+
+	                    var storedBlob = e.target.result;
+	                    var url = URL.createObjectURL(storedBlob);
+
+	                    _blobAjax(url).then(function (res) {
+	                        resolve(!!(res && res.type === 'image/png'));
+	                    }, function () {
+	                        resolve(false);
+	                    }).then(function () {
+	                        URL.revokeObjectURL(url);
+	                    });
+	                };
+	            };
+	        })['catch'](function () {
+	            return false; // error, so assume unsupported
+	        });
+	    }
+
+	    function _checkBlobSupport(idb) {
+	        if (typeof supportsBlobs === 'boolean') {
+	            return Promise.resolve(supportsBlobs);
+	        }
+	        return _checkBlobSupportWithoutCaching(idb).then(function (value) {
+	            supportsBlobs = value;
+	            return supportsBlobs;
+	        });
+	    }
+
+	    // encode a blob for indexeddb engines that don't support blobs
+	    function _encodeBlob(blob) {
+	        return new Promise(function (resolve, reject) {
+	            var reader = new FileReader();
+	            reader.onerror = reject;
+	            reader.onloadend = function (e) {
+	                var base64 = btoa(e.target.result || '');
+	                resolve({
+	                    __local_forage_encoded_blob: true,
+	                    data: base64,
+	                    type: blob.type
+	                });
+	            };
+	            reader.readAsBinaryString(blob);
+	        });
+	    }
+
+	    // decode an encoded blob
+	    function _decodeBlob(encodedBlob) {
+	        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
+	        return _createBlob([arrayBuff], { type: encodedBlob.type });
+	    }
+
+	    // is this one of our fancy encoded blobs?
+	    function _isEncodedBlob(value) {
+	        return value && value.__local_forage_encoded_blob;
+	    }
+
+	    // Open the IndexedDB database (automatically creates one if one didn't
+	    // previously exist), using any options set in the config.
+	    function _initStorage(options) {
+	        var self = this;
+	        var dbInfo = {
+	            db: null
+	        };
+
+	        if (options) {
+	            for (var i in options) {
+	                dbInfo[i] = options[i];
+	            }
+	        }
+
+	        // Initialize a singleton container for all running localForages.
+	        if (!dbContexts) {
+	            dbContexts = {};
+	        }
+
+	        // Get the current context of the database;
+	        var dbContext = dbContexts[dbInfo.name];
+
+	        // ...or create a new context.
+	        if (!dbContext) {
+	            dbContext = {
+	                // Running localForages sharing a database.
+	                forages: [],
+	                // Shared database.
+	                db: null
+	            };
+	            // Register the new context in the global container.
+	            dbContexts[dbInfo.name] = dbContext;
+	        }
+
+	        // Register itself as a running localForage in the current context.
+	        dbContext.forages.push(this);
+
+	        // Create an array of readiness of the related localForages.
+	        var readyPromises = [];
+
+	        function ignoreErrors() {
+	            // Don't handle errors here,
+	            // just makes sure related localForages aren't pending.
+	            return Promise.resolve();
+	        }
+
+	        for (var j = 0; j < dbContext.forages.length; j++) {
+	            var forage = dbContext.forages[j];
+	            if (forage !== this) {
+	                // Don't wait for itself...
+	                readyPromises.push(forage.ready()['catch'](ignoreErrors));
+	            }
+	        }
+
+	        // Take a snapshot of the related localForages.
+	        var forages = dbContext.forages.slice(0);
+
+	        // Initialize the connection process only when
+	        // all the related localForages aren't pending.
+	        return Promise.all(readyPromises).then(function () {
+	            dbInfo.db = dbContext.db;
+	            // Get the connection or open a new one without upgrade.
+	            return _getOriginalConnection(dbInfo);
+	        }).then(function (db) {
+	            dbInfo.db = db;
+	            if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
+	                // Reopen the database for upgrading.
+	                return _getUpgradedConnection(dbInfo);
+	            }
+	            return db;
+	        }).then(function (db) {
+	            dbInfo.db = dbContext.db = db;
+	            self._dbInfo = dbInfo;
+	            // Share the final connection amongst related localForages.
+	            for (var k in forages) {
+	                var forage = forages[k];
+	                if (forage !== self) {
+	                    // Self is already up-to-date.
+	                    forage._dbInfo.db = dbInfo.db;
+	                    forage._dbInfo.version = dbInfo.version;
+	                }
+	            }
+	        });
+	    }
+
+	    function _getOriginalConnection(dbInfo) {
+	        return _getConnection(dbInfo, false);
+	    }
+
+	    function _getUpgradedConnection(dbInfo) {
+	        return _getConnection(dbInfo, true);
+	    }
+
+	    function _getConnection(dbInfo, upgradeNeeded) {
+	        return new Promise(function (resolve, reject) {
+	            if (dbInfo.db) {
+	                if (upgradeNeeded) {
+	                    dbInfo.db.close();
+	                } else {
+	                    return resolve(dbInfo.db);
+	                }
+	            }
+
+	            var dbArgs = [dbInfo.name];
+
+	            if (upgradeNeeded) {
+	                dbArgs.push(dbInfo.version);
+	            }
+
+	            var openreq = indexedDB.open.apply(indexedDB, dbArgs);
+
+	            if (upgradeNeeded) {
+	                openreq.onupgradeneeded = function (e) {
+	                    var db = openreq.result;
+	                    try {
+	                        db.createObjectStore(dbInfo.storeName);
+	                        if (e.oldVersion <= 1) {
+	                            // Added when support for blob shims was added
+	                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
+	                        }
+	                    } catch (ex) {
+	                        if (ex.name === 'ConstraintError') {
+	                            globalObject.console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
+	                        } else {
+	                            throw ex;
+	                        }
+	                    }
+	                };
+	            }
+
+	            openreq.onerror = function () {
+	                reject(openreq.error);
+	            };
+
+	            openreq.onsuccess = function () {
+	                resolve(openreq.result);
+	            };
+	        });
+	    }
+
+	    function _isUpgradeNeeded(dbInfo, defaultVersion) {
+	        if (!dbInfo.db) {
+	            return true;
+	        }
+
+	        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
+	        var isDowngrade = dbInfo.version < dbInfo.db.version;
+	        var isUpgrade = dbInfo.version > dbInfo.db.version;
+
+	        if (isDowngrade) {
+	            // If the version is not the default one
+	            // then warn for impossible downgrade.
+	            if (dbInfo.version !== defaultVersion) {
+	                globalObject.console.warn('The database "' + dbInfo.name + '"' + ' can\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
+	            }
+	            // Align the versions to prevent errors.
+	            dbInfo.version = dbInfo.db.version;
+	        }
+
+	        if (isUpgrade || isNewStore) {
+	            // If the store is new then increment the version (if needed).
+	            // This will trigger an "upgradeneeded" event which is required
+	            // for creating a store.
+	            if (isNewStore) {
+	                var incVersion = dbInfo.db.version + 1;
+	                if (incVersion > dbInfo.version) {
+	                    dbInfo.version = incVersion;
+	                }
+	            }
+
+	            return true;
+	        }
+
+	        return false;
+	    }
+
+	    function getItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+	                var req = store.get(key);
+
+	                req.onsuccess = function () {
+	                    var value = req.result;
+	                    if (value === undefined) {
+	                        value = null;
+	                    }
+	                    if (_isEncodedBlob(value)) {
+	                        value = _decodeBlob(value);
+	                    }
+	                    resolve(value);
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Iterate over all items stored in database.
+	    function iterate(iterator, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+
+	                var req = store.openCursor();
+	                var iterationNumber = 1;
+
+	                req.onsuccess = function () {
+	                    var cursor = req.result;
+
+	                    if (cursor) {
+	                        var value = cursor.value;
+	                        if (_isEncodedBlob(value)) {
+	                            value = _decodeBlob(value);
+	                        }
+	                        var result = iterator(value, cursor.key, iterationNumber++);
+
+	                        if (result !== void 0) {
+	                            resolve(result);
+	                        } else {
+	                            cursor['continue']();
+	                        }
+	                    } else {
+	                        resolve();
+	                    }
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+
+	        return promise;
+	    }
+
+	    function setItem(key, value, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            var dbInfo;
+	            self.ready().then(function () {
+	                dbInfo = self._dbInfo;
+	                return _checkBlobSupport(dbInfo.db);
+	            }).then(function (blobSupport) {
+	                if (!blobSupport && value instanceof Blob) {
+	                    return _encodeBlob(value);
+	                }
+	                return value;
+	            }).then(function (value) {
+	                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
+	                var store = transaction.objectStore(dbInfo.storeName);
+
+	                // The reason we don't _save_ null is because IE 10 does
+	                // not support saving the `null` type in IndexedDB. How
+	                // ironic, given the bug below!
+	                // See: https://github.com/mozilla/localForage/issues/161
+	                if (value === null) {
+	                    value = undefined;
+	                }
+
+	                var req = store.put(value, key);
+	                transaction.oncomplete = function () {
+	                    // Cast to undefined so the value passed to
+	                    // callback/promise is the same as what one would get out
+	                    // of `getItem()` later. This leads to some weirdness
+	                    // (setItem('foo', undefined) will return `null`), but
+	                    // it's not my fault localStorage is our baseline and that
+	                    // it's weird.
+	                    if (value === undefined) {
+	                        value = null;
+	                    }
+
+	                    resolve(value);
+	                };
+	                transaction.onabort = transaction.onerror = function () {
+	                    var err = req.error ? req.error : req.transaction.error;
+	                    reject(err);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function removeItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
+	                var store = transaction.objectStore(dbInfo.storeName);
+
+	                // We use a Grunt task to make this safe for IE and some
+	                // versions of Android (including those used by Cordova).
+	                // Normally IE won't like `.delete()` and will insist on
+	                // using `['delete']()`, but we have a build step that
+	                // fixes this for us now.
+	                var req = store['delete'](key);
+	                transaction.oncomplete = function () {
+	                    resolve();
+	                };
+
+	                transaction.onerror = function () {
+	                    reject(req.error);
+	                };
+
+	                // The request will be also be aborted if we've exceeded our storage
+	                // space.
+	                transaction.onabort = function () {
+	                    var err = req.error ? req.error : req.transaction.error;
+	                    reject(err);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function clear(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
+	                var store = transaction.objectStore(dbInfo.storeName);
+	                var req = store.clear();
+
+	                transaction.oncomplete = function () {
+	                    resolve();
+	                };
+
+	                transaction.onabort = transaction.onerror = function () {
+	                    var err = req.error ? req.error : req.transaction.error;
+	                    reject(err);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function length(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+	                var req = store.count();
+
+	                req.onsuccess = function () {
+	                    resolve(req.result);
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function key(n, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            if (n < 0) {
+	                resolve(null);
+
+	                return;
+	            }
+
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+
+	                var advanced = false;
+	                var req = store.openCursor();
+	                req.onsuccess = function () {
+	                    var cursor = req.result;
+	                    if (!cursor) {
+	                        // this means there weren't enough keys
+	                        resolve(null);
+
+	                        return;
+	                    }
+
+	                    if (n === 0) {
+	                        // We have the first key, return it if that's what they
+	                        // wanted.
+	                        resolve(cursor.key);
+	                    } else {
+	                        if (!advanced) {
+	                            // Otherwise, ask the cursor to skip ahead n
+	                            // records.
+	                            advanced = true;
+	                            cursor.advance(n);
+	                        } else {
+	                            // When we get here, we've got the nth key.
+	                            resolve(cursor.key);
+	                        }
+	                    }
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function keys(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+
+	                var req = store.openCursor();
+	                var keys = [];
+
+	                req.onsuccess = function () {
+	                    var cursor = req.result;
+
+	                    if (!cursor) {
+	                        resolve(keys);
+	                        return;
+	                    }
+
+	                    keys.push(cursor.key);
+	                    cursor['continue']();
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function executeCallback(promise, callback) {
+	        if (callback) {
+	            promise.then(function (result) {
+	                callback(null, result);
+	            }, function (error) {
+	                callback(error);
+	            });
+	        }
+	    }
+
+	    var asyncStorage = {
+	        _driver: 'asyncStorage',
+	        _initStorage: _initStorage,
+	        iterate: iterate,
+	        getItem: getItem,
+	        setItem: setItem,
+	        removeItem: removeItem,
+	        clear: clear,
+	        length: length,
+	        key: key,
+	        keys: keys
+	    };
+
+	    exports['default'] = asyncStorage;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 2 */
+/***/ function(module, exports, __webpack_require__) {
+
+	// If IndexedDB isn't available, we'll fall back to localStorage.
+	// Note that this will have considerable performance and storage
+	// side-effects (all data will be serialized on save and only data that
+	// can be converted to a string via `JSON.stringify()` will be saved).
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    var globalObject = this;
+	    var localStorage = null;
+
+	    // If the app is running inside a Google Chrome packaged webapp, or some
+	    // other context where localStorage isn't available, we don't use
+	    // localStorage. This feature detection is preferred over the old
+	    // `if (window.chrome && window.chrome.runtime)` code.
+	    // See: https://github.com/mozilla/localForage/issues/68
+	    try {
+	        // If localStorage isn't available, we get outta here!
+	        // This should be inside a try catch
+	        if (!this.localStorage || !('setItem' in this.localStorage)) {
+	            return;
+	        }
+	        // Initialize localStorage and create a variable to use throughout
+	        // the code.
+	        localStorage = this.localStorage;
+	    } catch (e) {
+	        return;
+	    }
+
+	    // Config the localStorage backend, using options set in the config.
+	    function _initStorage(options) {
+	        var self = this;
+	        var dbInfo = {};
+	        if (options) {
+	            for (var i in options) {
+	                dbInfo[i] = options[i];
+	            }
+	        }
+
+	        dbInfo.keyPrefix = dbInfo.name + '/';
+
+	        if (dbInfo.storeName !== self._defaultConfig.storeName) {
+	            dbInfo.keyPrefix += dbInfo.storeName + '/';
+	        }
+
+	        self._dbInfo = dbInfo;
+
+	        return new Promise(function (resolve, reject) {
+	            resolve(__webpack_require__(3));
+	        }).then(function (lib) {
+	            dbInfo.serializer = lib;
+	            return Promise.resolve();
+	        });
+	    }
+
+	    // Remove all keys from the datastore, effectively destroying all data in
+	    // the app's key/value store!
+	    function clear(callback) {
+	        var self = this;
+	        var promise = self.ready().then(function () {
+	            var keyPrefix = self._dbInfo.keyPrefix;
+
+	            for (var i = localStorage.length - 1; i >= 0; i--) {
+	                var key = localStorage.key(i);
+
+	                if (key.indexOf(keyPrefix) === 0) {
+	                    localStorage.removeItem(key);
+	                }
+	            }
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Retrieve an item from the store. Unlike the original async_storage
+	    // library in Gaia, we don't modify return values at all. If a key's value
+	    // is `undefined`, we pass that value to the callback function.
+	    function getItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var result = localStorage.getItem(dbInfo.keyPrefix + key);
+
+	            // If a result was found, parse it from the serialized
+	            // string into a JS object. If result isn't truthy, the key
+	            // is likely undefined and we'll pass it straight to the
+	            // callback.
+	            if (result) {
+	                result = dbInfo.serializer.deserialize(result);
+	            }
+
+	            return result;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Iterate over all items in the store.
+	    function iterate(iterator, callback) {
+	        var self = this;
+
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var keyPrefix = dbInfo.keyPrefix;
+	            var keyPrefixLength = keyPrefix.length;
+	            var length = localStorage.length;
+
+	            // We use a dedicated iterator instead of the `i` variable below
+	            // so other keys we fetch in localStorage aren't counted in
+	            // the `iterationNumber` argument passed to the `iterate()`
+	            // callback.
+	            //
+	            // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
+	            var iterationNumber = 1;
+
+	            for (var i = 0; i < length; i++) {
+	                var key = localStorage.key(i);
+	                if (key.indexOf(keyPrefix) !== 0) {
+	                    continue;
+	                }
+	                var value = localStorage.getItem(key);
+
+	                // If a result was found, parse it from the serialized
+	                // string into a JS object. If result isn't truthy, the
+	                // key is likely undefined and we'll pass it straight
+	                // to the iterator.
+	                if (value) {
+	                    value = dbInfo.serializer.deserialize(value);
+	                }
+
+	                value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);
+
+	                if (value !== void 0) {
+	                    return value;
+	                }
+	            }
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Same as localStorage's key() method, except takes a callback.
+	    function key(n, callback) {
+	        var self = this;
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var result;
+	            try {
+	                result = localStorage.key(n);
+	            } catch (error) {
+	                result = null;
+	            }
+
+	            // Remove the prefix from the key, if a key is found.
+	            if (result) {
+	                result = result.substring(dbInfo.keyPrefix.length);
+	            }
+
+	            return result;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function keys(callback) {
+	        var self = this;
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var length = localStorage.length;
+	            var keys = [];
+
+	            for (var i = 0; i < length; i++) {
+	                if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {
+	                    keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));
+	                }
+	            }
+
+	            return keys;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Supply the number of keys in the datastore to the callback function.
+	    function length(callback) {
+	        var self = this;
+	        var promise = self.keys().then(function (keys) {
+	            return keys.length;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Remove an item from the store, nice and simple.
+	    function removeItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            localStorage.removeItem(dbInfo.keyPrefix + key);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Set a key's value and run an optional callback once the value is set.
+	    // Unlike Gaia's implementation, the callback function is passed the value,
+	    // in case you want to operate on that value only after you're sure it
+	    // saved, or something like that.
+	    function setItem(key, value, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = self.ready().then(function () {
+	            // Convert undefined values to null.
+	            // https://github.com/mozilla/localForage/pull/42
+	            if (value === undefined) {
+	                value = null;
+	            }
+
+	            // Save the original value to pass to the callback.
+	            var originalValue = value;
+
+	            return new Promise(function (resolve, reject) {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.serializer.serialize(value, function (value, error) {
+	                    if (error) {
+	                        reject(error);
+	                    } else {
+	                        try {
+	                            localStorage.setItem(dbInfo.keyPrefix + key, value);
+	                            resolve(originalValue);
+	                        } catch (e) {
+	                            // localStorage capacity exceeded.
+	                            // TODO: Make this a specific error/event.
+	                            if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
+	                                reject(e);
+	                            }
+	                            reject(e);
+	                        }
+	                    }
+	                });
+	            });
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function executeCallback(promise, callback) {
+	        if (callback) {
+	            promise.then(function (result) {
+	                callback(null, result);
+	            }, function (error) {
+	                callback(error);
+	            });
+	        }
+	    }
+
+	    var localStorageWrapper = {
+	        _driver: 'localStorageWrapper',
+	        _initStorage: _initStorage,
+	        // Default API, from Gaia/localStorage.
+	        iterate: iterate,
+	        getItem: getItem,
+	        setItem: setItem,
+	        removeItem: removeItem,
+	        clear: clear,
+	        length: length,
+	        key: key,
+	        keys: keys
+	    };
+
+	    exports['default'] = localStorageWrapper;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 3 */
+/***/ function(module, exports) {
+
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    // Sadly, the best way to save binary data in WebSQL/localStorage is serializing
+	    // it to Base64, so this is how we store it to prevent very strange errors with less
+	    // verbose ways of binary <-> string data storage.
+	    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+
+	    var BLOB_TYPE_PREFIX = '~~local_forage_type~';
+	    var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
+
+	    var SERIALIZED_MARKER = '__lfsc__:';
+	    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
+
+	    // OMG the serializations!
+	    var TYPE_ARRAYBUFFER = 'arbf';
+	    var TYPE_BLOB = 'blob';
+	    var TYPE_INT8ARRAY = 'si08';
+	    var TYPE_UINT8ARRAY = 'ui08';
+	    var TYPE_UINT8CLAMPEDARRAY = 'uic8';
+	    var TYPE_INT16ARRAY = 'si16';
+	    var TYPE_INT32ARRAY = 'si32';
+	    var TYPE_UINT16ARRAY = 'ur16';
+	    var TYPE_UINT32ARRAY = 'ui32';
+	    var TYPE_FLOAT32ARRAY = 'fl32';
+	    var TYPE_FLOAT64ARRAY = 'fl64';
+	    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
+
+	    // Get out of our habit of using `window` inline, at least.
+	    var globalObject = this;
+
+	    // Abstracts constructing a Blob object, so it also works in older
+	    // browsers that don't support the native Blob constructor. (i.e.
+	    // old QtWebKit versions, at least).
+	    function _createBlob(parts, properties) {
+	        parts = parts || [];
+	        properties = properties || {};
+
+	        try {
+	            return new Blob(parts, properties);
+	        } catch (err) {
+	            if (err.name !== 'TypeError') {
+	                throw err;
+	            }
+
+	            var BlobBuilder = globalObject.BlobBuilder || globalObject.MSBlobBuilder || globalObject.MozBlobBuilder || globalObject.WebKitBlobBuilder;
+
+	            var builder = new BlobBuilder();
+	            for (var i = 0; i < parts.length; i += 1) {
+	                builder.append(parts[i]);
+	            }
+
+	            return builder.getBlob(properties.type);
+	        }
+	    }
+
+	    // Serialize a value, afterwards executing a callback (which usually
+	    // instructs the `setItem()` callback/promise to be executed). This is how
+	    // we store binary data with localStorage.
+	    function serialize(value, callback) {
+	        var valueString = '';
+	        if (value) {
+	            valueString = value.toString();
+	        }
+
+	        // Cannot use `value instanceof ArrayBuffer` or such here, as these
+	        // checks fail when running the tests using casper.js...
+	        //
+	        // TODO: See why those tests fail and use a better solution.
+	        if (value && (value.toString() === '[object ArrayBuffer]' || value.buffer && value.buffer.toString() === '[object ArrayBuffer]')) {
+	            // Convert binary arrays to a string and prefix the string with
+	            // a special marker.
+	            var buffer;
+	            var marker = SERIALIZED_MARKER;
+
+	            if (value instanceof ArrayBuffer) {
+	                buffer = value;
+	                marker += TYPE_ARRAYBUFFER;
+	            } else {
+	                buffer = value.buffer;
+
+	                if (valueString === '[object Int8Array]') {
+	                    marker += TYPE_INT8ARRAY;
+	                } else if (valueString === '[object Uint8Array]') {
+	                    marker += TYPE_UINT8ARRAY;
+	                } else if (valueString === '[object Uint8ClampedArray]') {
+	                    marker += TYPE_UINT8CLAMPEDARRAY;
+	                } else if (valueString === '[object Int16Array]') {
+	                    marker += TYPE_INT16ARRAY;
+	                } else if (valueString === '[object Uint16Array]') {
+	                    marker += TYPE_UINT16ARRAY;
+	                } else if (valueString === '[object Int32Array]') {
+	                    marker += TYPE_INT32ARRAY;
+	                } else if (valueString === '[object Uint32Array]') {
+	                    marker += TYPE_UINT32ARRAY;
+	                } else if (valueString === '[object Float32Array]') {
+	                    marker += TYPE_FLOAT32ARRAY;
+	                } else if (valueString === '[object Float64Array]') {
+	                    marker += TYPE_FLOAT64ARRAY;
+	                } else {
+	                    callback(new Error('Failed to get type for BinaryArray'));
+	                }
+	            }
+
+	            callback(marker + bufferToString(buffer));
+	        } else if (valueString === '[object Blob]') {
+	            // Conver the blob to a binaryArray and then to a string.
+	            var fileReader = new FileReader();
+
+	            fileReader.onload = function () {
+	                // Backwards-compatible prefix for the blob type.
+	                var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);
+
+	                callback(SERIALIZED_MARKER + TYPE_BLOB + str);
+	            };
+
+	            fileReader.readAsArrayBuffer(value);
+	        } else {
+	            try {
+	                callback(JSON.stringify(value));
+	            } catch (e) {
+	                console.error("Couldn't convert value into a JSON string: ", value);
+
+	                callback(null, e);
+	            }
+	        }
+	    }
+
+	    // Deserialize data we've inserted into a value column/field. We place
+	    // special markers into our strings to mark them as encoded; this isn't
+	    // as nice as a meta field, but it's the only sane thing we can do whilst
+	    // keeping localStorage support intact.
+	    //
+	    // Oftentimes this will just deserialize JSON content, but if we have a
+	    // special marker (SERIALIZED_MARKER, defined above), we will extract
+	    // some kind of arraybuffer/binary data/typed array out of the string.
+	    function deserialize(value) {
+	        // If we haven't marked this string as being specially serialized (i.e.
+	        // something other than serialized JSON), we can just return it and be
+	        // done with it.
+	        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
+	            return JSON.parse(value);
+	        }
+
+	        // The following code deals with deserializing some kind of Blob or
+	        // TypedArray. First we separate out the type of data we're dealing
+	        // with from the data itself.
+	        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
+	        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
+
+	        var blobType;
+	        // Backwards-compatible blob type serialization strategy.
+	        // DBs created with older versions of localForage will simply not have the blob type.
+	        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
+	            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
+	            blobType = matcher[1];
+	            serializedString = serializedString.substring(matcher[0].length);
+	        }
+	        var buffer = stringToBuffer(serializedString);
+
+	        // Return the right type based on the code/type set during
+	        // serialization.
+	        switch (type) {
+	            case TYPE_ARRAYBUFFER:
+	                return buffer;
+	            case TYPE_BLOB:
+	                return _createBlob([buffer], { type: blobType });
+	            case TYPE_INT8ARRAY:
+	                return new Int8Array(buffer);
+	            case TYPE_UINT8ARRAY:
+	                return new Uint8Array(buffer);
+	            case TYPE_UINT8CLAMPEDARRAY:
+	                return new Uint8ClampedArray(buffer);
+	            case TYPE_INT16ARRAY:
+	                return new Int16Array(buffer);
+	            case TYPE_UINT16ARRAY:
+	                return new Uint16Array(buffer);
+	            case TYPE_INT32ARRAY:
+	                return new Int32Array(buffer);
+	            case TYPE_UINT32ARRAY:
+	                return new Uint32Array(buffer);
+	            case TYPE_FLOAT32ARRAY:
+	                return new Float32Array(buffer);
+	            case TYPE_FLOAT64ARRAY:
+	                return new Float64Array(buffer);
+	            default:
+	                throw new Error('Unkown type: ' + type);
+	        }
+	    }
+
+	    function stringToBuffer(serializedString) {
+	        // Fill the string into a ArrayBuffer.
+	        var bufferLength = serializedString.length * 0.75;
+	        var len = serializedString.length;
+	        var i;
+	        var p = 0;
+	        var encoded1, encoded2, encoded3, encoded4;
+
+	        if (serializedString[serializedString.length - 1] === '=') {
+	            bufferLength--;
+	            if (serializedString[serializedString.length - 2] === '=') {
+	                bufferLength--;
+	            }
+	        }
+
+	        var buffer = new ArrayBuffer(bufferLength);
+	        var bytes = new Uint8Array(buffer);
+
+	        for (i = 0; i < len; i += 4) {
+	            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
+	            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
+	            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
+	            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
+
+	            /*jslint bitwise: true */
+	            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
+	            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
+	            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
+	        }
+	        return buffer;
+	    }
+
+	    // Converts a buffer to a string to store, serialized, in the backend
+	    // storage library.
+	    function bufferToString(buffer) {
+	        // base64-arraybuffer
+	        var bytes = new Uint8Array(buffer);
+	        var base64String = '';
+	        var i;
+
+	        for (i = 0; i < bytes.length; i += 3) {
+	            /*jslint bitwise: true */
+	            base64String += BASE_CHARS[bytes[i] >> 2];
+	            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
+	            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
+	            base64String += BASE_CHARS[bytes[i + 2] & 63];
+	        }
+
+	        if (bytes.length % 3 === 2) {
+	            base64String = base64String.substring(0, base64String.length - 1) + '=';
+	        } else if (bytes.length % 3 === 1) {
+	            base64String = base64String.substring(0, base64String.length - 2) + '==';
+	        }
+
+	        return base64String;
+	    }
+
+	    var localforageSerializer = {
+	        serialize: serialize,
+	        deserialize: deserialize,
+	        stringToBuffer: stringToBuffer,
+	        bufferToString: bufferToString
+	    };
+
+	    exports['default'] = localforageSerializer;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 4 */
+/***/ function(module, exports, __webpack_require__) {
+
+	/*
+	 * Includes code from:
+	 *
+	 * base64-arraybuffer
+	 * https://github.com/niklasvh/base64-arraybuffer
+	 *
+	 * Copyright (c) 2012 Niklas von Hertzen
+	 * Licensed under the MIT license.
+	 */
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    var globalObject = this;
+	    var openDatabase = this.openDatabase;
+
+	    // If WebSQL methods aren't available, we can stop now.
+	    if (!openDatabase) {
+	        return;
+	    }
+
+	    // Open the WebSQL database (automatically creates one if one didn't
+	    // previously exist), using any options set in the config.
+	    function _initStorage(options) {
+	        var self = this;
+	        var dbInfo = {
+	            db: null
+	        };
+
+	        if (options) {
+	            for (var i in options) {
+	                dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
+	            }
+	        }
+
+	        var dbInfoPromise = new Promise(function (resolve, reject) {
+	            // Open the database; the openDatabase API will automatically
+	            // create it for us if it doesn't exist.
+	            try {
+	                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
+	            } catch (e) {
+	                return self.setDriver(self.LOCALSTORAGE).then(function () {
+	                    return self._initStorage(options);
+	                }).then(resolve)['catch'](reject);
+	            }
+
+	            // Create our key/value table if it doesn't exist.
+	            dbInfo.db.transaction(function (t) {
+	                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {
+	                    self._dbInfo = dbInfo;
+	                    resolve();
+	                }, function (t, error) {
+	                    reject(error);
+	                });
+	            });
+	        });
+
+	        return new Promise(function (resolve, reject) {
+	            resolve(__webpack_require__(3));
+	        }).then(function (lib) {
+	            dbInfo.serializer = lib;
+	            return dbInfoPromise;
+	        });
+	    }
+
+	    function getItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
+	                        var result = results.rows.length ? results.rows.item(0).value : null;
+
+	                        // Check to see if this is serialized content we need to
+	                        // unpack.
+	                        if (result) {
+	                            result = dbInfo.serializer.deserialize(result);
+	                        }
+
+	                        resolve(result);
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function iterate(iterator, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
+	                        var rows = results.rows;
+	                        var length = rows.length;
+
+	                        for (var i = 0; i < length; i++) {
+	                            var item = rows.item(i);
+	                            var result = item.value;
+
+	                            // Check to see if this is serialized content
+	                            // we need to unpack.
+	                            if (result) {
+	                                result = dbInfo.serializer.deserialize(result);
+	                            }
+
+	                            result = iterator(result, item.key, i + 1);
+
+	                            // void(0) prevents problems with redefinition
+	                            // of `undefined`.
+	                            if (result !== void 0) {
+	                                resolve(result);
+	                                return;
+	                            }
+	                        }
+
+	                        resolve();
+	                    }, function (t, error) {
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function setItem(key, value, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                // The localStorage API doesn't return undefined values in an
+	                // "expected" way, so undefined is always cast to null in all
+	                // drivers. See: https://github.com/mozilla/localForage/pull/42
+	                if (value === undefined) {
+	                    value = null;
+	                }
+
+	                // Save the original value to pass to the callback.
+	                var originalValue = value;
+
+	                var dbInfo = self._dbInfo;
+	                dbInfo.serializer.serialize(value, function (value, error) {
+	                    if (error) {
+	                        reject(error);
+	                    } else {
+	                        dbInfo.db.transaction(function (t) {
+	                            t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {
+	                                resolve(originalValue);
+	                            }, function (t, error) {
+	                                reject(error);
+	                            });
+	                        }, function (sqlError) {
+	                            // The transaction failed; check
+	                            // to see if it's a quota error.
+	                            if (sqlError.code === sqlError.QUOTA_ERR) {
+	                                // We reject the callback outright for now, but
+	                                // it's worth trying to re-run the transaction.
+	                                // Even if the user accepts the prompt to use
+	                                // more storage on Safari, this error will
+	                                // be called.
+	                                //
+	                                // TODO: Try to re-run the transaction.
+	                                reject(sqlError);
+	                            }
+	                        });
+	                    }
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function removeItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
+	                        resolve();
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Deletes every item in the table.
+	    // TODO: Find out if this resets the AUTO_INCREMENT number.
+	    function clear(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {
+	                        resolve();
+	                    }, function (t, error) {
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Does a simple `COUNT(key)` to get the number of items stored in
+	    // localForage.
+	    function length(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    // Ahhh, SQL makes this one soooooo easy.
+	                    t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
+	                        var result = results.rows.item(0).c;
+
+	                        resolve(result);
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Return the key located at key index X; essentially gets the key from a
+	    // `WHERE id = ?`. This is the most efficient way I can think to implement
+	    // this rarely-used (in my experience) part of the API, but it can seem
+	    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
+	    // the ID of each key will change every time it's updated. Perhaps a stored
+	    // procedure for the `setItem()` SQL would solve this problem?
+	    // TODO: Don't change ID on `setItem()`.
+	    function key(n, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
+	                        var result = results.rows.length ? results.rows.item(0).key : null;
+	                        resolve(result);
+	                    }, function (t, error) {
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function keys(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
+	                        var keys = [];
+
+	                        for (var i = 0; i < results.rows.length; i++) {
+	                            keys.push(results.rows.item(i).key);
+	                        }
+
+	                        resolve(keys);
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function executeCallback(promise, callback) {
+	        if (callback) {
+	            promise.then(function (result) {
+	                callback(null, result);
+	            }, function (error) {
+	                callback(error);
+	            });
+	        }
+	    }
+
+	    var webSQLStorage = {
+	        _driver: 'webSQLStorage',
+	        _initStorage: _initStorage,
+	        iterate: iterate,
+	        getItem: getItem,
+	        setItem: setItem,
+	        removeItem: removeItem,
+	        clear: clear,
+	        length: length,
+	        key: key,
+	        keys: keys
+	    };
+
+	    exports['default'] = webSQLStorage;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ }
+/******/ ])
 });
-
-},{}],19:[function(require,module,exports){
+;
+},{"__browserify_process":4}],19:[function(require,module,exports){
 //     Underscore.js 1.4.4
 //     http://underscorejs.org
 //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
diff --git a/browser-version/out/nedb.min.js b/browser-version/out/nedb.min.js
index 07d4361..fc05616 100755
--- a/browser-version/out/nedb.min.js
+++ b/browser-version/out/nedb.min.js
@@ -1,4 +1,4 @@
-!function(e){if("function"==typeof bootstrap)bootstrap("nedb",e);else if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else if("undefined"!=typeof ses){if(!ses.ok())return;ses.makeNedb=e}else"undefined"!=typeof window?window.Nedb=e():global.Nedb=e()}(function(){var e;return function(e,t,n){function r(n,o){if(!t[n]){if(!e[n]){var a="function"==typeof require&&require;if(!o&&a)return a(n,!0);if(i)return i(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var i=e[n][1][t];return r(i?i:t)},u,u.exports)}return t[n].exports}for(var i="function"==typeof require&&require,o=0;o<n.length;o++)r(n[o]);return r}({1:[function(e,t,n){function r(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0;n<e.length;n++)if(t===e[n])return n;return-1}var i=e("__browserify_process");i.EventEmitter||(i.EventEmitter=function(){});var o=n.EventEmitter=i.EventEmitter,a="function"==typeof Array.isArray?Array.isArray:function(e){return"[object Array]"===Object.prototype.toString.call(e)},u=10;o.prototype.setMaxListeners=function(e){this._events||(this._events={}),this._events.maxListeners=e},o.prototype.emit=function(e){if("error"===e&&(!this._events||!this._events.error||a(this._events.error)&&!this._events.error.length))throw arguments[1]instanceof Error?arguments[1]:new Error("Uncaught, unspecified 'error' event.");if(!this._events)return!1;var t=this._events[e];if(!t)return!1;if("function"==typeof t){switch(arguments.length){case 1:t.call(this);break;case 2:t.call(this,arguments[1]);break;case 3:t.call(this,arguments[1],arguments[2]);break;default:var n=Array.prototype.slice.call(arguments,1);t.apply(this,n)}return!0}if(a(t)){for(var n=Array.prototype.slice.call(arguments,1),r=t.slice(),i=0,o=r.length;o>i;i++)r[i].apply(this,n);return!0}return!1},o.prototype.addListener=function(e,t){if("function"!=typeof t)throw new Error("addListener only takes instances of Function");if(this._events||(this._events={}),this.emit("newListener",e,t),this._events[e])if(a(this._events[e])){if(!this._events[e].warned){var n;n=void 0!==this._events.maxListeners?this._events.maxListeners:u,n&&n>0&&this._events[e].length>n&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),console.trace())}this._events[e].push(t)}else this._events[e]=[this._events[e],t];else this._events[e]=t;return this},o.prototype.on=o.prototype.addListener,o.prototype.once=function(e,t){var n=this;return n.on(e,function r(){n.removeListener(e,r),t.apply(this,arguments)}),this},o.prototype.removeListener=function(e,t){if("function"!=typeof t)throw new Error("removeListener only takes instances of Function");if(!this._events||!this._events[e])return this;var n=this._events[e];if(a(n)){var i=r(n,t);if(0>i)return this;n.splice(i,1),0==n.length&&delete this._events[e]}else this._events[e]===t&&delete this._events[e];return this},o.prototype.removeAllListeners=function(e){return 0===arguments.length?(this._events={},this):(e&&this._events&&this._events[e]&&(this._events[e]=null),this)},o.prototype.listeners=function(e){return this._events||(this._events={}),this._events[e]||(this._events[e]=[]),a(this._events[e])||(this._events[e]=[this._events[e]]),this._events[e]},o.listenerCount=function(e,t){var n;return n=e._events&&e._events[t]?"function"==typeof e._events[t]?1:e._events[t].length:0}},{__browserify_process:4}],2:[function(e,t,n){function r(e,t){for(var n=[],r=0;r<e.length;r++)t(e[r],r,e)&&n.push(e[r]);return n}function i(e,t){for(var n=0,r=e.length;r>=0;r--){var i=e[r];"."==i?e.splice(r,1):".."===i?(e.splice(r,1),n++):n&&(e.splice(r,1),n--)}if(t)for(;n--;n)e.unshift("..");return e}var o=e("__browserify_process"),a=/^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;n.resolve=function(){for(var e="",t=!1,n=arguments.length;n>=-1&&!t;n--){var a=n>=0?arguments[n]:o.cwd();"string"==typeof a&&a&&(e=a+"/"+e,t="/"===a.charAt(0))}return e=i(r(e.split("/"),function(e){return!!e}),!t).join("/"),(t?"/":"")+e||"."},n.normalize=function(e){var t="/"===e.charAt(0),n="/"===e.slice(-1);return e=i(r(e.split("/"),function(e){return!!e}),!t).join("/"),e||t||(e="."),e&&n&&(e+="/"),(t?"/":"")+e},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(r(e,function(e){return e&&"string"==typeof e}).join("/"))},n.dirname=function(e){var t=a.exec(e)[1]||"",n=!1;return t?1===t.length||n&&t.length<=3&&":"===t.charAt(1)?t:t.substring(0,t.length-1):"."},n.basename=function(e,t){var n=a.exec(e)[2]||"";return t&&n.substr(-1*t.length)===t&&(n=n.substr(0,n.length-t.length)),n},n.extname=function(e){return a.exec(e)[3]||""},n.relative=function(e,t){function r(e){for(var t=0;t<e.length&&""===e[t];t++);for(var n=e.length-1;n>=0&&""===e[n];n--);return t>n?[]:e.slice(t,n-t+1)}e=n.resolve(e).substr(1),t=n.resolve(t).substr(1);for(var i=r(e.split("/")),o=r(t.split("/")),a=Math.min(i.length,o.length),u=a,s=0;a>s;s++)if(i[s]!==o[s]){u=s;break}for(var c=[],s=u;s<i.length;s++)c.push("..");return c=c.concat(o.slice(u)),c.join("/")},n.sep="/"},{__browserify_process:4}],3:[function(e,t,n){function r(e){return Array.isArray(e)||"object"==typeof e&&"[object Array]"===Object.prototype.toString.call(e)}function i(e){"object"==typeof e&&"[object RegExp]"===Object.prototype.toString.call(e)}function o(e){return"object"==typeof e&&"[object Date]"===Object.prototype.toString.call(e)}e("events"),n.isArray=r,n.isDate=function(e){return"[object Date]"===Object.prototype.toString.call(e)},n.isRegExp=function(e){return"[object RegExp]"===Object.prototype.toString.call(e)},n.print=function(){},n.puts=function(){},n.debug=function(){},n.inspect=function(e,t,s,c){function f(e,s){if(e&&"function"==typeof e.inspect&&e!==n&&(!e.constructor||e.constructor.prototype!==e))return e.inspect(s);switch(typeof e){case"undefined":return h("undefined","undefined");case"string":var c="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return h(c,"string");case"number":return h(""+e,"number");case"boolean":return h(""+e,"boolean")}if(null===e)return h("null","null");var p=a(e),d=t?u(e):p;if("function"==typeof e&&0===d.length){if(i(e))return h(""+e,"regexp");var y=e.name?": "+e.name:"";return h("[Function"+y+"]","special")}if(o(e)&&0===d.length)return h(e.toUTCString(),"date");var v,g,m;if(r(e)?(g="Array",m=["[","]"]):(g="Object",m=["{","}"]),"function"==typeof e){var b=e.name?": "+e.name:"";v=i(e)?" "+e:" [Function"+b+"]"}else v="";if(o(e)&&(v=" "+e.toUTCString()),0===d.length)return m[0]+v+m[1];if(0>s)return i(e)?h(""+e,"regexp"):h("[Object]","special");l.push(e);var w=d.map(function(t){var n,i;if(e.__lookupGetter__&&(e.__lookupGetter__(t)?i=e.__lookupSetter__(t)?h("[Getter/Setter]","special"):h("[Getter]","special"):e.__lookupSetter__(t)&&(i=h("[Setter]","special"))),p.indexOf(t)<0&&(n="["+t+"]"),i||(l.indexOf(e[t])<0?(i=null===s?f(e[t]):f(e[t],s-1),i.indexOf("\n")>-1&&(i=r(e)?i.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+i.split("\n").map(function(e){return"   "+e}).join("\n"))):i=h("[Circular]","special")),"undefined"==typeof n){if("Array"===g&&t.match(/^\d+$/))return i;n=JSON.stringify(""+t),n.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(n=n.substr(1,n.length-2),n=h(n,"name")):(n=n.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),n=h(n,"string"))}return n+": "+i});l.pop();var _=0,k=w.reduce(function(e,t){return _++,t.indexOf("\n")>=0&&_++,e+t.length+1},0);return w=k>50?m[0]+(""===v?"":v+"\n ")+" "+w.join(",\n  ")+" "+m[1]:m[0]+v+" "+w.join(", ")+" "+m[1]}var l=[],h=function(e,t){var n={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},r={special:"cyan",number:"blue","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"}[t];return r?"["+n[r][0]+"m"+e+"["+n[r][1]+"m":e};return c||(h=function(e){return e}),f(e,"undefined"==typeof s?2:s)},n.log=function(){},n.pump=null;var a=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t},u=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.hasOwnProperty.call(e,n)&&t.push(n);return t},s=Object.create||function(e,t){var n;if(null===e)n={__proto__:null};else{if("object"!=typeof e)throw new TypeError("typeof prototype["+typeof e+"] != 'object'");var r=function(){};r.prototype=e,n=new r,n.__proto__=e}return"undefined"!=typeof t&&Object.defineProperties&&Object.defineProperties(n,t),n};n.inherits=function(e,t){e.super_=t,e.prototype=s(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})};var c=/%[sdj%]/g;n.format=function(e){if("string"!=typeof e){for(var t=[],r=0;r<arguments.length;r++)t.push(n.inspect(arguments[r]));return t.join(" ")}for(var r=1,i=arguments,o=i.length,a=String(e).replace(c,function(e){if("%%"===e)return"%";if(r>=o)return e;switch(e){case"%s":return String(i[r++]);case"%d":return Number(i[r++]);case"%j":return JSON.stringify(i[r++]);default:return e}}),u=i[r];o>r;u=i[++r])a+=null===u||"object"!=typeof u?" "+u:" "+n.inspect(u);return a}},{events:1}],4:[function(e,t){var n=t.exports={};n.nextTick=function(){var e="undefined"!=typeof window&&window.setImmediate,t="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(e)return function(e){return window.setImmediate(e)};if(t){var n=[];return window.addEventListener("message",function(e){var t=e.source;if((t===window||null===t)&&"process-tick"===e.data&&(e.stopPropagation(),n.length>0)){var r=n.shift();r()}},!0),function(e){n.push(e),window.postMessage("process-tick","*")}}return function(e){setTimeout(e,0)}}(),n.title="browser",n.browser=!0,n.env={},n.argv=[],n.binding=function(){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(){throw new Error("process.chdir is not supported")}},{}],5:[function(e,t){function n(e,t,n){this.db=e,this.query=t||{},n&&(this.execFn=n)}var r=e("./model"),i=e("underscore");n.prototype.limit=function(e){return this._limit=e,this},n.prototype.skip=function(e){return this._skip=e,this},n.prototype.sort=function(e){return this._sort=e,this},n.prototype.projection=function(e){return this._projection=e,this},n.prototype.project=function(e){var t,n,o,a=[],u=this;return void 0===this._projection||0===Object.keys(this._projection).length?e:(t=0===this._projection._id?!1:!0,this._projection=i.omit(this._projection,"_id"),o=Object.keys(this._projection),o.forEach(function(e){if(void 0!==n&&u._projection[e]!==n)throw new Error("Can't both keep and omit fields except for _id");n=u._projection[e]}),e.forEach(function(e){var i;1===n?(i={$set:{}},o.forEach(function(t){i.$set[t]=r.getDotValue(e,t),void 0===i.$set[t]&&delete i.$set[t]}),i=r.modify({},i)):(i={$unset:{}},o.forEach(function(e){i.$unset[e]=!0}),i=r.modify(e,i)),t?i._id=e._id:delete i._id,a.push(i)}),a)},n.prototype._exec=function(e){function t(t,n){return c.execFn?c.execFn(t,n,e):e(t,n)}var n,i,o,a=[],u=0,s=0,c=this,f=null;this.db.getCandidates(this.query,function(e,l){if(e)return t(e);try{for(n=0;n<l.length;n+=1)if(r.match(l[n],c.query))if(c._sort)a.push(l[n]);else if(c._skip&&c._skip>s)s+=1;else if(a.push(l[n]),u+=1,c._limit&&c._limit<=u)break}catch(e){return t(e)}if(c._sort){i=Object.keys(c._sort);var h=[];for(n=0;n<i.length;n++)o=i[n],h.push({key:o,direction:c._sort[o]});a.sort(function(e,t){var n,i,o;for(o=0;o<h.length;o++)if(n=h[o],i=n.direction*r.compareThings(r.getDotValue(e,n.key),r.getDotValue(t,n.key),c.db.compareStrings),0!==i)return i;return 0});var p=c._limit||a.length,d=c._skip||0;a=a.slice(d,d+p)}try{a=c.project(a)}catch(y){f=y,a=void 0}return t(f,a)})},n.prototype.exec=function(){this.db.executor.push({"this":this,fn:this._exec,arguments:arguments})},t.exports=n},{"./model":10,underscore:19}],6:[function(e,t){function n(e){for(var t,t,n=new Array(e),r=0;e>r;r++)0==(3&r)&&(t=4294967296*Math.random()),n[r]=255&t>>>((3&r)<<3);return n}function r(e){function t(e){return o[63&e>>18]+o[63&e>>12]+o[63&e>>6]+o[63&e]}var n,r,i,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=e.length%3,u="";for(i=0,r=e.length-a;r>i;i+=3)n=(e[i]<<16)+(e[i+1]<<8)+e[i+2],u+=t(n);switch(a){case 1:n=e[e.length-1],u+=o[n>>2],u+=o[63&n<<4],u+="==";break;case 2:n=(e[e.length-2]<<8)+e[e.length-1],u+=o[n>>10],u+=o[63&n>>4],u+=o[63&n<<2],u+="="}return u}function i(e){return r(n(Math.ceil(Math.max(8,2*e)))).replace(/[+\/]/g,"").slice(0,e)}t.exports.uid=i},{}],7:[function(e,t){function n(e){var t;"string"==typeof e?(t=e,this.inMemoryOnly=!1):(e=e||{},t=e.filename,this.inMemoryOnly=e.inMemoryOnly||!1,this.autoload=e.autoload||!1,this.timestampData=e.timestampData||!1),t&&"string"==typeof t&&0!==t.length?this.filename=t:(this.filename=null,this.inMemoryOnly=!0),this.compareStrings=e.compareStrings,this.persistence=new f({db:this,nodeWebkitAppName:e.nodeWebkitAppName,afterSerialization:e.afterSerialization,beforeDeserialization:e.beforeDeserialization,corruptAlertThreshold:e.corruptAlertThreshold}),this.executor=new a,this.inMemoryOnly&&(this.executor.ready=!0),this.indexes={},this.indexes._id=new u({fieldName:"_id",unique:!0}),this.ttlIndexes={},this.autoload&&this.loadDatabase(e.onload||function(e){if(e)throw e})}var r=e("./customUtils"),i=e("./model"),o=e("async"),a=e("./executor"),u=e("./indexes"),s=e("util"),c=e("underscore"),f=e("./persistence"),l=e("./cursor");s.inherits(n,e("events").EventEmitter),n.prototype.loadDatabase=function(){this.executor.push({"this":this.persistence,fn:this.persistence.loadDatabase,arguments:arguments},!0)},n.prototype.getAllData=function(){return this.indexes._id.getAll()},n.prototype.resetIndexes=function(e){var t=this;Object.keys(this.indexes).forEach(function(n){t.indexes[n].reset(e)})},n.prototype.ensureIndex=function(e,t){var n,r=t||function(){};if(e=e||{},!e.fieldName)return n=new Error("Cannot create an index without a fieldName"),n.missingFieldName=!0,r(n);if(this.indexes[e.fieldName])return r(null);this.indexes[e.fieldName]=new u(e),void 0!==e.expireAfterSeconds&&(this.ttlIndexes[e.fieldName]=e.expireAfterSeconds);try{this.indexes[e.fieldName].insert(this.getAllData())}catch(i){return delete this.indexes[e.fieldName],r(i)}this.persistence.persistNewState([{$$indexCreated:e}],function(e){return e?r(e):r(null)})},n.prototype.removeIndex=function(e,t){var n=t||function(){};delete this.indexes[e],this.persistence.persistNewState([{$$indexRemoved:e}],function(e){return e?n(e):n(null)})},n.prototype.addToIndexes=function(e){var t,n,r,i=Object.keys(this.indexes);for(t=0;t<i.length;t+=1)try{this.indexes[i[t]].insert(e)}catch(o){n=t,r=o;break}if(r){for(t=0;n>t;t+=1)this.indexes[i[t]].remove(e);throw r}},n.prototype.removeFromIndexes=function(e){var t=this;Object.keys(this.indexes).forEach(function(n){t.indexes[n].remove(e)})},n.prototype.updateIndexes=function(e,t){var n,r,i,o=Object.keys(this.indexes);for(n=0;n<o.length;n+=1)try{this.indexes[o[n]].update(e,t)}catch(a){r=n,i=a;break}if(i){for(n=0;r>n;n+=1)this.indexes[o[n]].revertUpdate(e,t);throw i}},n.prototype.getCandidates=function(e,t,n){var r,i=Object.keys(this.indexes),a=this;"function"==typeof t&&(n=t,t=!1),o.waterfall([function(t){return r=[],Object.keys(e).forEach(function(t){("string"==typeof e[t]||"number"==typeof e[t]||"boolean"==typeof e[t]||s.isDate(e[t])||null===e[t])&&r.push(t)}),r=c.intersection(r,i),r.length>0?t(null,a.indexes[r[0]].getMatching(e[r[0]])):(r=[],Object.keys(e).forEach(function(t){e[t]&&e[t].hasOwnProperty("$in")&&r.push(t)}),r=c.intersection(r,i),r.length>0?t(null,a.indexes[r[0]].getMatching(e[r[0]].$in)):(r=[],Object.keys(e).forEach(function(t){e[t]&&(e[t].hasOwnProperty("$lt")||e[t].hasOwnProperty("$lte")||e[t].hasOwnProperty("$gt")||e[t].hasOwnProperty("$gte"))&&r.push(t)}),r=c.intersection(r,i),r.length>0?t(null,a.indexes[r[0]].getBetweenBounds(e[r[0]])):t(null,a.getAllData())))},function(e){if(t)return n(null,e);var r=[],i=[],u=Object.keys(a.ttlIndexes);e.forEach(function(e){var t=!0;u.forEach(function(n){void 0!==e[n]&&s.isDate(e[n])&&Date.now()>e[n].getTime()+1e3*a.ttlIndexes[n]&&(t=!1)}),t?i.push(e):r.push(e._id)}),o.eachSeries(r,function(e,t){a._remove({_id:e},{},function(e){return e?n(e):t()})},function(){return n(null,i)})}])},n.prototype._insert=function(e,t){var n,r=t||function(){};try{n=this.prepareDocumentForInsertion(e),this._insertInCache(n)}catch(o){return r(o)}this.persistence.persistNewState(s.isArray(n)?n:[n],function(e){return e?r(e):r(null,i.deepCopy(n))})},n.prototype.createNewId=function(){var e=r.uid(16);return this.indexes._id.getMatching(e).length>0&&(e=this.createNewId()),e},n.prototype.prepareDocumentForInsertion=function(e){var t,n=this;if(s.isArray(e))t=[],e.forEach(function(e){t.push(n.prepareDocumentForInsertion(e))});else{t=i.deepCopy(e),void 0===t._id&&(t._id=this.createNewId());var r=new Date;this.timestampData&&void 0===t.createdAt&&(t.createdAt=r),this.timestampData&&void 0===t.updatedAt&&(t.updatedAt=r),i.checkObject(t)}return t},n.prototype._insertInCache=function(e){s.isArray(e)?this._insertMultipleDocsInCache(e):this.addToIndexes(e)},n.prototype._insertMultipleDocsInCache=function(e){var t,n,r;for(t=0;t<e.length;t+=1)try{this.addToIndexes(e[t])}catch(i){r=i,n=t;break}if(r){for(t=0;n>t;t+=1)this.removeFromIndexes(e[t]);throw r}},n.prototype.insert=function(){this.executor.push({"this":this,fn:this._insert,arguments:arguments})},n.prototype.count=function(e,t){var n=new l(this,e,function(e,t,n){return e?n(e):n(null,t.length)});return"function"!=typeof t?n:(n.exec(t),void 0)},n.prototype.find=function(e,t,n){switch(arguments.length){case 1:t={};break;case 2:"function"==typeof t&&(n=t,t={})}var r=new l(this,e,function(e,t,n){var r,o=[];if(e)return n(e);for(r=0;r<t.length;r+=1)o.push(i.deepCopy(t[r]));return n(null,o)});return r.projection(t),"function"!=typeof n?r:(r.exec(n),void 0)},n.prototype.findOne=function(e,t,n){switch(arguments.length){case 1:t={};break;case 2:"function"==typeof t&&(n=t,t={})}var r=new l(this,e,function(e,t,n){return e?n(e):1===t.length?n(null,i.deepCopy(t[0])):n(null,null)});return r.projection(t).limit(1),"function"!=typeof n?r:(r.exec(n),void 0)},n.prototype._update=function(e,t,n,r){var a,u,s,f,h=this,p=0;"function"==typeof n&&(r=n,n={}),a=r||function(){},u=void 0!==n.multi?n.multi:!1,s=void 0!==n.upsert?n.upsert:!1,o.waterfall([function(n){if(!s)return n();var r=new l(h,e);r.limit(1)._exec(function(r,o){if(r)return a(r);if(1===o.length)return n();var u;try{i.checkObject(t),u=t}catch(s){try{u=i.modify(i.deepCopy(e,!0),t)}catch(r){return a(r)}}return h._insert(u,function(e,t){return e?a(e):a(null,1,t,!0)})})},function(){var r,o,s=[];h.getCandidates(e,function(l,d){if(l)return a(l);try{for(f=0;f<d.length;f+=1)i.match(d[f],e)&&(u||0===p)&&(p+=1,h.timestampData&&(o=d[f].createdAt),r=i.modify(d[f],t),h.timestampData&&(r.createdAt=o,r.updatedAt=new Date),s.push({oldDoc:d[f],newDoc:r}))}catch(l){return a(l)}try{h.updateIndexes(s)}catch(l){return a(l)}var y=c.pluck(s,"newDoc");h.persistence.persistNewState(y,function(e){if(e)return a(e);if(n.returnUpdatedDocs){var t=[];return y.forEach(function(e){t.push(i.deepCopy(e))}),u||(t=t[0]),a(null,p,t)}return a(null,p)})})}])},n.prototype.update=function(){this.executor.push({"this":this,fn:this._update,arguments:arguments})},n.prototype._remove=function(e,t,n){var r,o,a=this,u=0,s=[];"function"==typeof t&&(n=t,t={}),r=n||function(){},o=void 0!==t.multi?t.multi:!1,this.getCandidates(e,!0,function(t,n){if(t)return r(t);try{n.forEach(function(t){i.match(t,e)&&(o||0===u)&&(u+=1,s.push({$$deleted:!0,_id:t._id}),a.removeFromIndexes(t))})}catch(t){return r(t)}a.persistence.persistNewState(s,function(e){return e?r(e):r(null,u)})})},n.prototype.remove=function(){this.executor.push({"this":this,fn:this._remove,arguments:arguments})},t.exports=n},{"./cursor":5,"./customUtils":6,"./executor":8,"./indexes":9,"./model":10,"./persistence":11,async:13,events:1,underscore:19,util:3}],8:[function(e,t){function n(){this.buffer=[],this.ready=!1,this.queue=i.queue(function(e,t){for(var n=[],i=0;i<e.arguments.length;i+=1)n.push(e.arguments[i]);var o=e.arguments[e.arguments.length-1];"function"==typeof o?n[n.length-1]=function(){"function"==typeof setImmediate?setImmediate(t):r.nextTick(t),o.apply(null,arguments)}:o||0===e.arguments.length?n.push(function(){t()}):n[n.length-1]=function(){t()},e.fn.apply(e.this,n)},1)}var r=e("__browserify_process"),i=e("async");n.prototype.push=function(e,t){this.ready||t?this.queue.push(e):this.buffer.push(e)},n.prototype.processBuffer=function(){var e;for(this.ready=!0,e=0;e<this.buffer.length;e+=1)this.queue.push(this.buffer[e]);this.buffer=[]},t.exports=n},{__browserify_process:4,async:13}],9:[function(e,t){function n(e,t){return e===t}function r(e){return null===e?"$null":"string"==typeof e?"$string"+e:"boolean"==typeof e?"$boolean"+e:"number"==typeof e?"$number"+e:s.isArray(e)?"$date"+e.getTime():e}function i(e){this.fieldName=e.fieldName,this.unique=e.unique||!1,this.sparse=e.sparse||!1,this.treeOptions={unique:this.unique,compareKeys:a.compareThings,checkValueEquality:n},this.reset()}var o=e("binary-search-tree").AVLTree,a=e("./model"),u=e("underscore"),s=e("util");i.prototype.reset=function(e){this.tree=new o(this.treeOptions),e&&this.insert(e)},i.prototype.insert=function(e){var t,n,i,o,c;if(s.isArray(e))return this.insertMultipleDocs(e),void 0;if(t=a.getDotValue(e,this.fieldName),void 0!==t||!this.sparse)if(s.isArray(t)){for(n=u.uniq(t,r),i=0;i<n.length;i+=1)try{this.tree.insert(n[i],e)}catch(f){c=f,o=i;break}if(c){for(i=0;o>i;i+=1)this.tree.delete(n[i],e);throw c}}else this.tree.insert(t,e)},i.prototype.insertMultipleDocs=function(e){var t,n,r;for(t=0;t<e.length;t+=1)try{this.insert(e[t])}catch(i){n=i,r=t;break}if(n){for(t=0;r>t;t+=1)this.remove(e[t]);throw n}},i.prototype.remove=function(e){var t,n=this;return s.isArray(e)?(e.forEach(function(e){n.remove(e)}),void 0):(t=a.getDotValue(e,this.fieldName),void 0===t&&this.sparse||(s.isArray(t)?u.uniq(t,r).forEach(function(t){n.tree.delete(t,e)}):this.tree.delete(t,e)),void 0)},i.prototype.update=function(e,t){if(s.isArray(e))return this.updateMultipleDocs(e),void 0;this.remove(e);try{this.insert(t)}catch(n){throw this.insert(e),n}},i.prototype.updateMultipleDocs=function(e){var t,n,r;for(t=0;t<e.length;t+=1)this.remove(e[t].oldDoc);for(t=0;t<e.length;t+=1)try{this.insert(e[t].newDoc)}catch(i){r=i,n=t;break}if(r){for(t=0;n>t;t+=1)this.remove(e[t].newDoc);for(t=0;t<e.length;t+=1)this.insert(e[t].oldDoc);throw r}},i.prototype.revertUpdate=function(e,t){var n=[];s.isArray(e)?(e.forEach(function(e){n.push({oldDoc:e.newDoc,newDoc:e.oldDoc})}),this.update(n)):this.update(t,e)},i.prototype.getMatching=function(e){var t=this;if(s.isArray(e)){var n={},r=[];return e.forEach(function(e){t.getMatching(e).forEach(function(e){n[e._id]=e})}),Object.keys(n).forEach(function(e){r.push(n[e])}),r}return t.tree.search(e)},i.prototype.getBetweenBounds=function(e){return this.tree.betweenBounds(e)},i.prototype.getAll=function(){var e=[];return this.tree.executeOnEveryNode(function(t){var n;for(n=0;n<t.data.length;n+=1)e.push(t.data[n])}),e},t.exports=i},{"./model":10,"binary-search-tree":14,underscore:19,util:3}],10:[function(e,t){function n(e,t){if("number"==typeof e&&(e=e.toString()),!("$"!==e[0]||"$$date"===e&&"number"==typeof t||"$$deleted"===e&&t===!0||"$$indexCreated"===e||"$$indexRemoved"===e))throw new Error("Field names cannot begin with the $ character");if(-1!==e.indexOf("."))throw new Error("Field names cannot contain a .")}function r(e){m.isArray(e)&&e.forEach(function(e){r(e)}),"object"==typeof e&&null!==e&&Object.keys(e).forEach(function(t){n(t,e[t]),r(e[t])})}function i(e){var t;return t=JSON.stringify(e,function(e,t){return n(e,t),void 0===t?void 0:null===t?null:"function"==typeof this[e].getTime?{$$date:this[e].getTime()}:t})}function o(e){return JSON.parse(e,function(e,t){return"$$date"===e?new Date(t):"string"==typeof t||"number"==typeof t||"boolean"==typeof t||null===t?t:t&&t.$$date?t.$$date:t})}function a(e,t){var n;if("boolean"==typeof e||"number"==typeof e||"string"==typeof e||null===e||m.isDate(e))return e;if(m.isArray(e))return n=[],e.forEach(function(e){n.push(a(e,t))}),n;if("object"==typeof e){var r=Object.prototype.toString;switch(r.call(e)){case"[object Blob]":case"[object ArrayBuffer]":case"[object Int8Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":case"[object Int16Array]":case"[object Uint16Array]":case"[object Int32Array]":case"[object Uint32Array]":case"[object Float32Array]":case"[object Float64Array]":return e}return n={},Object.keys(e).forEach(function(r){(!t||"$"!==r[0]&&-1===r.indexOf("."))&&(n[r]=a(e[r],t))}),n}return void 0}function u(e){return"boolean"==typeof e||"number"==typeof e||"string"==typeof e||null===e||m.isDate(e)||m.isArray(e)}function s(e,t){return t>e?-1:e>t?1:0}function c(e,t){var n,r;for(n=0;n<Math.min(e.length,t.length);n+=1)if(r=f(e[n],t[n]),0!==r)return r;return s(e.length,t.length)}function f(e,t,n){var r,i,o,a,u=n||s;if(void 0===e)return void 0===t?0:-1;if(void 0===t)return void 0===e?0:1;if(null===e)return null===t?0:-1;if(null===t)return null===e?0:1;if("number"==typeof e)return"number"==typeof t?s(e,t):-1;if("number"==typeof t)return"number"==typeof e?s(e,t):1;if("string"==typeof e)return"string"==typeof t?u(e,t):-1;if("string"==typeof t)return"string"==typeof e?u(e,t):1;if("boolean"==typeof e)return"boolean"==typeof t?s(e,t):-1;if("boolean"==typeof t)return"boolean"==typeof e?s(e,t):1;if(m.isDate(e))return m.isDate(t)?s(e.getTime(),t.getTime()):-1;if(m.isDate(t))return m.isDate(e)?s(e.getTime(),t.getTime()):1;if(m.isArray(e))return m.isArray(t)?c(e,t):-1;if(m.isArray(t))return m.isArray(e)?c(e,t):1;for(r=Object.keys(e).sort(),i=Object.keys(t).sort(),a=0;a<Math.min(r.length,i.length);a+=1)if(o=f(e[r[a]],t[i[a]]),0!==o)return o;return s(r.length,i.length)}function l(e){return function(t,n,r){var i="string"==typeof n?n.split("."):n;if(1===i.length)_[e](t,n,r);else{if(void 0===t[i[0]]){if("$unset"===e)return;t[i[0]]={}}w[e](t[i[0]],i.slice(1),r)}}}function h(e,t){var n,i,o=Object.keys(t),u=b.map(o,function(e){return e[0]}),s=b.filter(u,function(e){return"$"===e});if(-1!==o.indexOf("_id")&&t._id!==e._id)throw new Error("You cannot change a document's _id");if(0!==s.length&&s.length!==u.length)throw new Error("You cannot mix modifiers and normal fields");if(0===s.length?(n=a(t),n._id=e._id):(i=b.uniq(o),n=a(e),i.forEach(function(e){var r;if(!w[e])throw new Error("Unknown modifier "+e);if("object"!=typeof t[e])throw new Error("Modifier "+e+"'s argument must be an object");r=Object.keys(t[e]),r.forEach(function(r){w[e](n,r,t[e][r])})})),r(n),e._id!==n._id)throw new Error("You can't change a document's _id");return n}function p(e,t){var n,r,i="string"==typeof t?t.split("."):t;if(!e)return void 0;if(0===i.length)return e;if(1===i.length)return e[i[0]];if(m.isArray(e[i[0]])){if(n=parseInt(i[1],10),"number"==typeof n&&!isNaN(n))return p(e[i[0]][n],i.slice(2));for(r=new Array,n=0;n<e[i[0]].length;n+=1)r.push(p(e[i[0]][n],i.slice(1)));return r}return p(e[i[0]],i.slice(1))}function d(e,t){var n,r,i;if(null===e||"string"==typeof e||"boolean"==typeof e||"number"==typeof e||null===t||"string"==typeof t||"boolean"==typeof t||"number"==typeof t)return e===t;if(m.isDate(e)||m.isDate(t))return m.isDate(e)&&m.isDate(t)&&e.getTime()===t.getTime();if((!m.isArray(e)||!m.isArray(t))&&(m.isArray(e)||m.isArray(t))||void 0===e||void 0===t)return!1;try{n=Object.keys(e),r=Object.keys(t)}catch(o){return!1}if(n.length!==r.length)return!1;for(i=0;i<n.length;i+=1){if(-1===r.indexOf(n[i]))return!1;if(!d(e[n[i]],t[n[i]]))return!1}return!0}function y(e,t){return"string"==typeof e||"number"==typeof e||m.isDate(e)||"string"==typeof t||"number"==typeof t||m.isDate(t)?typeof e!=typeof t?!1:!0:!1}function v(e,t){var n,r,i,o;if(u(e)||u(t))return g({needAKey:e},"needAKey",t);for(n=Object.keys(t),o=0;o<n.length;o+=1)if(r=n[o],i=t[r],"$"===r[0]){if(!x[r])throw new Error("Unknown logical operator "+r);if(!x[r](e,i))return!1}else if(!g(e,r,i))return!1;return!0}function g(e,t,n,r){var i,o,a,u,s=p(e,t);if(m.isArray(s)&&!r){if(m.isArray(n))return g(e,t,n,!0);if(null!==n&&"object"==typeof n&&!m.isRegExp(n))for(o=Object.keys(n),i=0;i<o.length;i+=1)if(E[o[i]])return g(e,t,n,!0);for(i=0;i<s.length;i+=1)if(g({k:s[i]},"k",n))return!0;return!1}if(null!==n&&"object"==typeof n&&!m.isRegExp(n)&&!m.isArray(n)){if(o=Object.keys(n),a=b.map(o,function(e){return e[0]}),u=b.filter(a,function(e){return"$"===e}),0!==u.length&&u.length!==a.length)throw new Error("You cannot mix operators and normal fields");if(u.length>0){for(i=0;i<o.length;i+=1){if(!k[o[i]])throw new Error("Unknown comparison function "+o[i]);if(!k[o[i]](s,n[o[i]]))return!1}return!0}}return m.isRegExp(n)?k.$regex(s,n):d(s,n)?!0:!1}var m=e("util"),b=e("underscore"),w={},_={},k={},x={},E={};_.$set=function(e,t,n){e[t]=n},_.$unset=function(e,t){delete e[t]},_.$push=function(e,t,n){if(e.hasOwnProperty(t)||(e[t]=[]),!m.isArray(e[t]))throw new Error("Can't $push an element on non-array values");if(null!==n&&"object"==typeof n&&n.$slice&&void 0===n.$each&&(n.$each=[]),null!==n&&"object"==typeof n&&n.$each){if(Object.keys(n).length>=3||2===Object.keys(n).length&&void 0===n.$slice)throw new Error("Can only use $slice in cunjunction with $each when $push to array");if(!m.isArray(n.$each))throw new Error("$each requires an array value");if(n.$each.forEach(function(n){e[t].push(n)}),void 0===n.$slice||"number"!=typeof n.$slice)return;if(0===n.$slice)e[t]=[];else{var r,i,o=e[t].length;n.$slice<0?(r=Math.max(0,o+n.$slice),i=o):n.$slice>0&&(r=0,i=Math.min(o,n.$slice)),e[t]=e[t].slice(r,i)}}else e[t].push(n)},_.$addToSet=function(e,t,n){var r=!0;if(e.hasOwnProperty(t)||(e[t]=[]),!m.isArray(e[t]))throw new Error("Can't $addToSet an element on non-array values");if(null!==n&&"object"==typeof n&&n.$each){if(Object.keys(n).length>1)throw new Error("Can't use another field in conjunction with $each");if(!m.isArray(n.$each))throw new Error("$each requires an array value");n.$each.forEach(function(n){_.$addToSet(e,t,n)})}else e[t].forEach(function(e){0===f(e,n)&&(r=!1)}),r&&e[t].push(n)},_.$pop=function(e,t,n){if(!m.isArray(e[t]))throw new Error("Can't $pop an element from non-array values");if("number"!=typeof n)throw new Error(n+" isn't an integer, can't use it with $pop");0!==n&&(e[t]=n>0?e[t].slice(0,e[t].length-1):e[t].slice(1))},_.$pull=function(e,t,n){var r,i;if(!m.isArray(e[t]))throw new Error("Can't $pull an element from non-array values");for(r=e[t],i=r.length-1;i>=0;i-=1)v(r[i],n)&&r.splice(i,1)},_.$inc=function(e,t,n){if("number"!=typeof n)throw new Error(n+" must be a number");if("number"!=typeof e[t]){if(b.has(e,t))throw new Error("Don't use the $inc modifier on non-number fields");e[t]=n}else e[t]+=n},_.$max=function(e,t,n){"undefined"==typeof e[t]?e[t]=n:n>e[t]&&(e[t]=n)},_.$min=function(e,t,n){"undefined"==typeof e[t]?e[t]=n:n<e[t]&&(e[t]=n)},Object.keys(_).forEach(function(e){w[e]=l(e)}),k.$lt=function(e,t){return y(e,t)&&t>e},k.$lte=function(e,t){return y(e,t)&&t>=e},k.$gt=function(e,t){return y(e,t)&&e>t},k.$gte=function(e,t){return y(e,t)&&e>=t},k.$ne=function(e,t){return void 0===e?!0:!d(e,t)},k.$in=function(e,t){var n;if(!m.isArray(t))throw new Error("$in operator called with a non-array");for(n=0;n<t.length;n+=1)if(d(e,t[n]))return!0;return!1},k.$nin=function(e,t){if(!m.isArray(t))throw new Error("$nin operator called with a non-array");return!k.$in(e,t)},k.$regex=function(e,t){if(!m.isRegExp(t))throw new Error("$regex operator called with non regular expression");return"string"!=typeof e?!1:t.test(e)},k.$exists=function(e,t){return t=t||""===t?!0:!1,void 0===e?!t:t},k.$size=function(e,t){if(!m.isArray(e))return!1;if(0!==t%1)throw new Error("$size operator called without an integer");
-return e.length==t},k.$elemMatch=function(e,t){if(!m.isArray(e))return!1;for(var n=e.length,r=!1;n--;)if(v(e[n],t)){r=!0;break}return r},E.$size=!0,E.$elemMatch=!0,x.$or=function(e,t){var n;if(!m.isArray(t))throw new Error("$or operator used without an array");for(n=0;n<t.length;n+=1)if(v(e,t[n]))return!0;return!1},x.$and=function(e,t){var n;if(!m.isArray(t))throw new Error("$and operator used without an array");for(n=0;n<t.length;n+=1)if(!v(e,t[n]))return!1;return!0},x.$not=function(e,t){return!v(e,t)},x.$where=function(e,t){var n;if(!b.isFunction(t))throw new Error("$where operator used without a function");if(n=t.call(e),!b.isBoolean(n))throw new Error("$where function must return boolean");return n},t.exports.serialize=i,t.exports.deserialize=o,t.exports.deepCopy=a,t.exports.checkObject=r,t.exports.isPrimitiveType=u,t.exports.modify=h,t.exports.getDotValue=p,t.exports.match=v,t.exports.areThingsEqual=d,t.exports.compareThings=f},{underscore:19,util:3}],11:[function(e,t){function n(e){var t,r,i;if(this.db=e.db,this.inMemoryOnly=this.db.inMemoryOnly,this.filename=this.db.filename,this.corruptAlertThreshold=void 0!==e.corruptAlertThreshold?e.corruptAlertThreshold:.1,!this.inMemoryOnly&&this.filename&&"~"===this.filename.charAt(this.filename.length-1))throw new Error("The datafile name can't end with a ~, which is reserved for crash safe backup files");if(e.afterSerialization&&!e.beforeDeserialization)throw new Error("Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss");if(!e.afterSerialization&&e.beforeDeserialization)throw new Error("Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss");for(this.afterSerialization=e.afterSerialization||function(e){return e},this.beforeDeserialization=e.beforeDeserialization||function(e){return e},t=1;30>t;t+=1)for(r=0;10>r;r+=1)if(i=s.uid(t),this.beforeDeserialization(this.afterSerialization(i))!==i)throw new Error("beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss");this.filename&&e.nodeWebkitAppName&&(console.log("=================================================================="),console.log("WARNING: The nodeWebkitAppName option is deprecated"),console.log("To get the path to the directory where Node Webkit stores the data"),console.log("for your app, use the internal nw.gui module like this"),console.log("require('nw.gui').App.dataPath"),console.log("See https://github.com/rogerwang/node-webkit/issues/500"),console.log("=================================================================="),this.filename=n.getNWAppFilename(e.nodeWebkitAppName,this.filename))}var r=e("__browserify_process"),i=e("./storage"),o=e("path"),a=e("./model"),u=e("async"),s=e("./customUtils"),c=e("./indexes");i.forage&&i.forage.supports("asyncStorage")&&(a.serialize=function(e){return e},oldDeserialize=a.deserialize,a.deserialize=function(e){return"string"==typeof e?oldDeserialize(e):e},i&&(a.noSerialize=!0,i.setNoSerialize(!0))),n.ensureDirectoryExists=function(e,t){var n=t||function(){};i.mkdirp(e,function(e){return n(e)})},n.getNWAppFilename=function(e,t){var n;switch(r.platform){case"win32":case"win64":if(n=r.env.LOCALAPPDATA||r.env.APPDATA,!n)throw new Error("Couldn't find the base application data folder");n=o.join(n,e);break;case"darwin":if(n=r.env.HOME,!n)throw new Error("Couldn't find the base application data directory");n=o.join(n,"Library","Application Support",e);break;case"linux":if(n=r.env.HOME,!n)throw new Error("Couldn't find the base application data directory");n=o.join(n,".config",e);break;default:throw new Error("Can't use the Node Webkit relative path for platform "+r.platform)}return o.join(n,"nedb-data",t)},n.prototype.addToPersist=function(e,t){return a.noSerialize?e.push(t):e+=t+"\n",e},n.prototype.persistCachedDatabase=function(e){var t=e||function(){},n="",r=this;return this.inMemoryOnly?t(null):(a.noSerialize&&(n=[]),this.db.getAllData().forEach(function(e){n=r.addToPersist(n,r.afterSerialization(a.serialize(e)))}),Object.keys(this.db.indexes).forEach(function(e){"_id"!=e&&(n=r.addToPersist(n,r.afterSerialization(a.serialize({$$indexCreated:{fieldName:e,unique:r.db.indexes[e].unique,sparse:r.db.indexes[e].sparse}}))))}),i.crashSafeWriteFile(this.filename,n,function(e){return e?t(e):(r.db.emit("compaction.done"),t(null))}),void 0)},n.prototype.compactDatafile=function(){this.db.executor.push({"this":this,fn:this.persistCachedDatabase,arguments:[]})},n.prototype.setAutocompactionInterval=function(e){var t=this,n=5e3,r=Math.max(e||0,n);this.stopAutocompaction(),this.autocompactionIntervalId=setInterval(function(){t.compactDatafile()},r)},n.prototype.stopAutocompaction=function(){this.autocompactionIntervalId&&clearInterval(this.autocompactionIntervalId)},n.prototype.persistNewState=function(e,t){var n=this,r="",o=t||function(){};return n.inMemoryOnly?o(null):(a.noSerialize&&(r=[]),e.forEach(function(e){r=n.addToPersist(r,n.afterSerialization(a.serialize(e)))}),0===r.length?o(null):(i.appendFile(n.filename,r,"utf8",function(e){return o(e)}),void 0))},n.prototype.split=function(e){return a.noSerialize?"string"==typeof e?e.split("\n"):e:"string"==typeof e?e.split("\n"):e},n.prototype.treatRawData=function(e){var t,n=this.split(e),r={},i=[],o={},u=-1;for(t=0;t<n.length;t+=1){var s;try{s=a.deserialize(this.beforeDeserialization(n[t])),s._id?s.$$deleted===!0?delete r[s._id]:r[s._id]=s:s.$$indexCreated&&void 0!=s.$$indexCreated.fieldName?o[s.$$indexCreated.fieldName]=s.$$indexCreated:"string"==typeof s.$$indexRemoved&&delete o[s.$$indexRemoved]}catch(c){u+=1}}if(n.length>0&&u/n.length>this.corruptAlertThreshold)throw new Error("More than "+Math.floor(100*this.corruptAlertThreshold)+"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss");return Object.keys(r).forEach(function(e){i.push(r[e])}),{data:i,indexes:o}},n.prototype.loadDatabase=function(e){var t=e||function(){},r=this;return r.db.resetIndexes(),r.inMemoryOnly?t(null):(u.waterfall([function(e){n.ensureDirectoryExists(o.dirname(r.filename),function(){i.ensureDatafileIntegrity(r.filename,function(){i.readFile(r.filename,"utf8",function(t,n){if(t)return e(t);try{var i=r.treatRawData(n)}catch(o){return e(o)}Object.keys(i.indexes).forEach(function(e){r.db.indexes[e]=new c(i.indexes[e])});try{r.db.resetIndexes(i.data)}catch(o){return r.db.resetIndexes(),e(o)}r.db.persistence.persistCachedDatabase(e)})})})}],function(e){return e?t(e):(r.db.executor.processBuffer(),t(null))}),void 0)},t.exports=n},{"./customUtils":6,"./indexes":9,"./model":10,"./storage":12,__browserify_process:4,async:13,path:2}],12:[function(e,t){function n(e,t){l.getItem(e,function(e,n){return null!==n?t(!0):t(!1)})}function r(e,t,n){l.getItem(e,function(r,i){null===i?l.removeItem(t,function(){return n()}):l.setItem(t,i,function(){l.removeItem(e,function(){return n()})})})}function i(e,t,n,r){"function"==typeof n&&(r=n),l.setItem(e,t,function(){return r()})}function o(e,t,n,r){"function"==typeof n&&(r=n),l.getItem(e,function(n,i){h?(i=i||[],i=i.concat(t)):(i=i||"",i+=t),l.setItem(e,i,function(){return r()})})}function a(e,t,n){"function"==typeof t&&(n=t),l.getItem(e,function(e,t){return n(null,t||"")})}function u(e,t){l.removeItem(e,function(){return t()})}function s(e,t){return t()}function c(e,t){return t(null)}function f(e){h=e}var l=e("localforage");l.config({name:"NeDB",storeName:"nedbdata"});var h=!1;t.exports.exists=n,t.exports.rename=r,t.exports.writeFile=i,t.exports.crashSafeWriteFile=i,t.exports.appendFile=o,t.exports.readFile=a,t.exports.unlink=u,t.exports.mkdirp=s,t.exports.ensureDatafileIntegrity=c,t.exports.forage=l,t.exports.setNoSerialize=f},{localforage:18}],13:[function(t,n){var r=t("__browserify_process");!function(){function t(e){var t=!1;return function(){if(t)throw new Error("Callback was already called.");t=!0,e.apply(i,arguments)}}var i,o,a={};i=this,null!=i&&(o=i.async),a.noConflict=function(){return i.async=o,a};var u=function(e,t){if(e.forEach)return e.forEach(t);for(var n=0;n<e.length;n+=1)t(e[n],n,e)},s=function(e,t){if(e.map)return e.map(t);var n=[];return u(e,function(e,r,i){n.push(t(e,r,i))}),n},c=function(e,t,n){return e.reduce?e.reduce(t,n):(u(e,function(e,r,i){n=t(n,e,r,i)}),n)},f=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(n);return t};"undefined"!=typeof r&&r.nextTick?(a.nextTick=r.nextTick,a.setImmediate="undefined"!=typeof setImmediate?function(e){setImmediate(e)}:a.nextTick):"function"==typeof setImmediate?(a.nextTick=function(e){setImmediate(e)},a.setImmediate=a.nextTick):(a.nextTick=function(e){setTimeout(e,0)},a.setImmediate=a.nextTick),a.each=function(e,n,r){if(r=r||function(){},!e.length)return r();var i=0;u(e,function(o){n(o,t(function(t){t?(r(t),r=function(){}):(i+=1,i>=e.length&&r(null))}))})},a.forEach=a.each,a.eachSeries=function(e,t,n){if(n=n||function(){},!e.length)return n();var r=0,i=function(){t(e[r],function(t){t?(n(t),n=function(){}):(r+=1,r>=e.length?n(null):i())})};i()},a.forEachSeries=a.eachSeries,a.eachLimit=function(e,t,n,r){var i=l(t);i.apply(null,[e,n,r])},a.forEachLimit=a.eachLimit;var l=function(e){return function(t,n,r){if(r=r||function(){},!t.length||0>=e)return r();var i=0,o=0,a=0;!function u(){if(i>=t.length)return r();for(;e>a&&o<t.length;)o+=1,a+=1,n(t[o-1],function(e){e?(r(e),r=function(){}):(i+=1,a-=1,i>=t.length?r():u())})}()}},h=function(e){return function(){var t=Array.prototype.slice.call(arguments);return e.apply(null,[a.each].concat(t))}},p=function(e,t){return function(){var n=Array.prototype.slice.call(arguments);return t.apply(null,[l(e)].concat(n))}},d=function(e){return function(){var t=Array.prototype.slice.call(arguments);return e.apply(null,[a.eachSeries].concat(t))}},y=function(e,t,n,r){var i=[];t=s(t,function(e,t){return{index:t,value:e}}),e(t,function(e,t){n(e.value,function(n,r){i[e.index]=r,t(n)})},function(e){r(e,i)})};a.map=h(y),a.mapSeries=d(y),a.mapLimit=function(e,t,n,r){return v(t)(e,n,r)};var v=function(e){return p(e,y)};a.reduce=function(e,t,n,r){a.eachSeries(e,function(e,r){n(t,e,function(e,n){t=n,r(e)})},function(e){r(e,t)})},a.inject=a.reduce,a.foldl=a.reduce,a.reduceRight=function(e,t,n,r){var i=s(e,function(e){return e}).reverse();a.reduce(i,t,n,r)},a.foldr=a.reduceRight;var g=function(e,t,n,r){var i=[];t=s(t,function(e,t){return{index:t,value:e}}),e(t,function(e,t){n(e.value,function(n){n&&i.push(e),t()})},function(){r(s(i.sort(function(e,t){return e.index-t.index}),function(e){return e.value}))})};a.filter=h(g),a.filterSeries=d(g),a.select=a.filter,a.selectSeries=a.filterSeries;var m=function(e,t,n,r){var i=[];t=s(t,function(e,t){return{index:t,value:e}}),e(t,function(e,t){n(e.value,function(n){n||i.push(e),t()})},function(){r(s(i.sort(function(e,t){return e.index-t.index}),function(e){return e.value}))})};a.reject=h(m),a.rejectSeries=d(m);var b=function(e,t,n,r){e(t,function(e,t){n(e,function(n){n?(r(e),r=function(){}):t()})},function(){r()})};a.detect=h(b),a.detectSeries=d(b),a.some=function(e,t,n){a.each(e,function(e,r){t(e,function(e){e&&(n(!0),n=function(){}),r()})},function(){n(!1)})},a.any=a.some,a.every=function(e,t,n){a.each(e,function(e,r){t(e,function(e){e||(n(!1),n=function(){}),r()})},function(){n(!0)})},a.all=a.every,a.sortBy=function(e,t,n){a.map(e,function(e,n){t(e,function(t,r){t?n(t):n(null,{value:e,criteria:r})})},function(e,t){if(e)return n(e);var r=function(e,t){var n=e.criteria,r=t.criteria;return r>n?-1:n>r?1:0};n(null,s(t.sort(r),function(e){return e.value}))})},a.auto=function(e,t){t=t||function(){};var n=f(e);if(!n.length)return t(null);var r={},i=[],o=function(e){i.unshift(e)},s=function(e){for(var t=0;t<i.length;t+=1)if(i[t]===e)return i.splice(t,1),void 0},l=function(){u(i.slice(0),function(e){e()})};o(function(){f(r).length===n.length&&(t(null,r),t=function(){})}),u(n,function(n){var i=e[n]instanceof Function?[e[n]]:e[n],h=function(e){var i=Array.prototype.slice.call(arguments,1);if(i.length<=1&&(i=i[0]),e){var o={};u(f(r),function(e){o[e]=r[e]}),o[n]=i,t(e,o),t=function(){}}else r[n]=i,a.setImmediate(l)},p=i.slice(0,Math.abs(i.length-1))||[],d=function(){return c(p,function(e,t){return e&&r.hasOwnProperty(t)},!0)&&!r.hasOwnProperty(n)};if(d())i[i.length-1](h,r);else{var y=function(){d()&&(s(y),i[i.length-1](h,r))};o(y)}})},a.waterfall=function(e,t){if(t=t||function(){},e.constructor!==Array){var n=new Error("First argument to waterfall must be an array of functions");return t(n)}if(!e.length)return t();var r=function(e){return function(n){if(n)t.apply(null,arguments),t=function(){};else{var i=Array.prototype.slice.call(arguments,1),o=e.next();o?i.push(r(o)):i.push(t),a.setImmediate(function(){e.apply(null,i)})}}};r(a.iterator(e))()};var w=function(e,t,n){if(n=n||function(){},t.constructor===Array)e.map(t,function(e,t){e&&e(function(e){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),t.call(null,e,n)})},n);else{var r={};e.each(f(t),function(e,n){t[e](function(t){var i=Array.prototype.slice.call(arguments,1);i.length<=1&&(i=i[0]),r[e]=i,n(t)})},function(e){n(e,r)})}};a.parallel=function(e,t){w({map:a.map,each:a.each},e,t)},a.parallelLimit=function(e,t,n){w({map:v(t),each:l(t)},e,n)},a.series=function(e,t){if(t=t||function(){},e.constructor===Array)a.mapSeries(e,function(e,t){e&&e(function(e){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),t.call(null,e,n)})},t);else{var n={};a.eachSeries(f(e),function(t,r){e[t](function(e){var i=Array.prototype.slice.call(arguments,1);i.length<=1&&(i=i[0]),n[t]=i,r(e)})},function(e){t(e,n)})}},a.iterator=function(e){var t=function(n){var r=function(){return e.length&&e[n].apply(null,arguments),r.next()};return r.next=function(){return n<e.length-1?t(n+1):null},r};return t(0)},a.apply=function(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t.concat(Array.prototype.slice.call(arguments)))}};var _=function(e,t,n,r){var i=[];e(t,function(e,t){n(e,function(e,n){i=i.concat(n||[]),t(e)})},function(e){r(e,i)})};a.concat=h(_),a.concatSeries=d(_),a.whilst=function(e,t,n){e()?t(function(r){return r?n(r):(a.whilst(e,t,n),void 0)}):n()},a.doWhilst=function(e,t,n){e(function(r){return r?n(r):(t()?a.doWhilst(e,t,n):n(),void 0)})},a.until=function(e,t,n){e()?n():t(function(r){return r?n(r):(a.until(e,t,n),void 0)})},a.doUntil=function(e,t,n){e(function(r){return r?n(r):(t()?n():a.doUntil(e,t,n),void 0)})},a.queue=function(e,n){function r(e,t,r,i){t.constructor!==Array&&(t=[t]),u(t,function(t){var o={data:t,callback:"function"==typeof i?i:null};r?e.tasks.unshift(o):e.tasks.push(o),e.saturated&&e.tasks.length===n&&e.saturated(),a.setImmediate(e.process)})}void 0===n&&(n=1);var i=0,o={tasks:[],concurrency:n,saturated:null,empty:null,drain:null,push:function(e,t){r(o,e,!1,t)},unshift:function(e,t){r(o,e,!0,t)},process:function(){if(i<o.concurrency&&o.tasks.length){var n=o.tasks.shift();o.empty&&0===o.tasks.length&&o.empty(),i+=1;var r=function(){i-=1,n.callback&&n.callback.apply(n,arguments),o.drain&&0===o.tasks.length+i&&o.drain(),o.process()},a=t(r);e(n.data,a)}},length:function(){return o.tasks.length},running:function(){return i}};return o},a.cargo=function(e,t){var n=!1,r=[],i={tasks:r,payload:t,saturated:null,empty:null,drain:null,push:function(e,n){e.constructor!==Array&&(e=[e]),u(e,function(e){r.push({data:e,callback:"function"==typeof n?n:null}),i.saturated&&r.length===t&&i.saturated()}),a.setImmediate(i.process)},process:function o(){if(!n){if(0===r.length)return i.drain&&i.drain(),void 0;var a="number"==typeof t?r.splice(0,t):r.splice(0),c=s(a,function(e){return e.data});i.empty&&i.empty(),n=!0,e(c,function(){n=!1;var e=arguments;u(a,function(t){t.callback&&t.callback.apply(null,e)}),o()})}},length:function(){return r.length},running:function(){return n}};return i};var k=function(e){return function(t){var n=Array.prototype.slice.call(arguments,1);t.apply(null,n.concat([function(t){var n=Array.prototype.slice.call(arguments,1);"undefined"!=typeof console&&(t?console.error&&console.error(t):console[e]&&u(n,function(t){console[e](t)}))}]))}};a.log=k("log"),a.dir=k("dir"),a.memoize=function(e,t){var n={},r={};t=t||function(e){return e};var i=function(){var i=Array.prototype.slice.call(arguments),o=i.pop(),a=t.apply(null,i);a in n?o.apply(null,n[a]):a in r?r[a].push(o):(r[a]=[o],e.apply(null,i.concat([function(){n[a]=arguments;var e=r[a];delete r[a];for(var t=0,i=e.length;i>t;t++)e[t].apply(null,arguments)}])))};return i.memo=n,i.unmemoized=e,i},a.unmemoize=function(e){return function(){return(e.unmemoized||e).apply(null,arguments)}},a.times=function(e,t,n){for(var r=[],i=0;e>i;i++)r.push(i);return a.map(r,t,n)},a.timesSeries=function(e,t,n){for(var r=[],i=0;e>i;i++)r.push(i);return a.mapSeries(r,t,n)},a.compose=function(){var e=Array.prototype.reverse.call(arguments);return function(){var t=this,n=Array.prototype.slice.call(arguments),r=n.pop();a.reduce(e,n,function(e,n,r){n.apply(t,e.concat([function(){var e=arguments[0],t=Array.prototype.slice.call(arguments,1);r(e,t)}]))},function(e,n){r.apply(t,[e].concat(n))})}};var x=function(e,t){var n=function(){var n=this,r=Array.prototype.slice.call(arguments),i=r.pop();return e(t,function(e,t){e.apply(n,r.concat([t]))},i)};if(arguments.length>2){var r=Array.prototype.slice.call(arguments,2);return n.apply(this,r)}return n};a.applyEach=h(x),a.applyEachSeries=d(x),a.forever=function(e,t){function n(r){if(r){if(t)return t(r);throw r}e(n)}n()},"undefined"!=typeof e&&e.amd?e([],function(){return a}):"undefined"!=typeof n&&n.exports?n.exports=a:i.async=a}()},{__browserify_process:4}],14:[function(e,t){t.exports.BinarySearchTree=e("./lib/bst"),t.exports.AVLTree=e("./lib/avltree")},{"./lib/avltree":15,"./lib/bst":16}],15:[function(e,t){function n(e){this.tree=new r(e)}function r(e){e=e||{},this.left=null,this.right=null,this.parent=void 0!==e.parent?e.parent:null,e.hasOwnProperty("key")&&(this.key=e.key),this.data=e.hasOwnProperty("value")?[e.value]:[],this.unique=e.unique||!1,this.compareKeys=e.compareKeys||o.defaultCompareKeysFunction,this.checkValueEquality=e.checkValueEquality||o.defaultCheckValueEquality}var i=e("./bst"),o=e("./customUtils"),a=e("util");e("underscore"),a.inherits(r,i),n._AVLTree=r,r.prototype.checkHeightCorrect=function(){var e,t;if(this.hasOwnProperty("key")){if(this.left&&void 0===this.left.height)throw new Error("Undefined height for node "+this.left.key);if(this.right&&void 0===this.right.height)throw new Error("Undefined height for node "+this.right.key);if(void 0===this.height)throw new Error("Undefined height for node "+this.key);if(e=this.left?this.left.height:0,t=this.right?this.right.height:0,this.height!==1+Math.max(e,t))throw new Error("Height constraint failed for node "+this.key);this.left&&this.left.checkHeightCorrect(),this.right&&this.right.checkHeightCorrect()}},r.prototype.balanceFactor=function(){var e=this.left?this.left.height:0,t=this.right?this.right.height:0;return e-t},r.prototype.checkBalanceFactors=function(){if(Math.abs(this.balanceFactor())>1)throw new Error("Tree is unbalanced at node "+this.key);this.left&&this.left.checkBalanceFactors(),this.right&&this.right.checkBalanceFactors()},r.prototype.checkIsAVLT=function(){r.super_.prototype.checkIsBST.call(this),this.checkHeightCorrect(),this.checkBalanceFactors()},n.prototype.checkIsAVLT=function(){this.tree.checkIsAVLT()},r.prototype.rightRotation=function(){var e,t,n,r,i=this,o=this.left;return o?(e=o.right,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.right=i,i.parent=o,i.left=e,e&&(e.parent=i),t=o.left?o.left.height:0,n=e?e.height:0,r=i.right?i.right.height:0,i.height=Math.max(n,r)+1,o.height=Math.max(t,i.height)+1,o):this},r.prototype.leftRotation=function(){var e,t,n,r,i=this,o=this.right;return o?(e=o.left,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.left=i,i.parent=o,i.right=e,e&&(e.parent=i),t=i.left?i.left.height:0,n=e?e.height:0,r=o.right?o.right.height:0,i.height=Math.max(t,n)+1,o.height=Math.max(r,i.height)+1,o):this},r.prototype.rightTooSmall=function(){return this.balanceFactor()<=1?this:(this.left.balanceFactor()<0&&this.left.leftRotation(),this.rightRotation())},r.prototype.leftTooSmall=function(){return this.balanceFactor()>=-1?this:(this.right.balanceFactor()>0&&this.right.rightRotation(),this.leftRotation())},r.prototype.rebalanceAlongPath=function(e){var t,n,r=this;if(!this.hasOwnProperty("key"))return delete this.height,this;for(n=e.length-1;n>=0;n-=1)e[n].height=1+Math.max(e[n].left?e[n].left.height:0,e[n].right?e[n].right.height:0),e[n].balanceFactor()>1&&(t=e[n].rightTooSmall(),0===n&&(r=t)),e[n].balanceFactor()<-1&&(t=e[n].leftTooSmall(),0===n&&(r=t));return r},r.prototype.insert=function(e,t){var n=[],r=this;if(!this.hasOwnProperty("key"))return this.key=e,this.data.push(t),this.height=1,this;for(;;){if(0===r.compareKeys(r.key,e)){if(r.unique){var i=new Error("Can't insert key "+e+", it violates the unique constraint");throw i.key=e,i.errorType="uniqueViolated",i}return r.data.push(t),this}if(n.push(r),r.compareKeys(e,r.key)<0){if(!r.left){n.push(r.createLeftChild({key:e,value:t}));break}r=r.left}else{if(!r.right){n.push(r.createRightChild({key:e,value:t}));break}r=r.right}}return this.rebalanceAlongPath(n)},n.prototype.insert=function(e,t){var n=this.tree.insert(e,t);n&&(this.tree=n)},r.prototype.delete=function(e,t){var n,r=[],i=this,o=[];if(!this.hasOwnProperty("key"))return this;for(;;){if(0===i.compareKeys(e,i.key))break;if(o.push(i),i.compareKeys(e,i.key)<0){if(!i.left)return this;i=i.left}else{if(!i.right)return this;i=i.right}}if(i.data.length>1&&t)return i.data.forEach(function(e){i.checkValueEquality(e,t)||r.push(e)}),i.data=r,this;if(!i.left&&!i.right)return i===this?(delete i.key,i.data=[],delete i.height,this):(i.parent.left===i?i.parent.left=null:i.parent.right=null,this.rebalanceAlongPath(o));if(!i.left||!i.right)return n=i.left?i.left:i.right,i===this?(n.parent=null,n):(i.parent.left===i?(i.parent.left=n,n.parent=i.parent):(i.parent.right=n,n.parent=i.parent),this.rebalanceAlongPath(o));if(o.push(i),n=i.left,!n.right)return i.key=n.key,i.data=n.data,i.left=n.left,n.left&&(n.left.parent=i),this.rebalanceAlongPath(o);for(;;){if(!n.right)break;o.push(n),n=n.right}return i.key=n.key,i.data=n.data,n.parent.right=n.left,n.left&&(n.left.parent=n.parent),this.rebalanceAlongPath(o)},n.prototype.delete=function(e,t){var n=this.tree.delete(e,t);n&&(this.tree=n)},["getNumberOfKeys","search","betweenBounds","prettyPrint","executeOnEveryNode"].forEach(function(e){n.prototype[e]=function(){return this.tree[e].apply(this.tree,arguments)}}),t.exports=n},{"./bst":16,"./customUtils":17,underscore:19,util:3}],16:[function(e,t){function n(e){e=e||{},this.left=null,this.right=null,this.parent=void 0!==e.parent?e.parent:null,e.hasOwnProperty("key")&&(this.key=e.key),this.data=e.hasOwnProperty("value")?[e.value]:[],this.unique=e.unique||!1,this.compareKeys=e.compareKeys||i.defaultCompareKeysFunction,this.checkValueEquality=e.checkValueEquality||i.defaultCheckValueEquality}function r(e,t){var n;for(n=0;n<t.length;n+=1)e.push(t[n])}var i=e("./customUtils");n.prototype.getMaxKeyDescendant=function(){return this.right?this.right.getMaxKeyDescendant():this},n.prototype.getMaxKey=function(){return this.getMaxKeyDescendant().key},n.prototype.getMinKeyDescendant=function(){return this.left?this.left.getMinKeyDescendant():this},n.prototype.getMinKey=function(){return this.getMinKeyDescendant().key},n.prototype.checkAllNodesFullfillCondition=function(e){this.hasOwnProperty("key")&&(e(this.key,this.data),this.left&&this.left.checkAllNodesFullfillCondition(e),this.right&&this.right.checkAllNodesFullfillCondition(e))},n.prototype.checkNodeOrdering=function(){var e=this;this.hasOwnProperty("key")&&(this.left&&(this.left.checkAllNodesFullfillCondition(function(t){if(e.compareKeys(t,e.key)>=0)throw new Error("Tree with root "+e.key+" is not a binary search tree")}),this.left.checkNodeOrdering()),this.right&&(this.right.checkAllNodesFullfillCondition(function(t){if(e.compareKeys(t,e.key)<=0)throw new Error("Tree with root "+e.key+" is not a binary search tree")}),this.right.checkNodeOrdering()))},n.prototype.checkInternalPointers=function(){if(this.left){if(this.left.parent!==this)throw new Error("Parent pointer broken for key "+this.key);this.left.checkInternalPointers()}if(this.right){if(this.right.parent!==this)throw new Error("Parent pointer broken for key "+this.key);this.right.checkInternalPointers()}},n.prototype.checkIsBST=function(){if(this.checkNodeOrdering(),this.checkInternalPointers(),this.parent)throw new Error("The root shouldn't have a parent")},n.prototype.getNumberOfKeys=function(){var e;return this.hasOwnProperty("key")?(e=1,this.left&&(e+=this.left.getNumberOfKeys()),this.right&&(e+=this.right.getNumberOfKeys()),e):0},n.prototype.createSimilar=function(e){return e=e||{},e.unique=this.unique,e.compareKeys=this.compareKeys,e.checkValueEquality=this.checkValueEquality,new this.constructor(e)},n.prototype.createLeftChild=function(e){var t=this.createSimilar(e);return t.parent=this,this.left=t,t},n.prototype.createRightChild=function(e){var t=this.createSimilar(e);return t.parent=this,this.right=t,t},n.prototype.insert=function(e,t){if(!this.hasOwnProperty("key"))return this.key=e,this.data.push(t),void 0;if(0===this.compareKeys(this.key,e)){if(this.unique){var n=new Error("Can't insert key "+e+", it violates the unique constraint");throw n.key=e,n.errorType="uniqueViolated",n}return this.data.push(t),void 0}this.compareKeys(e,this.key)<0?this.left?this.left.insert(e,t):this.createLeftChild({key:e,value:t}):this.right?this.right.insert(e,t):this.createRightChild({key:e,value:t})},n.prototype.search=function(e){return this.hasOwnProperty("key")?0===this.compareKeys(this.key,e)?this.data:this.compareKeys(e,this.key)<0?this.left?this.left.search(e):[]:this.right?this.right.search(e):[]:[]},n.prototype.getLowerBoundMatcher=function(e){var t=this;return e.hasOwnProperty("$gt")||e.hasOwnProperty("$gte")?e.hasOwnProperty("$gt")&&e.hasOwnProperty("$gte")?0===t.compareKeys(e.$gte,e.$gt)?function(n){return t.compareKeys(n,e.$gt)>0}:t.compareKeys(e.$gte,e.$gt)>0?function(n){return t.compareKeys(n,e.$gte)>=0}:function(n){return t.compareKeys(n,e.$gt)>0}:e.hasOwnProperty("$gt")?function(n){return t.compareKeys(n,e.$gt)>0}:function(n){return t.compareKeys(n,e.$gte)>=0}:function(){return!0}},n.prototype.getUpperBoundMatcher=function(e){var t=this;return e.hasOwnProperty("$lt")||e.hasOwnProperty("$lte")?e.hasOwnProperty("$lt")&&e.hasOwnProperty("$lte")?0===t.compareKeys(e.$lte,e.$lt)?function(n){return t.compareKeys(n,e.$lt)<0}:t.compareKeys(e.$lte,e.$lt)<0?function(n){return t.compareKeys(n,e.$lte)<=0}:function(n){return t.compareKeys(n,e.$lt)<0}:e.hasOwnProperty("$lt")?function(n){return t.compareKeys(n,e.$lt)<0}:function(n){return t.compareKeys(n,e.$lte)<=0}:function(){return!0}},n.prototype.betweenBounds=function(e,t,n){var i=[];return this.hasOwnProperty("key")?(t=t||this.getLowerBoundMatcher(e),n=n||this.getUpperBoundMatcher(e),t(this.key)&&this.left&&r(i,this.left.betweenBounds(e,t,n)),t(this.key)&&n(this.key)&&r(i,this.data),n(this.key)&&this.right&&r(i,this.right.betweenBounds(e,t,n)),i):[]},n.prototype.deleteIfLeaf=function(){return this.left||this.right?!1:this.parent?(this.parent.left===this?this.parent.left=null:this.parent.right=null,!0):(delete this.key,this.data=[],!0)},n.prototype.deleteIfOnlyOneChild=function(){var e;return this.left&&!this.right&&(e=this.left),!this.left&&this.right&&(e=this.right),e?this.parent?(this.parent.left===this?(this.parent.left=e,e.parent=this.parent):(this.parent.right=e,e.parent=this.parent),!0):(this.key=e.key,this.data=e.data,this.left=null,e.left&&(this.left=e.left,e.left.parent=this),this.right=null,e.right&&(this.right=e.right,e.right.parent=this),!0):!1},n.prototype.delete=function(e,t){var n,r=[],i=this;if(this.hasOwnProperty("key")){if(this.compareKeys(e,this.key)<0)return this.left&&this.left.delete(e,t),void 0;if(this.compareKeys(e,this.key)>0)return this.right&&this.right.delete(e,t),void 0;if(0!==!this.compareKeys(e,this.key))return this.data.length>1&&void 0!==t?(this.data.forEach(function(e){i.checkValueEquality(e,t)||r.push(e)}),i.data=r,void 0):(this.deleteIfLeaf()||this.deleteIfOnlyOneChild()||(Math.random()>=.5?(n=this.left.getMaxKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.left=n.left,n.left&&(n.left.parent=n.parent)):(n.parent.right=n.left,n.left&&(n.left.parent=n.parent))):(n=this.right.getMinKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.right=n.right,n.right&&(n.right.parent=n.parent)):(n.parent.left=n.right,n.right&&(n.right.parent=n.parent)))),void 0)}},n.prototype.executeOnEveryNode=function(e){this.left&&this.left.executeOnEveryNode(e),e(this),this.right&&this.right.executeOnEveryNode(e)},n.prototype.prettyPrint=function(e,t){t=t||"",console.log(t+"* "+this.key),e&&console.log(t+"* "+this.data),(this.left||this.right)&&(this.left?this.left.prettyPrint(e,t+"  "):console.log(t+"  *"),this.right?this.right.prettyPrint(e,t+"  "):console.log(t+"  *"))},t.exports=n},{"./customUtils":17}],17:[function(e,t){function n(e){var t,r;return 0===e?[]:1===e?[0]:(t=n(e-1),r=Math.floor(Math.random()*e),t.splice(r,0,e-1),t)}function r(e,t){if(t>e)return-1;if(e>t)return 1;if(e===t)return 0;var n=new Error("Couldn't compare elements");throw n.a=e,n.b=t,n}function i(e,t){return e===t}t.exports.getRandomArray=n,t.exports.defaultCompareKeysFunction=r,t.exports.defaultCheckValueEquality=i},{}],18:[function(t,n,r){var i=self;!function(t){if("object"==typeof r&&"undefined"!=typeof n)n.exports=t();else if("function"==typeof e&&e.amd)e([],t);else{var o;o="undefined"!=typeof window?window:"undefined"!=typeof i?i:"undefined"!=typeof self?self:this,o.localforage=t()}}(function(){return function e(n,r,i){function o(u,s){if(!r[u]){if(!n[u]){var c="function"==typeof t&&t;if(!s&&c)return c(u,!0);if(a)return a(u,!0);var f=new Error("Cannot find module '"+u+"'");throw f.code="MODULE_NOT_FOUND",f}var l=r[u]={exports:{}};n[u][0].call(l.exports,function(e){var t=n[u][1][e];return o(t?t:e)},l,l.exports,e,n,r,i)}return r[u].exports}for(var a="function"==typeof t&&t,u=0;u<i.length;u++)o(i[u]);return o}({1:[function(e,t){!function(e){"use strict";function n(){f=!0;for(var e,t,n=l.length;n;){for(t=l,l=[],e=-1;++e<n;)t[e]();n=l.length}f=!1}function r(e){1!==l.push(e)||f||i()}var i,o=e.MutationObserver||e.WebKitMutationObserver;if(o){var a=0,u=new o(n),s=e.document.createTextNode("");u.observe(s,{characterData:!0}),i=function(){s.data=a=++a%2}}else if(e.setImmediate||"undefined"==typeof e.MessageChannel)i="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){n(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(n,0)};else{var c=new e.MessageChannel;c.port1.onmessage=n,i=function(){c.port2.postMessage(0)}}var f,l=[];t.exports=r}.call(this,"undefined"!=typeof i?i:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(e,t){"use strict";function n(){}function r(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=g,this.queue=[],this.outcome=void 0,e!==n&&u(this,e)}function i(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}function o(e,t,n){p(function(){var r;try{r=t(n)}catch(i){return d.reject(e,i)}r===e?d.reject(e,new TypeError("Cannot resolve promise with itself")):d.resolve(e,r)
-})}function a(e){var t=e&&e.then;return!e||"object"!=typeof e&&"function"!=typeof e||"function"!=typeof t?void 0:function(){t.apply(e,arguments)}}function u(e,t){function n(t){o||(o=!0,d.reject(e,t))}function r(t){o||(o=!0,d.resolve(e,t))}function i(){t(r,n)}var o=!1,a=s(i);"error"===a.status&&n(a.value)}function s(e,t){var n={};try{n.value=e(t),n.status="success"}catch(r){n.status="error",n.value=r}return n}function c(e){return e instanceof this?e:d.resolve(new this(n),e)}function f(e){var t=new this(n);return d.reject(t,e)}function l(e){function t(e,t){function n(e){a[t]=e,++u!==i||o||(o=!0,d.resolve(c,a))}r.resolve(e).then(n,function(e){o||(o=!0,d.reject(c,e))})}var r=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var i=e.length,o=!1;if(!i)return this.resolve([]);for(var a=new Array(i),u=0,s=-1,c=new this(n);++s<i;)t(e[s],s);return c}function h(e){function t(e){r.resolve(e).then(function(e){o||(o=!0,d.resolve(u,e))},function(e){o||(o=!0,d.reject(u,e))})}var r=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var i=e.length,o=!1;if(!i)return this.resolve([]);for(var a=-1,u=new this(n);++a<i;)t(e[a]);return u}var p=e(1),d={},y=["REJECTED"],v=["FULFILLED"],g=["PENDING"];t.exports=r,r.prototype["catch"]=function(e){return this.then(null,e)},r.prototype.then=function(e,t){if("function"!=typeof e&&this.state===v||"function"!=typeof t&&this.state===y)return this;var r=new this.constructor(n);if(this.state!==g){var a=this.state===v?e:t;o(r,a,this.outcome)}else this.queue.push(new i(r,e,t));return r},i.prototype.callFulfilled=function(e){d.resolve(this.promise,e)},i.prototype.otherCallFulfilled=function(e){o(this.promise,this.onFulfilled,e)},i.prototype.callRejected=function(e){d.reject(this.promise,e)},i.prototype.otherCallRejected=function(e){o(this.promise,this.onRejected,e)},d.resolve=function(e,t){var n=s(a,t);if("error"===n.status)return d.reject(e,n.value);var r=n.value;if(r)u(e,r);else{e.state=v,e.outcome=t;for(var i=-1,o=e.queue.length;++i<o;)e.queue[i].callFulfilled(t)}return e},d.reject=function(e,t){e.state=y,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e},r.resolve=c,r.reject=f,r.all=l,r.race=h},{1:1}],3:[function(e){!function(t){"use strict";"function"!=typeof t.Promise&&(t.Promise=e(2))}.call(this,"undefined"!=typeof i?i:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(e,t){"use strict";function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(e){return}}function i(){try{if(!bt)return!1;var e="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),t="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!e||t)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(n){return!1}}function o(e,t){e=e||[],t=t||{};try{return new Blob(e,t)}catch(n){if("TypeError"!==n.name)throw n;for(var r="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,i=new r,o=0;o<e.length;o+=1)i.append(e[o]);return i.getBlob(t.type)}}function a(e,t){t&&e.then(function(e){t(null,e)},function(e){t(e)})}function u(e,t,n){"function"==typeof t&&e.then(t),"function"==typeof n&&e["catch"](n)}function s(e){return"string"!=typeof e&&(console.warn(e+" used as a key, but it is not a string."),e=String(e)),e}function c(){return arguments.length&&"function"==typeof arguments[arguments.length-1]?arguments[arguments.length-1]:void 0}function f(e){for(var t=e.length,n=new ArrayBuffer(t),r=new Uint8Array(n),i=0;t>i;i++)r[i]=e.charCodeAt(i);return n}function l(e){return new wt(function(t){var n=e.transaction(_t,jt),r=o([""]);n.objectStore(_t).put(r,"key"),n.onabort=function(e){e.preventDefault(),e.stopPropagation(),t(!1)},n.oncomplete=function(){var e=navigator.userAgent.match(/Chrome\/(\d+)/),n=navigator.userAgent.match(/Edge\//);t(n||!e||parseInt(e[1],10)>=43)}})["catch"](function(){return!1})}function h(e){return"boolean"==typeof kt?wt.resolve(kt):l(e).then(function(e){return kt=e})}function p(e){var t=xt[e.name],n={};n.promise=new wt(function(e,t){n.resolve=e,n.reject=t}),t.deferredOperations.push(n),t.dbReady=t.dbReady?t.dbReady.then(function(){return n.promise}):n.promise}function d(e){var t=xt[e.name],n=t.deferredOperations.pop();return n?(n.resolve(),n.promise):void 0}function y(e,t){var n=xt[e.name],r=n.deferredOperations.pop();return r?(r.reject(t),r.promise):void 0}function v(e,t){return new wt(function(n,r){if(xt[e.name]=xt[e.name]||j(),e.db){if(!t)return n(e.db);p(e),e.db.close()}var i=[e.name];t&&i.push(e.version);var o=bt.open.apply(bt,i);t&&(o.onupgradeneeded=function(t){var n=o.result;try{n.createObjectStore(e.storeName),t.oldVersion<=1&&n.createObjectStore(_t)}catch(r){if("ConstraintError"!==r.name)throw r;console.warn('The database "'+e.name+'"'+" has been upgraded from version "+t.oldVersion+" to version "+t.newVersion+', but the storage "'+e.storeName+'" already exists.')}}),o.onerror=function(e){e.preventDefault(),r(o.error)},o.onsuccess=function(){n(o.result),d(e)}})}function g(e){return v(e,!1)}function m(e){return v(e,!0)}function b(e,t){if(!e.db)return!0;var n=!e.db.objectStoreNames.contains(e.storeName),r=e.version<e.db.version,i=e.version>e.db.version;if(r&&(e.version!==t&&console.warn('The database "'+e.name+'"'+" can't be downgraded from version "+e.db.version+" to version "+e.version+"."),e.version=e.db.version),i||n){if(n){var o=e.db.version+1;o>e.version&&(e.version=o)}return!0}return!1}function w(e){return new wt(function(t,n){var r=new FileReader;r.onerror=n,r.onloadend=function(n){var r=btoa(n.target.result||"");t({__local_forage_encoded_blob:!0,data:r,type:e.type})},r.readAsBinaryString(e)})}function _(e){var t=f(atob(e.data));return o([t],{type:e.type})}function k(e){return e&&e.__local_forage_encoded_blob}function x(e){var t=this,n=t._initReady().then(function(){var e=xt[t._dbInfo.name];return e&&e.dbReady?e.dbReady:void 0});return u(n,e,e),n}function E(e){p(e);for(var t=xt[e.name],n=t.forages,r=0;r<n.length;r++){var i=n[r];i._dbInfo.db&&(i._dbInfo.db.close(),i._dbInfo.db=null)}return e.db=null,g(e).then(function(t){return e.db=t,b(e)?m(e):t}).then(function(r){e.db=t.db=r;for(var i=0;i<n.length;i++)n[i]._dbInfo.db=r})["catch"](function(t){throw y(e,t),t})}function A(e,t,n,r){void 0===r&&(r=1);try{var i=e.db.transaction(e.storeName,t);n(null,i)}catch(o){if(r>0&&(!e.db||"InvalidStateError"===o.name||"NotFoundError"===o.name))return wt.resolve().then(function(){return!e.db||"NotFoundError"===o.name&&!e.db.objectStoreNames.contains(e.storeName)&&e.version<=e.db.version?(e.db&&(e.version=e.db.version+1),m(e)):void 0}).then(function(){return E(e).then(function(){A(e,t,n,r-1)})})["catch"](n);n(o)}}function j(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function I(e){function t(){return wt.resolve()}var n=this,r={db:null};if(e)for(var i in e)r[i]=e[i];var o=xt[r.name];o||(o=j(),xt[r.name]=o),o.forages.push(n),n._initReady||(n._initReady=n.ready,n.ready=x);for(var a=[],u=0;u<o.forages.length;u++){var s=o.forages[u];s!==n&&a.push(s._initReady()["catch"](t))}var c=o.forages.slice(0);return wt.all(a).then(function(){return r.db=o.db,g(r)}).then(function(e){return r.db=e,b(r,n._defaultConfig.version)?m(r):e}).then(function(e){r.db=o.db=e,n._dbInfo=r;for(var t=0;t<c.length;t++){var i=c[t];i!==n&&(i._dbInfo.db=r.db,i._dbInfo.version=r.version)}})}function O(e,t){var n=this;e=s(e);var r=new wt(function(t,r){n.ready().then(function(){A(n._dbInfo,At,function(i,o){if(i)return r(i);try{var a=o.objectStore(n._dbInfo.storeName),u=a.get(e);u.onsuccess=function(){var e=u.result;void 0===e&&(e=null),k(e)&&(e=_(e)),t(e)},u.onerror=function(){r(u.error)}}catch(s){r(s)}})})["catch"](r)});return a(r,t),r}function S(e,t){var n=this,r=new wt(function(t,r){n.ready().then(function(){A(n._dbInfo,At,function(i,o){if(i)return r(i);try{var a=o.objectStore(n._dbInfo.storeName),u=a.openCursor(),s=1;u.onsuccess=function(){var n=u.result;if(n){var r=n.value;k(r)&&(r=_(r));var i=e(r,n.key,s++);void 0!==i?t(i):n["continue"]()}else t()},u.onerror=function(){r(u.error)}}catch(c){r(c)}})})["catch"](r)});return a(r,t),r}function $(e,t,n){var r=this;e=s(e);var i=new wt(function(n,i){var o;r.ready().then(function(){return o=r._dbInfo,"[object Blob]"===Et.call(t)?h(o.db).then(function(e){return e?t:w(t)}):t}).then(function(t){A(r._dbInfo,jt,function(o,a){if(o)return i(o);try{var u=a.objectStore(r._dbInfo.storeName);null===t&&(t=void 0);var s=u.put(t,e);a.oncomplete=function(){void 0===t&&(t=null),n(t)},a.onabort=a.onerror=function(){var e=s.error?s.error:s.transaction.error;i(e)}}catch(c){i(c)}})})["catch"](i)});return a(i,n),i}function N(e,t){var n=this;e=s(e);var r=new wt(function(t,r){n.ready().then(function(){A(n._dbInfo,jt,function(i,o){if(i)return r(i);try{var a=o.objectStore(n._dbInfo.storeName),u=a["delete"](e);o.oncomplete=function(){t()},o.onerror=function(){r(u.error)},o.onabort=function(){var e=u.error?u.error:u.transaction.error;r(e)}}catch(s){r(s)}})})["catch"](r)});return a(r,t),r}function D(e){var t=this,n=new wt(function(e,n){t.ready().then(function(){A(t._dbInfo,jt,function(r,i){if(r)return n(r);try{var o=i.objectStore(t._dbInfo.storeName),a=o.clear();i.oncomplete=function(){e()},i.onabort=i.onerror=function(){var e=a.error?a.error:a.transaction.error;n(e)}}catch(u){n(u)}})})["catch"](n)});return a(n,e),n}function T(e){var t=this,n=new wt(function(e,n){t.ready().then(function(){A(t._dbInfo,At,function(r,i){if(r)return n(r);try{var o=i.objectStore(t._dbInfo.storeName),a=o.count();a.onsuccess=function(){e(a.result)},a.onerror=function(){n(a.error)}}catch(u){n(u)}})})["catch"](n)});return a(n,e),n}function C(e,t){var n=this,r=new wt(function(t,r){return 0>e?(t(null),void 0):(n.ready().then(function(){A(n._dbInfo,At,function(i,o){if(i)return r(i);try{var a=o.objectStore(n._dbInfo.storeName),u=!1,s=a.openCursor();s.onsuccess=function(){var n=s.result;return n?(0===e?t(n.key):u?t(n.key):(u=!0,n.advance(e)),void 0):(t(null),void 0)},s.onerror=function(){r(s.error)}}catch(c){r(c)}})})["catch"](r),void 0)});return a(r,t),r}function M(e){var t=this,n=new wt(function(e,n){t.ready().then(function(){A(t._dbInfo,At,function(r,i){if(r)return n(r);try{var o=i.objectStore(t._dbInfo.storeName),a=o.openCursor(),u=[];a.onsuccess=function(){var t=a.result;return t?(u.push(t.key),t["continue"](),void 0):(e(u),void 0)},a.onerror=function(){n(a.error)}}catch(s){n(s)}})})["catch"](n)});return a(n,e),n}function F(e,t){t=c.apply(this,arguments);var n=this.config();e="function"!=typeof e&&e||{},e.name||(e.name=e.name||n.name,e.storeName=e.storeName||n.storeName);var r,i=this;if(e.name){var o=e.name===n.name&&i._dbInfo.db,u=o?wt.resolve(i._dbInfo.db):g(e).then(function(t){var n=xt[e.name],r=n.forages;n.db=t;for(var i=0;i<r.length;i++)r[i]._dbInfo.db=t;return t});r=e.storeName?u.then(function(t){if(t.objectStoreNames.contains(e.storeName)){var n=t.version+1;p(e);var r=xt[e.name],i=r.forages;t.close();for(var o=0;o<i.length;o++){var a=i[o];a._dbInfo.db=null,a._dbInfo.version=n}var u=new wt(function(t,r){var i=bt.open(e.name,n);i.onerror=function(e){var t=i.result;t.close(),r(e)},i.onupgradeneeded=function(){var t=i.result;t.deleteObjectStore(e.storeName)},i.onsuccess=function(){var e=i.result;e.close(),t(e)}});return u.then(function(e){r.db=e;for(var t=0;t<i.length;t++){var n=i[t];n._dbInfo.db=e,d(n._dbInfo)}})["catch"](function(t){throw(y(e,t)||wt.resolve())["catch"](function(){}),t})}}):u.then(function(t){p(e);var n=xt[e.name],r=n.forages;t.close();for(var i=0;i<r.length;i++){var o=r[i];o._dbInfo.db=null}var a=new wt(function(t,n){var r=bt.deleteDatabase(e.name);r.onerror=r.onblocked=function(e){var t=r.result;t&&t.close(),n(e)},r.onsuccess=function(){var e=r.result;e&&e.close(),t(e)}});return a.then(function(e){n.db=e;for(var t=0;t<r.length;t++){var i=r[t];d(i._dbInfo)}})["catch"](function(t){throw(y(e,t)||wt.resolve())["catch"](function(){}),t})})}else r=wt.reject("Invalid arguments");return a(r,t),r}function R(){return"function"==typeof openDatabase}function P(e){var t,n,r,i,o,a=.75*e.length,u=e.length,s=0;"="===e[e.length-1]&&(a--,"="===e[e.length-2]&&a--);var c=new ArrayBuffer(a),f=new Uint8Array(c);for(t=0;u>t;t+=4)n=Ot.indexOf(e[t]),r=Ot.indexOf(e[t+1]),i=Ot.indexOf(e[t+2]),o=Ot.indexOf(e[t+3]),f[s++]=n<<2|r>>4,f[s++]=(15&r)<<4|i>>2,f[s++]=(3&i)<<6|63&o;return c}function B(e){var t,n=new Uint8Array(e),r="";for(t=0;t<n.length;t+=3)r+=Ot[n[t]>>2],r+=Ot[(3&n[t])<<4|n[t+1]>>4],r+=Ot[(15&n[t+1])<<2|n[t+2]>>6],r+=Ot[63&n[t+2]];return 2===n.length%3?r=r.substring(0,r.length-1)+"=":1===n.length%3&&(r=r.substring(0,r.length-2)+"=="),r}function z(e,t){var n="";if(e&&(n=Vt.call(e)),e&&("[object ArrayBuffer]"===n||e.buffer&&"[object ArrayBuffer]"===Vt.call(e.buffer))){var r,i=Nt;e instanceof ArrayBuffer?(r=e,i+=Tt):(r=e.buffer,"[object Int8Array]"===n?i+=Mt:"[object Uint8Array]"===n?i+=Ft:"[object Uint8ClampedArray]"===n?i+=Rt:"[object Int16Array]"===n?i+=Pt:"[object Uint16Array]"===n?i+=zt:"[object Int32Array]"===n?i+=Bt:"[object Uint32Array]"===n?i+=qt:"[object Float32Array]"===n?i+=Lt:"[object Float64Array]"===n?i+=Kt:t(new Error("Failed to get type for BinaryArray"))),t(i+B(r))}else if("[object Blob]"===n){var o=new FileReader;o.onload=function(){var n=St+e.type+"~"+B(this.result);t(Nt+Ct+n)},o.readAsArrayBuffer(e)}else try{t(JSON.stringify(e))}catch(a){console.error("Couldn't convert value into a JSON string: ",e),t(null,a)}}function q(e){if(e.substring(0,Dt)!==Nt)return JSON.parse(e);var t,n=e.substring(Ut),r=e.substring(Dt,Ut);if(r===Ct&&$t.test(n)){var i=n.match($t);t=i[1],n=n.substring(i[0].length)}var a=P(n);switch(r){case Tt:return a;case Ct:return o([a],{type:t});case Mt:return new Int8Array(a);case Ft:return new Uint8Array(a);case Rt:return new Uint8ClampedArray(a);case Pt:return new Int16Array(a);case zt:return new Uint16Array(a);case Bt:return new Int32Array(a);case qt:return new Uint32Array(a);case Lt:return new Float32Array(a);case Kt:return new Float64Array(a);default:throw new Error("Unkown type: "+r)}}function L(e,t,n,r){e.executeSql("CREATE TABLE IF NOT EXISTS "+t.storeName+" "+"(id INTEGER PRIMARY KEY, key unique, value)",[],n,r)}function K(e){var t=this,n={db:null};if(e)for(var r in e)n[r]="string"!=typeof e[r]?e[r].toString():e[r];var i=new wt(function(e,r){try{n.db=openDatabase(n.name,String(n.version),n.description,n.size)}catch(i){return r(i)}n.db.transaction(function(i){L(i,n,function(){t._dbInfo=n,e()},function(e,t){r(t)})},r)});return n.serializer=Wt,i}function U(e,t,n,r,i,o){e.executeSql(n,r,i,function(e,a){a.code===a.SYNTAX_ERR?e.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?",[name],function(e,u){u.rows.length?o(e,a):L(e,t,function(){e.executeSql(n,r,i,o)},o)},o):o(e,a)},o)}function V(e,t){var n=this;e=s(e);var r=new wt(function(t,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){U(n,i,"SELECT * FROM "+i.storeName+" WHERE key = ? LIMIT 1",[e],function(e,n){var r=n.rows.length?n.rows.item(0).value:null;r&&(r=i.serializer.deserialize(r)),t(r)},function(e,t){r(t)})})})["catch"](r)});return a(r,t),r}function W(e,t){var n=this,r=new wt(function(t,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){U(n,i,"SELECT * FROM "+i.storeName,[],function(n,r){for(var o=r.rows,a=o.length,u=0;a>u;u++){var s=o.item(u),c=s.value;if(c&&(c=i.serializer.deserialize(c)),c=e(c,s.key,u+1),void 0!==c)return t(c),void 0}t()},function(e,t){r(t)})})})["catch"](r)});return a(r,t),r}function H(e,t,n,r){var i=this;e=s(e);var o=new wt(function(o,a){i.ready().then(function(){void 0===t&&(t=null);var u=t,s=i._dbInfo;s.serializer.serialize(t,function(t,c){c?a(c):s.db.transaction(function(n){U(n,s,"INSERT OR REPLACE INTO "+s.storeName+" "+"(key, value) VALUES (?, ?)",[e,t],function(){o(u)},function(e,t){a(t)})},function(t){if(t.code===t.QUOTA_ERR){if(r>0)return o(H.apply(i,[e,u,n,r-1])),void 0;a(t)}})})})["catch"](a)});return a(o,n),o}function G(e,t,n){return H.apply(this,[e,t,n,1])}function J(e,t){var n=this;e=s(e);var r=new wt(function(t,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){U(n,i,"DELETE FROM "+i.storeName+" WHERE key = ?",[e],function(){t()},function(e,t){r(t)})})})["catch"](r)});return a(r,t),r}function Y(e){var t=this,n=new wt(function(e,n){t.ready().then(function(){var r=t._dbInfo;r.db.transaction(function(t){U(t,r,"DELETE FROM "+r.storeName,[],function(){e()},function(e,t){n(t)})})})["catch"](n)});return a(n,e),n}function Q(e){var t=this,n=new wt(function(e,n){t.ready().then(function(){var r=t._dbInfo;r.db.transaction(function(t){U(t,r,"SELECT COUNT(key) as c FROM "+r.storeName,[],function(t,n){var r=n.rows.item(0).c;e(r)},function(e,t){n(t)})})})["catch"](n)});return a(n,e),n}function X(e,t){var n=this,r=new wt(function(t,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){U(n,i,"SELECT key FROM "+i.storeName+" WHERE id = ? LIMIT 1",[e+1],function(e,n){var r=n.rows.length?n.rows.item(0).key:null;t(r)},function(e,t){r(t)})})})["catch"](r)});return a(r,t),r}function Z(e){var t=this,n=new wt(function(e,n){t.ready().then(function(){var r=t._dbInfo;r.db.transaction(function(t){U(t,r,"SELECT key FROM "+r.storeName,[],function(t,n){for(var r=[],i=0;i<n.rows.length;i++)r.push(n.rows.item(i).key);e(r)},function(e,t){n(t)})})})["catch"](n)});return a(n,e),n}function et(e){return new wt(function(t,n){e.transaction(function(r){r.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",[],function(n,r){for(var i=[],o=0;o<r.rows.length;o++)i.push(r.rows.item(o).name);t({db:e,storeNames:i})},function(e,t){n(t)})},function(e){n(e)})})}function tt(e,t){t=c.apply(this,arguments);var n=this.config();e="function"!=typeof e&&e||{},e.name||(e.name=e.name||n.name,e.storeName=e.storeName||n.storeName);var r,i=this;return r=e.name?new wt(function(t){var r;r=e.name===n.name?i._dbInfo.db:openDatabase(e.name,"","",0),e.storeName?t({db:r,storeNames:[e.storeName]}):t(et(r))}).then(function(e){return new wt(function(t,n){e.db.transaction(function(r){function i(e){return new wt(function(t,n){r.executeSql("DROP TABLE IF EXISTS "+e,[],function(){t()},function(e,t){n(t)})})}for(var o=[],a=0,u=e.storeNames.length;u>a;a++)o.push(i(e.storeNames[a]));wt.all(o).then(function(){t()})["catch"](function(e){n(e)})},function(e){n(e)})})}):wt.reject("Invalid arguments"),a(r,t),r}function nt(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&!!localStorage.setItem}catch(e){return!1}}function rt(e,t){var n=e.name+"/";return e.storeName!==t.storeName&&(n+=e.storeName+"/"),n}function it(){var e="_localforage_support_test";try{return localStorage.setItem(e,!0),localStorage.removeItem(e),!1}catch(t){return!0}}function ot(){return!it()||localStorage.length>0}function at(e){var t=this,n={};if(e)for(var r in e)n[r]=e[r];return n.keyPrefix=rt(e,t._defaultConfig),ot()?(t._dbInfo=n,n.serializer=Wt,wt.resolve()):wt.reject()}function ut(e){var t=this,n=t.ready().then(function(){for(var e=t._dbInfo.keyPrefix,n=localStorage.length-1;n>=0;n--){var r=localStorage.key(n);0===r.indexOf(e)&&localStorage.removeItem(r)}});return a(n,e),n}function st(e,t){var n=this;e=s(e);var r=n.ready().then(function(){var t=n._dbInfo,r=localStorage.getItem(t.keyPrefix+e);return r&&(r=t.serializer.deserialize(r)),r});return a(r,t),r}function ct(e,t){var n=this,r=n.ready().then(function(){for(var t=n._dbInfo,r=t.keyPrefix,i=r.length,o=localStorage.length,a=1,u=0;o>u;u++){var s=localStorage.key(u);if(0===s.indexOf(r)){var c=localStorage.getItem(s);if(c&&(c=t.serializer.deserialize(c)),c=e(c,s.substring(i),a++),void 0!==c)return c}}});return a(r,t),r}function ft(e,t){var n=this,r=n.ready().then(function(){var t,r=n._dbInfo;try{t=localStorage.key(e)}catch(i){t=null}return t&&(t=t.substring(r.keyPrefix.length)),t});return a(r,t),r}function lt(e){var t=this,n=t.ready().then(function(){for(var e=t._dbInfo,n=localStorage.length,r=[],i=0;n>i;i++){var o=localStorage.key(i);0===o.indexOf(e.keyPrefix)&&r.push(o.substring(e.keyPrefix.length))}return r});return a(n,e),n}function ht(e){var t=this,n=t.keys().then(function(e){return e.length});return a(n,e),n}function pt(e,t){var n=this;e=s(e);var r=n.ready().then(function(){var t=n._dbInfo;localStorage.removeItem(t.keyPrefix+e)});return a(r,t),r}function dt(e,t,n){var r=this;e=s(e);var i=r.ready().then(function(){void 0===t&&(t=null);var n=t;return new wt(function(i,o){var a=r._dbInfo;a.serializer.serialize(t,function(t,r){if(r)o(r);else try{localStorage.setItem(a.keyPrefix+e,t),i(n)}catch(u){("QuotaExceededError"===u.name||"NS_ERROR_DOM_QUOTA_REACHED"===u.name)&&o(u),o(u)}})})});return a(i,n),i}function yt(e,t){if(t=c.apply(this,arguments),e="function"!=typeof e&&e||{},!e.name){var n=this.config();e.name=e.name||n.name,e.storeName=e.storeName||n.storeName}var r,i=this;return r=e.name?new wt(function(t){e.storeName?t(rt(e,i._defaultConfig)):t(e.name+"/")}).then(function(e){for(var t=localStorage.length-1;t>=0;t--){var n=localStorage.key(t);0===n.indexOf(e)&&localStorage.removeItem(n)}}):wt.reject("Invalid arguments"),a(r,t),r}function vt(e,t){e[t]=function(){var n=arguments;return e.ready().then(function(){return e[t].apply(e,n)})}}function gt(){for(var e=1;e<arguments.length;e++){var t=arguments[e];if(t)for(var n in t)t.hasOwnProperty(n)&&(arguments[0][n]=Qt(t[n])?t[n].slice():t[n])}return arguments[0]}var mt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},bt=r();"undefined"==typeof Promise&&e(3);var wt=Promise,_t="local-forage-detect-blob-support",kt=void 0,xt={},Et=Object.prototype.toString,At="readonly",jt="readwrite",It={_driver:"asyncStorage",_initStorage:I,_support:i(),iterate:S,getItem:O,setItem:$,removeItem:N,clear:D,length:T,key:C,keys:M,dropInstance:F},Ot="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",St="~~local_forage_type~",$t=/^~~local_forage_type~([^~]+)~/,Nt="__lfsc__:",Dt=Nt.length,Tt="arbf",Ct="blob",Mt="si08",Ft="ui08",Rt="uic8",Pt="si16",Bt="si32",zt="ur16",qt="ui32",Lt="fl32",Kt="fl64",Ut=Dt+Tt.length,Vt=Object.prototype.toString,Wt={serialize:z,deserialize:q,stringToBuffer:P,bufferToString:B},Ht={_driver:"webSQLStorage",_initStorage:K,_support:R(),iterate:W,getItem:V,setItem:G,removeItem:J,clear:Y,length:Q,key:X,keys:Z,dropInstance:tt},Gt={_driver:"localStorageWrapper",_initStorage:at,_support:nt(),iterate:ct,getItem:st,setItem:dt,removeItem:pt,clear:ut,length:ht,key:ft,keys:lt,dropInstance:yt},Jt=function(e,t){return e===t||"number"==typeof e&&"number"==typeof t&&isNaN(e)&&isNaN(t)},Yt=function(e,t){for(var n=e.length,r=0;n>r;){if(Jt(e[r],t))return!0;r++}return!1},Qt=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},Xt={},Zt={},en={INDEXEDDB:It,WEBSQL:Ht,LOCALSTORAGE:Gt},tn=[en.INDEXEDDB._driver,en.WEBSQL._driver,en.LOCALSTORAGE._driver],nn=["dropInstance"],rn=["clear","getItem","iterate","key","keys","length","removeItem","setItem"].concat(nn),on={description:"",driver:tn.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},an=function(){function e(t){n(this,e);for(var r in en)if(en.hasOwnProperty(r)){var i=en[r],o=i._driver;this[r]=o,Xt[o]||this.defineDriver(i)}this._defaultConfig=gt({},on),this._config=gt({},this._defaultConfig,t),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver)["catch"](function(){})}return e.prototype.config=function(e){if("object"===("undefined"==typeof e?"undefined":mt(e))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var t in e){if("storeName"===t&&(e[t]=e[t].replace(/\W/g,"_")),"version"===t&&"number"!=typeof e[t])return new Error("Database version must be a number.");this._config[t]=e[t]}return"driver"in e&&e.driver?this.setDriver(this._config.driver):!0}return"string"==typeof e?this._config[e]:this._config},e.prototype.defineDriver=function(e,t,n){var r=new wt(function(t,n){try{var r=e._driver,i=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!e._driver)return n(i),void 0;for(var o=rn.concat("_initStorage"),u=0,s=o.length;s>u;u++){var c=o[u],f=!Yt(nn,c);if((f||e[c])&&"function"!=typeof e[c])return n(i),void 0}var l=function(){for(var t=function(e){return function(){var t=new Error("Method "+e+" is not implemented by the current driver"),n=wt.reject(t);return a(n,arguments[arguments.length-1]),n}},n=0,r=nn.length;r>n;n++){var i=nn[n];e[i]||(e[i]=t(i))}};l();var h=function(n){Xt[r]&&console.info("Redefining LocalForage driver: "+r),Xt[r]=e,Zt[r]=n,t()};"_support"in e?e._support&&"function"==typeof e._support?e._support().then(h,n):h(!!e._support):h(!0)}catch(p){n(p)}});return u(r,t,n),r},e.prototype.driver=function(){return this._driver||null},e.prototype.getDriver=function(e,t,n){var r=Xt[e]?wt.resolve(Xt[e]):wt.reject(new Error("Driver not found."));return u(r,t,n),r},e.prototype.getSerializer=function(e){var t=wt.resolve(Wt);return u(t,e),t},e.prototype.ready=function(e){var t=this,n=t._driverSet.then(function(){return null===t._ready&&(t._ready=t._initDriver()),t._ready});return u(n,e,e),n},e.prototype.setDriver=function(e,t,n){function r(){a._config.driver=a.driver()}function i(e){return a._extend(e),r(),a._ready=a._initStorage(a._config),a._ready}function o(e){return function(){function t(){for(;n<e.length;){var o=e[n];return n++,a._dbInfo=null,a._ready=null,a.getDriver(o).then(i)["catch"](t)}r();var u=new Error("No available storage method found.");return a._driverSet=wt.reject(u),a._driverSet}var n=0;return t()}}var a=this;Qt(e)||(e=[e]);var s=this._getSupportedDrivers(e),c=null!==this._driverSet?this._driverSet["catch"](function(){return wt.resolve()}):wt.resolve();return this._driverSet=c.then(function(){var e=s[0];return a._dbInfo=null,a._ready=null,a.getDriver(e).then(function(e){a._driver=e._driver,r(),a._wrapLibraryMethodsWithReady(),a._initDriver=o(s)})})["catch"](function(){r();var e=new Error("No available storage method found.");return a._driverSet=wt.reject(e),a._driverSet}),u(this._driverSet,t,n),this._driverSet},e.prototype.supports=function(e){return!!Zt[e]},e.prototype._extend=function(e){gt(this,e)},e.prototype._getSupportedDrivers=function(e){for(var t=[],n=0,r=e.length;r>n;n++){var i=e[n];this.supports(i)&&t.push(i)}return t},e.prototype._wrapLibraryMethodsWithReady=function(){for(var e=0,t=rn.length;t>e;e++)vt(this,rn[e])},e.prototype.createInstance=function(t){return new e(t)},e}(),un=new an;t.exports=un},{3:3}]},{},[4])(4)})},{}],19:[function(e,t,n){!function(){var e=this,r=e._,i={},o=Array.prototype,a=Object.prototype,u=Function.prototype,s=o.push,c=o.slice,f=o.concat,l=a.toString,h=a.hasOwnProperty,p=o.forEach,d=o.map,y=o.reduce,v=o.reduceRight,g=o.filter,m=o.every,b=o.some,w=o.indexOf,_=o.lastIndexOf,k=Array.isArray,x=Object.keys,E=u.bind,A=function(e){return e instanceof A?e:this instanceof A?(this._wrapped=e,void 0):new A(e)};"undefined"!=typeof n?("undefined"!=typeof t&&t.exports&&(n=t.exports=A),n._=A):e._=A,A.VERSION="1.4.4";var j=A.each=A.forEach=function(e,t,n){if(null!=e)if(p&&e.forEach===p)e.forEach(t,n);else if(e.length===+e.length){for(var r=0,o=e.length;o>r;r++)if(t.call(n,e[r],r,e)===i)return}else for(var a in e)if(A.has(e,a)&&t.call(n,e[a],a,e)===i)return};A.map=A.collect=function(e,t,n){var r=[];return null==e?r:d&&e.map===d?e.map(t,n):(j(e,function(e,i,o){r[r.length]=t.call(n,e,i,o)}),r)};var I="Reduce of empty array with no initial value";A.reduce=A.foldl=A.inject=function(e,t,n,r){var i=arguments.length>2;if(null==e&&(e=[]),y&&e.reduce===y)return r&&(t=A.bind(t,r)),i?e.reduce(t,n):e.reduce(t);if(j(e,function(e,o,a){i?n=t.call(r,n,e,o,a):(n=e,i=!0)}),!i)throw new TypeError(I);return n},A.reduceRight=A.foldr=function(e,t,n,r){var i=arguments.length>2;if(null==e&&(e=[]),v&&e.reduceRight===v)return r&&(t=A.bind(t,r)),i?e.reduceRight(t,n):e.reduceRight(t);var o=e.length;if(o!==+o){var a=A.keys(e);o=a.length}if(j(e,function(u,s,c){s=a?a[--o]:--o,i?n=t.call(r,n,e[s],s,c):(n=e[s],i=!0)}),!i)throw new TypeError(I);return n},A.find=A.detect=function(e,t,n){var r;return O(e,function(e,i,o){return t.call(n,e,i,o)?(r=e,!0):void 0}),r},A.filter=A.select=function(e,t,n){var r=[];return null==e?r:g&&e.filter===g?e.filter(t,n):(j(e,function(e,i,o){t.call(n,e,i,o)&&(r[r.length]=e)}),r)},A.reject=function(e,t,n){return A.filter(e,function(e,r,i){return!t.call(n,e,r,i)},n)},A.every=A.all=function(e,t,n){t||(t=A.identity);var r=!0;return null==e?r:m&&e.every===m?e.every(t,n):(j(e,function(e,o,a){return(r=r&&t.call(n,e,o,a))?void 0:i}),!!r)};var O=A.some=A.any=function(e,t,n){t||(t=A.identity);var r=!1;return null==e?r:b&&e.some===b?e.some(t,n):(j(e,function(e,o,a){return r||(r=t.call(n,e,o,a))?i:void 0}),!!r)};A.contains=A.include=function(e,t){return null==e?!1:w&&e.indexOf===w?-1!=e.indexOf(t):O(e,function(e){return e===t})},A.invoke=function(e,t){var n=c.call(arguments,2),r=A.isFunction(t);return A.map(e,function(e){return(r?t:e[t]).apply(e,n)})},A.pluck=function(e,t){return A.map(e,function(e){return e[t]})},A.where=function(e,t,n){return A.isEmpty(t)?n?null:[]:A[n?"find":"filter"](e,function(e){for(var n in t)if(t[n]!==e[n])return!1;return!0})},A.findWhere=function(e,t){return A.where(e,t,!0)},A.max=function(e,t,n){if(!t&&A.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.max.apply(Math,e);if(!t&&A.isEmpty(e))return-1/0;var r={computed:-1/0,value:-1/0};return j(e,function(e,i,o){var a=t?t.call(n,e,i,o):e;a>=r.computed&&(r={value:e,computed:a})}),r.value},A.min=function(e,t,n){if(!t&&A.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.min.apply(Math,e);if(!t&&A.isEmpty(e))return 1/0;var r={computed:1/0,value:1/0};return j(e,function(e,i,o){var a=t?t.call(n,e,i,o):e;a<r.computed&&(r={value:e,computed:a})}),r.value},A.shuffle=function(e){var t,n=0,r=[];return j(e,function(e){t=A.random(n++),r[n-1]=r[t],r[t]=e}),r};var S=function(e){return A.isFunction(e)?e:function(t){return t[e]}};A.sortBy=function(e,t,n){var r=S(t);return A.pluck(A.map(e,function(e,t,i){return{value:e,index:t,criteria:r.call(n,e,t,i)}}).sort(function(e,t){var n=e.criteria,r=t.criteria;if(n!==r){if(n>r||void 0===n)return 1;if(r>n||void 0===r)return-1}return e.index<t.index?-1:1}),"value")};var $=function(e,t,n,r){var i={},o=S(t||A.identity);return j(e,function(t,a){var u=o.call(n,t,a,e);r(i,u,t)}),i};A.groupBy=function(e,t,n){return $(e,t,n,function(e,t,n){(A.has(e,t)?e[t]:e[t]=[]).push(n)})},A.countBy=function(e,t,n){return $(e,t,n,function(e,t){A.has(e,t)||(e[t]=0),e[t]++})},A.sortedIndex=function(e,t,n,r){n=null==n?A.identity:S(n);for(var i=n.call(r,t),o=0,a=e.length;a>o;){var u=o+a>>>1;n.call(r,e[u])<i?o=u+1:a=u}return o},A.toArray=function(e){return e?A.isArray(e)?c.call(e):e.length===+e.length?A.map(e,A.identity):A.values(e):[]},A.size=function(e){return null==e?0:e.length===+e.length?e.length:A.keys(e).length},A.first=A.head=A.take=function(e,t,n){return null==e?void 0:null==t||n?e[0]:c.call(e,0,t)},A.initial=function(e,t,n){return c.call(e,0,e.length-(null==t||n?1:t))},A.last=function(e,t,n){return null==e?void 0:null==t||n?e[e.length-1]:c.call(e,Math.max(e.length-t,0))},A.rest=A.tail=A.drop=function(e,t,n){return c.call(e,null==t||n?1:t)
-},A.compact=function(e){return A.filter(e,A.identity)};var N=function(e,t,n){return j(e,function(e){A.isArray(e)?t?s.apply(n,e):N(e,t,n):n.push(e)}),n};A.flatten=function(e,t){return N(e,t,[])},A.without=function(e){return A.difference(e,c.call(arguments,1))},A.uniq=A.unique=function(e,t,n,r){A.isFunction(t)&&(r=n,n=t,t=!1);var i=n?A.map(e,n,r):e,o=[],a=[];return j(i,function(n,r){(t?r&&a[a.length-1]===n:A.contains(a,n))||(a.push(n),o.push(e[r]))}),o},A.union=function(){return A.uniq(f.apply(o,arguments))},A.intersection=function(e){var t=c.call(arguments,1);return A.filter(A.uniq(e),function(e){return A.every(t,function(t){return A.indexOf(t,e)>=0})})},A.difference=function(e){var t=f.apply(o,c.call(arguments,1));return A.filter(e,function(e){return!A.contains(t,e)})},A.zip=function(){for(var e=c.call(arguments),t=A.max(A.pluck(e,"length")),n=new Array(t),r=0;t>r;r++)n[r]=A.pluck(e,""+r);return n},A.object=function(e,t){if(null==e)return{};for(var n={},r=0,i=e.length;i>r;r++)t?n[e[r]]=t[r]:n[e[r][0]]=e[r][1];return n},A.indexOf=function(e,t,n){if(null==e)return-1;var r=0,i=e.length;if(n){if("number"!=typeof n)return r=A.sortedIndex(e,t),e[r]===t?r:-1;r=0>n?Math.max(0,i+n):n}if(w&&e.indexOf===w)return e.indexOf(t,n);for(;i>r;r++)if(e[r]===t)return r;return-1},A.lastIndexOf=function(e,t,n){if(null==e)return-1;var r=null!=n;if(_&&e.lastIndexOf===_)return r?e.lastIndexOf(t,n):e.lastIndexOf(t);for(var i=r?n:e.length;i--;)if(e[i]===t)return i;return-1},A.range=function(e,t,n){arguments.length<=1&&(t=e||0,e=0),n=arguments[2]||1;for(var r=Math.max(Math.ceil((t-e)/n),0),i=0,o=new Array(r);r>i;)o[i++]=e,e+=n;return o},A.bind=function(e,t){if(e.bind===E&&E)return E.apply(e,c.call(arguments,1));var n=c.call(arguments,2);return function(){return e.apply(t,n.concat(c.call(arguments)))}},A.partial=function(e){var t=c.call(arguments,1);return function(){return e.apply(this,t.concat(c.call(arguments)))}},A.bindAll=function(e){var t=c.call(arguments,1);return 0===t.length&&(t=A.functions(e)),j(t,function(t){e[t]=A.bind(e[t],e)}),e},A.memoize=function(e,t){var n={};return t||(t=A.identity),function(){var r=t.apply(this,arguments);return A.has(n,r)?n[r]:n[r]=e.apply(this,arguments)}},A.delay=function(e,t){var n=c.call(arguments,2);return setTimeout(function(){return e.apply(null,n)},t)},A.defer=function(e){return A.delay.apply(A,[e,1].concat(c.call(arguments,1)))},A.throttle=function(e,t){var n,r,i,o,a=0,u=function(){a=new Date,i=null,o=e.apply(n,r)};return function(){var s=new Date,c=t-(s-a);return n=this,r=arguments,0>=c?(clearTimeout(i),i=null,a=s,o=e.apply(n,r)):i||(i=setTimeout(u,c)),o}},A.debounce=function(e,t,n){var r,i;return function(){var o=this,a=arguments,u=function(){r=null,n||(i=e.apply(o,a))},s=n&&!r;return clearTimeout(r),r=setTimeout(u,t),s&&(i=e.apply(o,a)),i}},A.once=function(e){var t,n=!1;return function(){return n?t:(n=!0,t=e.apply(this,arguments),e=null,t)}},A.wrap=function(e,t){return function(){var n=[e];return s.apply(n,arguments),t.apply(this,n)}},A.compose=function(){var e=arguments;return function(){for(var t=arguments,n=e.length-1;n>=0;n--)t=[e[n].apply(this,t)];return t[0]}},A.after=function(e,t){return 0>=e?t():function(){return--e<1?t.apply(this,arguments):void 0}},A.keys=x||function(e){if(e!==Object(e))throw new TypeError("Invalid object");var t=[];for(var n in e)A.has(e,n)&&(t[t.length]=n);return t},A.values=function(e){var t=[];for(var n in e)A.has(e,n)&&t.push(e[n]);return t},A.pairs=function(e){var t=[];for(var n in e)A.has(e,n)&&t.push([n,e[n]]);return t},A.invert=function(e){var t={};for(var n in e)A.has(e,n)&&(t[e[n]]=n);return t},A.functions=A.methods=function(e){var t=[];for(var n in e)A.isFunction(e[n])&&t.push(n);return t.sort()},A.extend=function(e){return j(c.call(arguments,1),function(t){if(t)for(var n in t)e[n]=t[n]}),e},A.pick=function(e){var t={},n=f.apply(o,c.call(arguments,1));return j(n,function(n){n in e&&(t[n]=e[n])}),t},A.omit=function(e){var t={},n=f.apply(o,c.call(arguments,1));for(var r in e)A.contains(n,r)||(t[r]=e[r]);return t},A.defaults=function(e){return j(c.call(arguments,1),function(t){if(t)for(var n in t)null==e[n]&&(e[n]=t[n])}),e},A.clone=function(e){return A.isObject(e)?A.isArray(e)?e.slice():A.extend({},e):e},A.tap=function(e,t){return t(e),e};var D=function(e,t,n,r){if(e===t)return 0!==e||1/e==1/t;if(null==e||null==t)return e===t;e instanceof A&&(e=e._wrapped),t instanceof A&&(t=t._wrapped);var i=l.call(e);if(i!=l.call(t))return!1;switch(i){case"[object String]":return e==String(t);case"[object Number]":return e!=+e?t!=+t:0==e?1/e==1/t:e==+t;case"[object Date]":case"[object Boolean]":return+e==+t;case"[object RegExp]":return e.source==t.source&&e.global==t.global&&e.multiline==t.multiline&&e.ignoreCase==t.ignoreCase}if("object"!=typeof e||"object"!=typeof t)return!1;for(var o=n.length;o--;)if(n[o]==e)return r[o]==t;n.push(e),r.push(t);var a=0,u=!0;if("[object Array]"==i){if(a=e.length,u=a==t.length)for(;a--&&(u=D(e[a],t[a],n,r)););}else{var s=e.constructor,c=t.constructor;if(s!==c&&!(A.isFunction(s)&&s instanceof s&&A.isFunction(c)&&c instanceof c))return!1;for(var f in e)if(A.has(e,f)&&(a++,!(u=A.has(t,f)&&D(e[f],t[f],n,r))))break;if(u){for(f in t)if(A.has(t,f)&&!a--)break;u=!a}}return n.pop(),r.pop(),u};A.isEqual=function(e,t){return D(e,t,[],[])},A.isEmpty=function(e){if(null==e)return!0;if(A.isArray(e)||A.isString(e))return 0===e.length;for(var t in e)if(A.has(e,t))return!1;return!0},A.isElement=function(e){return!(!e||1!==e.nodeType)},A.isArray=k||function(e){return"[object Array]"==l.call(e)},A.isObject=function(e){return e===Object(e)},j(["Arguments","Function","String","Number","Date","RegExp"],function(e){A["is"+e]=function(t){return l.call(t)=="[object "+e+"]"}}),A.isArguments(arguments)||(A.isArguments=function(e){return!(!e||!A.has(e,"callee"))}),"function"!=typeof/./&&(A.isFunction=function(e){return"function"==typeof e}),A.isFinite=function(e){return isFinite(e)&&!isNaN(parseFloat(e))},A.isNaN=function(e){return A.isNumber(e)&&e!=+e},A.isBoolean=function(e){return e===!0||e===!1||"[object Boolean]"==l.call(e)},A.isNull=function(e){return null===e},A.isUndefined=function(e){return void 0===e},A.has=function(e,t){return h.call(e,t)},A.noConflict=function(){return e._=r,this},A.identity=function(e){return e},A.times=function(e,t,n){for(var r=Array(e),i=0;e>i;i++)r[i]=t.call(n,i);return r},A.random=function(e,t){return null==t&&(t=e,e=0),e+Math.floor(Math.random()*(t-e+1))};var T={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};T.unescape=A.invert(T.escape);var C={escape:new RegExp("["+A.keys(T.escape).join("")+"]","g"),unescape:new RegExp("("+A.keys(T.unescape).join("|")+")","g")};A.each(["escape","unescape"],function(e){A[e]=function(t){return null==t?"":(""+t).replace(C[e],function(t){return T[e][t]})}}),A.result=function(e,t){if(null==e)return null;var n=e[t];return A.isFunction(n)?n.call(e):n},A.mixin=function(e){j(A.functions(e),function(t){var n=A[t]=e[t];A.prototype[t]=function(){var e=[this._wrapped];return s.apply(e,arguments),B.call(this,n.apply(A,e))}})};var M=0;A.uniqueId=function(e){var t=++M+"";return e?e+t:t},A.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var F=/(.)^/,R={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},P=/\\|'|\r|\n|\t|\u2028|\u2029/g;A.template=function(e,t,n){var r;n=A.defaults({},n,A.templateSettings);var i=new RegExp([(n.escape||F).source,(n.interpolate||F).source,(n.evaluate||F).source].join("|")+"|$","g"),o=0,a="__p+='";e.replace(i,function(t,n,r,i,u){return a+=e.slice(o,u).replace(P,function(e){return"\\"+R[e]}),n&&(a+="'+\n((__t=("+n+"))==null?'':_.escape(__t))+\n'"),r&&(a+="'+\n((__t=("+r+"))==null?'':__t)+\n'"),i&&(a+="';\n"+i+"\n__p+='"),o=u+t.length,t}),a+="';\n",n.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{r=new Function(n.variable||"obj","_",a)}catch(u){throw u.source=a,u}if(t)return r(t,A);var s=function(e){return r.call(this,e,A)};return s.source="function("+(n.variable||"obj")+"){\n"+a+"}",s},A.chain=function(e){return A(e).chain()};var B=function(e){return this._chain?A(e).chain():e};A.mixin(A),j(["pop","push","reverse","shift","sort","splice","unshift"],function(e){var t=o[e];A.prototype[e]=function(){var n=this._wrapped;return t.apply(n,arguments),"shift"!=e&&"splice"!=e||0!==n.length||delete n[0],B.call(this,n)}}),j(["concat","join","slice"],function(e){var t=o[e];A.prototype[e]=function(){return B.call(this,t.apply(this._wrapped,arguments))}}),A.extend(A.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}.call(this)},{}]},{},[7])(7)});
\ No newline at end of file
+!function(t){if("function"==typeof bootstrap)bootstrap("nedb",t);else if("object"==typeof exports)module.exports=t();else if("function"==typeof define&&define.amd)define(t);else if("undefined"!=typeof ses){if(!ses.ok())return;ses.makeNedb=t}else"undefined"!=typeof window?window.Nedb=t():global.Nedb=t()}(function(){var t;return function(t,e,n){function r(n,o){if(!e[n]){if(!t[n]){var a="function"==typeof require&&require;if(!o&&a)return a(n,!0);if(i)return i(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=e[n]={exports:{}};t[n][0].call(u.exports,function(e){var i=t[n][1][e];return r(i?i:e)},u,u.exports)}return e[n].exports}for(var i="function"==typeof require&&require,o=0;o<n.length;o++)r(n[o]);return r}({1:[function(t,e,n){function r(t,e){if(t.indexOf)return t.indexOf(e);for(var n=0;n<t.length;n++)if(e===t[n])return n;return-1}var i=t("__browserify_process");i.EventEmitter||(i.EventEmitter=function(){});var o=n.EventEmitter=i.EventEmitter,a="function"==typeof Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)},u=10;o.prototype.setMaxListeners=function(t){this._events||(this._events={}),this._events.maxListeners=t},o.prototype.emit=function(t){if("error"===t&&(!this._events||!this._events.error||a(this._events.error)&&!this._events.error.length))throw arguments[1]instanceof Error?arguments[1]:new Error("Uncaught, unspecified 'error' event.");if(!this._events)return!1;var e=this._events[t];if(!e)return!1;if("function"==typeof e){switch(arguments.length){case 1:e.call(this);break;case 2:e.call(this,arguments[1]);break;case 3:e.call(this,arguments[1],arguments[2]);break;default:var n=Array.prototype.slice.call(arguments,1);e.apply(this,n)}return!0}if(a(e)){for(var n=Array.prototype.slice.call(arguments,1),r=e.slice(),i=0,o=r.length;o>i;i++)r[i].apply(this,n);return!0}return!1},o.prototype.addListener=function(t,e){if("function"!=typeof e)throw new Error("addListener only takes instances of Function");if(this._events||(this._events={}),this.emit("newListener",t,e),this._events[t])if(a(this._events[t])){if(!this._events[t].warned){var n;n=void 0!==this._events.maxListeners?this._events.maxListeners:u,n&&n>0&&this._events[t].length>n&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),console.trace())}this._events[t].push(e)}else this._events[t]=[this._events[t],e];else this._events[t]=e;return this},o.prototype.on=o.prototype.addListener,o.prototype.once=function(t,e){var n=this;return n.on(t,function r(){n.removeListener(t,r),e.apply(this,arguments)}),this},o.prototype.removeListener=function(t,e){if("function"!=typeof e)throw new Error("removeListener only takes instances of Function");if(!this._events||!this._events[t])return this;var n=this._events[t];if(a(n)){var i=r(n,e);if(0>i)return this;n.splice(i,1),0==n.length&&delete this._events[t]}else this._events[t]===e&&delete this._events[t];return this},o.prototype.removeAllListeners=function(t){return 0===arguments.length?(this._events={},this):(t&&this._events&&this._events[t]&&(this._events[t]=null),this)},o.prototype.listeners=function(t){return this._events||(this._events={}),this._events[t]||(this._events[t]=[]),a(this._events[t])||(this._events[t]=[this._events[t]]),this._events[t]},o.listenerCount=function(t,e){var n;return n=t._events&&t._events[e]?"function"==typeof t._events[e]?1:t._events[e].length:0}},{__browserify_process:4}],2:[function(t,e,n){function r(t,e){for(var n=[],r=0;r<t.length;r++)e(t[r],r,t)&&n.push(t[r]);return n}function i(t,e){for(var n=0,r=t.length;r>=0;r--){var i=t[r];"."==i?t.splice(r,1):".."===i?(t.splice(r,1),n++):n&&(t.splice(r,1),n--)}if(e)for(;n--;n)t.unshift("..");return t}var o=t("__browserify_process"),a=/^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;n.resolve=function(){for(var t="",e=!1,n=arguments.length;n>=-1&&!e;n--){var a=n>=0?arguments[n]:o.cwd();"string"==typeof a&&a&&(t=a+"/"+t,e="/"===a.charAt(0))}return t=i(r(t.split("/"),function(t){return!!t}),!e).join("/"),(e?"/":"")+t||"."},n.normalize=function(t){var e="/"===t.charAt(0),n="/"===t.slice(-1);return t=i(r(t.split("/"),function(t){return!!t}),!e).join("/"),t||e||(t="."),t&&n&&(t+="/"),(e?"/":"")+t},n.join=function(){var t=Array.prototype.slice.call(arguments,0);return n.normalize(r(t,function(t){return t&&"string"==typeof t}).join("/"))},n.dirname=function(t){var e=a.exec(t)[1]||"",n=!1;return e?1===e.length||n&&e.length<=3&&":"===e.charAt(1)?e:e.substring(0,e.length-1):"."},n.basename=function(t,e){var n=a.exec(t)[2]||"";return e&&n.substr(-1*e.length)===e&&(n=n.substr(0,n.length-e.length)),n},n.extname=function(t){return a.exec(t)[3]||""},n.relative=function(t,e){function r(t){for(var e=0;e<t.length&&""===t[e];e++);for(var n=t.length-1;n>=0&&""===t[n];n--);return e>n?[]:t.slice(e,n-e+1)}t=n.resolve(t).substr(1),e=n.resolve(e).substr(1);for(var i=r(t.split("/")),o=r(e.split("/")),a=Math.min(i.length,o.length),u=a,s=0;a>s;s++)if(i[s]!==o[s]){u=s;break}for(var c=[],s=u;s<i.length;s++)c.push("..");return c=c.concat(o.slice(u)),c.join("/")},n.sep="/"},{__browserify_process:4}],3:[function(t,e,n){function r(t){return Array.isArray(t)||"object"==typeof t&&"[object Array]"===Object.prototype.toString.call(t)}function i(t){"object"==typeof t&&"[object RegExp]"===Object.prototype.toString.call(t)}function o(t){return"object"==typeof t&&"[object Date]"===Object.prototype.toString.call(t)}t("events"),n.isArray=r,n.isDate=function(t){return"[object Date]"===Object.prototype.toString.call(t)},n.isRegExp=function(t){return"[object RegExp]"===Object.prototype.toString.call(t)},n.print=function(){},n.puts=function(){},n.debug=function(){},n.inspect=function(t,e,s,c){function f(t,s){if(t&&"function"==typeof t.inspect&&t!==n&&(!t.constructor||t.constructor.prototype!==t))return t.inspect(s);switch(typeof t){case"undefined":return h("undefined","undefined");case"string":var c="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return h(c,"string");case"number":return h(""+t,"number");case"boolean":return h(""+t,"boolean")}if(null===t)return h("null","null");var p=a(t),d=e?u(t):p;if("function"==typeof t&&0===d.length){if(i(t))return h(""+t,"regexp");var y=t.name?": "+t.name:"";return h("[Function"+y+"]","special")}if(o(t)&&0===d.length)return h(t.toUTCString(),"date");var v,g,m;if(r(t)?(g="Array",m=["[","]"]):(g="Object",m=["{","}"]),"function"==typeof t){var b=t.name?": "+t.name:"";v=i(t)?" "+t:" [Function"+b+"]"}else v="";if(o(t)&&(v=" "+t.toUTCString()),0===d.length)return m[0]+v+m[1];if(0>s)return i(t)?h(""+t,"regexp"):h("[Object]","special");l.push(t);var w=d.map(function(e){var n,i;if(t.__lookupGetter__&&(t.__lookupGetter__(e)?i=t.__lookupSetter__(e)?h("[Getter/Setter]","special"):h("[Getter]","special"):t.__lookupSetter__(e)&&(i=h("[Setter]","special"))),p.indexOf(e)<0&&(n="["+e+"]"),i||(l.indexOf(t[e])<0?(i=null===s?f(t[e]):f(t[e],s-1),i.indexOf("\n")>-1&&(i=r(t)?i.split("\n").map(function(t){return"  "+t}).join("\n").substr(2):"\n"+i.split("\n").map(function(t){return"   "+t}).join("\n"))):i=h("[Circular]","special")),"undefined"==typeof n){if("Array"===g&&e.match(/^\d+$/))return i;n=JSON.stringify(""+e),n.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(n=n.substr(1,n.length-2),n=h(n,"name")):(n=n.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),n=h(n,"string"))}return n+": "+i});l.pop();var _=0,k=w.reduce(function(t,e){return _++,e.indexOf("\n")>=0&&_++,t+e.length+1},0);return w=k>50?m[0]+(""===v?"":v+"\n ")+" "+w.join(",\n  ")+" "+m[1]:m[0]+v+" "+w.join(", ")+" "+m[1]}var l=[],h=function(t,e){var n={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},r={special:"cyan",number:"blue","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"}[e];return r?"["+n[r][0]+"m"+t+"["+n[r][1]+"m":t};return c||(h=function(t){return t}),f(t,"undefined"==typeof s?2:s)},n.log=function(){},n.pump=null;var a=Object.keys||function(t){var e=[];for(var n in t)e.push(n);return e},u=Object.getOwnPropertyNames||function(t){var e=[];for(var n in t)Object.hasOwnProperty.call(t,n)&&e.push(n);return e},s=Object.create||function(t,e){var n;if(null===t)n={__proto__:null};else{if("object"!=typeof t)throw new TypeError("typeof prototype["+typeof t+"] != 'object'");var r=function(){};r.prototype=t,n=new r,n.__proto__=t}return"undefined"!=typeof e&&Object.defineProperties&&Object.defineProperties(n,e),n};n.inherits=function(t,e){t.super_=e,t.prototype=s(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})};var c=/%[sdj%]/g;n.format=function(t){if("string"!=typeof t){for(var e=[],r=0;r<arguments.length;r++)e.push(n.inspect(arguments[r]));return e.join(" ")}for(var r=1,i=arguments,o=i.length,a=String(t).replace(c,function(t){if("%%"===t)return"%";if(r>=o)return t;switch(t){case"%s":return String(i[r++]);case"%d":return Number(i[r++]);case"%j":return JSON.stringify(i[r++]);default:return t}}),u=i[r];o>r;u=i[++r])a+=null===u||"object"!=typeof u?" "+u:" "+n.inspect(u);return a}},{events:1}],4:[function(t,e){var n=e.exports={};n.nextTick=function(){var t="undefined"!=typeof window&&window.setImmediate,e="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(t)return function(t){return window.setImmediate(t)};if(e){var n=[];return window.addEventListener("message",function(t){var e=t.source;if((e===window||null===e)&&"process-tick"===t.data&&(t.stopPropagation(),n.length>0)){var r=n.shift();r()}},!0),function(t){n.push(t),window.postMessage("process-tick","*")}}return function(t){setTimeout(t,0)}}(),n.title="browser",n.browser=!0,n.env={},n.argv=[],n.binding=function(){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(){throw new Error("process.chdir is not supported")}},{}],5:[function(t,e){function n(t,e,n){this.db=t,this.query=e||{},n&&(this.execFn=n)}var r=t("./model"),i=t("underscore");n.prototype.limit=function(t){return this._limit=t,this},n.prototype.skip=function(t){return this._skip=t,this},n.prototype.sort=function(t){return this._sort=t,this},n.prototype.projection=function(t){return this._projection=t,this},n.prototype.project=function(t){var e,n,r,o=[],a=this;return void 0===this._projection||0===Object.keys(this._projection).length?t:(e=0===this._projection._id?!1:!0,this._projection=i.omit(this._projection,"_id"),r=Object.keys(this._projection),r.forEach(function(t){if(void 0!==n&&a._projection[t]!==n)throw new Error("Can't both keep and omit fields except for _id");n=a._projection[t]}),t.forEach(function(t){var a=1===n?i.pick(t,r):i.omit(t,r);e?a._id=t._id:delete a._id,o.push(a)}),o)},n.prototype._exec=function(t){var e,n,i,o=this.db.getCandidates(this.query),a=[],u=0,s=0,c=this,f=null;try{for(e=0;e<o.length;e+=1)if(r.match(o[e],this.query))if(this._sort)a.push(o[e]);else if(this._skip&&this._skip>s)s+=1;else if(a.push(o[e]),u+=1,this._limit&&this._limit<=u)break}catch(l){return t(l)}if(this._sort){n=Object.keys(this._sort);var h=[];for(e=0;e<n.length;e++)i=n[e],h.push({key:i,direction:c._sort[i]});a.sort(function(t,e){var n,i,o;for(o=0;o<h.length;o++)if(n=h[o],i=n.direction*r.compareThings(r.getDotValue(t,n.key),r.getDotValue(e,n.key)),0!==i)return i;return 0});var p=this._limit||a.length,d=this._skip||0;a=a.slice(d,d+p)}try{a=this.project(a)}catch(y){f=y,a=void 0}return this.execFn?this.execFn(f,a,t):t(f,a)},n.prototype.exec=function(){this.db.executor.push({"this":this,fn:this._exec,arguments:arguments})},e.exports=n},{"./model":10,underscore:19}],6:[function(t,e){function n(t){for(var e,e,n=new Array(t),r=0;t>r;r++)0==(3&r)&&(e=4294967296*Math.random()),n[r]=255&e>>>((3&r)<<3);return n}function r(t){function e(t){return o[63&t>>18]+o[63&t>>12]+o[63&t>>6]+o[63&t]}var n,r,i,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=t.length%3,u="";for(i=0,r=t.length-a;r>i;i+=3)n=(t[i]<<16)+(t[i+1]<<8)+t[i+2],u+=e(n);switch(a){case 1:n=t[t.length-1],u+=o[n>>2],u+=o[63&n<<4],u+="==";break;case 2:n=(t[t.length-2]<<8)+t[t.length-1],u+=o[n>>10],u+=o[63&n>>4],u+=o[63&n<<2],u+="="}return u}function i(t){return r(n(Math.ceil(Math.max(8,2*t)))).replace(/[+\/]/g,"").slice(0,t)}e.exports.uid=i},{}],7:[function(t,e){function n(t){var e;"string"==typeof t?(e=t,this.inMemoryOnly=!1):(t=t||{},e=t.filename,this.inMemoryOnly=t.inMemoryOnly||!1,this.autoload=t.autoload||!1,this.timestampData=t.timestampData||!1),e&&"string"==typeof e&&0!==e.length?this.filename=e:(this.filename=null,this.inMemoryOnly=!0),this.persistence=new f({db:this,nodeWebkitAppName:t.nodeWebkitAppName,afterSerialization:t.afterSerialization,beforeDeserialization:t.beforeDeserialization,corruptAlertThreshold:t.corruptAlertThreshold}),this.executor=new a,this.inMemoryOnly&&(this.executor.ready=!0),this.indexes={},this.indexes._id=new u({fieldName:"_id",unique:!0}),this.autoload&&this.loadDatabase(t.onload||function(t){if(t)throw t})}var r=t("./customUtils"),i=t("./model"),o=t("async"),a=t("./executor"),u=t("./indexes"),s=t("util"),c=t("underscore"),f=t("./persistence"),l=t("./cursor");n.prototype.loadDatabase=function(){this.executor.push({"this":this.persistence,fn:this.persistence.loadDatabase,arguments:arguments},!0)},n.prototype.getAllData=function(){return this.indexes._id.getAll()},n.prototype.resetIndexes=function(t){var e=this;Object.keys(this.indexes).forEach(function(n){e.indexes[n].reset(t)})},n.prototype.ensureIndex=function(t,e){var n,r=e||function(){};if(t=t||{},!t.fieldName)return n=new Error("Cannot create an index without a fieldName"),n.missingFieldName=!0,r(n);if(this.indexes[t.fieldName])return r(null);this.indexes[t.fieldName]=new u(t);try{this.indexes[t.fieldName].insert(this.getAllData())}catch(i){return delete this.indexes[t.fieldName],r(i)}this.persistence.persistNewState([{$$indexCreated:t}],function(t){return t?r(t):r(null)})},n.prototype.removeIndex=function(t,e){var n=e||function(){};delete this.indexes[t],this.persistence.persistNewState([{$$indexRemoved:t}],function(t){return t?n(t):n(null)})},n.prototype.addToIndexes=function(t){var e,n,r,i=Object.keys(this.indexes);for(e=0;e<i.length;e+=1)try{this.indexes[i[e]].insert(t)}catch(o){n=e,r=o;break}if(r){for(e=0;n>e;e+=1)this.indexes[i[e]].remove(t);throw r}},n.prototype.removeFromIndexes=function(t){var e=this;Object.keys(this.indexes).forEach(function(n){e.indexes[n].remove(t)})},n.prototype.updateIndexes=function(t,e){var n,r,i,o=Object.keys(this.indexes);for(n=0;n<o.length;n+=1)try{this.indexes[o[n]].update(t,e)}catch(a){r=n,i=a;break}if(i){for(n=0;r>n;n+=1)this.indexes[o[n]].revertUpdate(t,e);throw i}},n.prototype.getCandidates=function(t){var e,n=Object.keys(this.indexes);return e=[],Object.keys(t).forEach(function(n){("string"==typeof t[n]||"number"==typeof t[n]||"boolean"==typeof t[n]||s.isDate(t[n])||null===t[n])&&e.push(n)}),e=c.intersection(e,n),e.length>0?this.indexes[e[0]].getMatching(t[e[0]]):(e=[],Object.keys(t).forEach(function(n){t[n]&&t[n].hasOwnProperty("$in")&&e.push(n)}),e=c.intersection(e,n),e.length>0?this.indexes[e[0]].getMatching(t[e[0]].$in):(e=[],Object.keys(t).forEach(function(n){t[n]&&(t[n].hasOwnProperty("$lt")||t[n].hasOwnProperty("$lte")||t[n].hasOwnProperty("$gt")||t[n].hasOwnProperty("$gte"))&&e.push(n)}),e=c.intersection(e,n),e.length>0?this.indexes[e[0]].getBetweenBounds(t[e[0]]):this.getAllData()))},n.prototype._insert=function(t,e){var n,r=e||function(){};try{n=this.prepareDocumentForInsertion(t),this._insertInCache(n)}catch(o){return r(o)}this.persistence.persistNewState(s.isArray(n)?n:[n],function(t){return t?r(t):r(null,i.deepCopy(n))})},n.prototype.createNewId=function(){var t=r.uid(16);return this.indexes._id.getMatching(t).length>0&&(t=this.createNewId()),t},n.prototype.prepareDocumentForInsertion=function(t){var e,n=this;if(s.isArray(t))e=[],t.forEach(function(t){e.push(n.prepareDocumentForInsertion(t))});else{e=i.deepCopy(t),void 0===e._id&&(e._id=this.createNewId());var r=new Date;this.timestampData&&void 0===e.createdAt&&(e.createdAt=r),this.timestampData&&void 0===e.updatedAt&&(e.updatedAt=r),i.checkObject(e)}return e},n.prototype._insertInCache=function(t){s.isArray(t)?this._insertMultipleDocsInCache(t):this.addToIndexes(t)},n.prototype._insertMultipleDocsInCache=function(t){var e,n,r;for(e=0;e<t.length;e+=1)try{this.addToIndexes(t[e])}catch(i){r=i,n=e;break}if(r){for(e=0;n>e;e+=1)this.removeFromIndexes(t[e]);throw r}},n.prototype.insert=function(){this.executor.push({"this":this,fn:this._insert,arguments:arguments})},n.prototype.count=function(t,e){var n=new l(this,t,function(t,e,n){return t?n(t):n(null,e.length)});return"function"!=typeof e?n:(n.exec(e),void 0)},n.prototype.find=function(t,e,n){switch(arguments.length){case 1:e={};break;case 2:"function"==typeof e&&(n=e,e={})}var r=new l(this,t,function(t,e,n){var r,o=[];if(t)return n(t);for(r=0;r<e.length;r+=1)o.push(i.deepCopy(e[r]));return n(null,o)});return r.projection(e),"function"!=typeof n?r:(r.exec(n),void 0)},n.prototype.findOne=function(t,e,n){switch(arguments.length){case 1:e={};break;case 2:"function"==typeof e&&(n=e,e={})}var r=new l(this,t,function(t,e,n){return t?n(t):1===e.length?n(null,i.deepCopy(e[0])):n(null,null)});return r.projection(e).limit(1),"function"!=typeof n?r:(r.exec(n),void 0)},n.prototype._update=function(t,e,n,r){var a,u,s,f,h=this,p=0;"function"==typeof n&&(r=n,n={}),a=r||function(){},u=void 0!==n.multi?n.multi:!1,s=void 0!==n.upsert?n.upsert:!1,o.waterfall([function(n){if(!s)return n();var r=new l(h,t);r.limit(1)._exec(function(r,o){if(r)return a(r);if(1===o.length)return n();var u;try{i.checkObject(e),u=e}catch(s){try{u=i.modify(i.deepCopy(t,!0),e)}catch(r){return a(r)}}return h._insert(u,function(t,e){return t?a(t):a(null,1,e)})})},function(){var r,o=h.getCandidates(t),s=[];try{for(f=0;f<o.length;f+=1)i.match(o[f],t)&&(u||0===p)&&(p+=1,r=i.modify(o[f],e),h.timestampData&&(r.updatedAt=new Date),s.push({oldDoc:o[f],newDoc:r}))}catch(l){return a(l)}try{h.updateIndexes(s)}catch(l){return a(l)}var d=c.pluck(s,"newDoc");h.persistence.persistNewState(d,function(t){if(t)return a(t);if(n.returnUpdatedDocs){var e=[];return d.forEach(function(t){e.push(i.deepCopy(t))}),a(null,p,e)}return a(null,p)})}])},n.prototype.update=function(){this.executor.push({"this":this,fn:this._update,arguments:arguments})},n.prototype._remove=function(t,e,n){var r,o,a=this,u=0,s=[],c=this.getCandidates(t);"function"==typeof e&&(n=e,e={}),r=n||function(){},o=void 0!==e.multi?e.multi:!1;try{c.forEach(function(e){i.match(e,t)&&(o||0===u)&&(u+=1,s.push({$$deleted:!0,_id:e._id}),a.removeFromIndexes(e))})}catch(f){return r(f)}a.persistence.persistNewState(s,function(t){return t?r(t):r(null,u)})},n.prototype.remove=function(){this.executor.push({"this":this,fn:this._remove,arguments:arguments})},e.exports=n},{"./cursor":5,"./customUtils":6,"./executor":8,"./indexes":9,"./model":10,"./persistence":11,async:13,underscore:19,util:3}],8:[function(t,e){function n(){this.buffer=[],this.ready=!1,this.queue=i.queue(function(t,e){var n,i,o=t.arguments[t.arguments.length-1],a=[];for(i=0;i<t.arguments.length;i+=1)a.push(t.arguments[i]);"function"==typeof o?(n=function(){"function"==typeof setImmediate?setImmediate(e):r.nextTick(e),o.apply(null,arguments)},a[a.length-1]=n):(n=function(){e()},a.push(n)),t.fn.apply(t.this,a)},1)}var r=t("__browserify_process"),i=t("async");n.prototype.push=function(t,e){this.ready||e?this.queue.push(t):this.buffer.push(t)},n.prototype.processBuffer=function(){var t;for(this.ready=!0,t=0;t<this.buffer.length;t+=1)this.queue.push(this.buffer[t]);this.buffer=[]},e.exports=n},{__browserify_process:4,async:13}],9:[function(t,e){function n(t,e){return t===e}function r(t){return null===t?"$null":"string"==typeof t?"$string"+t:"boolean"==typeof t?"$boolean"+t:"number"==typeof t?"$number"+t:s.isArray(t)?"$date"+t.getTime():t}function i(t){this.fieldName=t.fieldName,this.unique=t.unique||!1,this.sparse=t.sparse||!1,this.treeOptions={unique:this.unique,compareKeys:a.compareThings,checkValueEquality:n},this.reset()}var o=t("binary-search-tree").AVLTree,a=t("./model"),u=t("underscore"),s=t("util");i.prototype.reset=function(t){this.tree=new o(this.treeOptions),t&&this.insert(t)},i.prototype.insert=function(t){var e,n,i,o,c;if(s.isArray(t))return this.insertMultipleDocs(t),void 0;if(e=a.getDotValue(t,this.fieldName),void 0!==e||!this.sparse)if(s.isArray(e)){for(n=u.uniq(e,r),i=0;i<n.length;i+=1)try{this.tree.insert(n[i],t)}catch(f){c=f,o=i;break}if(c){for(i=0;o>i;i+=1)this.tree.delete(n[i],t);throw c}}else this.tree.insert(e,t)},i.prototype.insertMultipleDocs=function(t){var e,n,r;for(e=0;e<t.length;e+=1)try{this.insert(t[e])}catch(i){n=i,r=e;break}if(n){for(e=0;r>e;e+=1)this.remove(t[e]);throw n}},i.prototype.remove=function(t){var e,n=this;return s.isArray(t)?(t.forEach(function(t){n.remove(t)}),void 0):(e=a.getDotValue(t,this.fieldName),void 0===e&&this.sparse||(s.isArray(e)?u.uniq(e,r).forEach(function(e){n.tree.delete(e,t)}):this.tree.delete(e,t)),void 0)},i.prototype.update=function(t,e){if(s.isArray(t))return this.updateMultipleDocs(t),void 0;this.remove(t);try{this.insert(e)}catch(n){throw this.insert(t),n}},i.prototype.updateMultipleDocs=function(t){var e,n,r;for(e=0;e<t.length;e+=1)this.remove(t[e].oldDoc);for(e=0;e<t.length;e+=1)try{this.insert(t[e].newDoc)}catch(i){r=i,n=e;break}if(r){for(e=0;n>e;e+=1)this.remove(t[e].newDoc);for(e=0;e<t.length;e+=1)this.insert(t[e].oldDoc);throw r}},i.prototype.revertUpdate=function(t,e){var n=[];s.isArray(t)?(t.forEach(function(t){n.push({oldDoc:t.newDoc,newDoc:t.oldDoc})}),this.update(n)):this.update(e,t)},i.prototype.getMatching=function(t){var e=this;if(s.isArray(t)){var n={},r=[];return t.forEach(function(t){e.getMatching(t).forEach(function(t){n[t._id]=t})}),Object.keys(n).forEach(function(t){r.push(n[t])}),r}return e.tree.search(t)},i.prototype.getBetweenBounds=function(t){return this.tree.betweenBounds(t)},i.prototype.getAll=function(){var t=[];return this.tree.executeOnEveryNode(function(e){var n;for(n=0;n<e.data.length;n+=1)t.push(e.data[n])}),t},e.exports=i},{"./model":10,"binary-search-tree":14,underscore:19,util:3}],10:[function(t,e){function n(t,e){if("number"==typeof t&&(t=t.toString()),!("$"!==t[0]||"$$date"===t&&"number"==typeof e||"$$deleted"===t&&e===!0||"$$indexCreated"===t||"$$indexRemoved"===t))throw new Error("Field names cannot begin with the $ character");if(-1!==t.indexOf("."))throw new Error("Field names cannot contain a .")}function r(t){m.isArray(t)&&t.forEach(function(t){r(t)}),"object"==typeof t&&null!==t&&Object.keys(t).forEach(function(e){n(e,t[e]),r(t[e])})}function i(t){var e;return e=JSON.stringify(t,function(t,e){return n(t,e),void 0===e?void 0:null===e?null:"function"==typeof this[t].getTime?{$$date:this[t].getTime()}:e})}function o(t){return JSON.parse(t,function(t,e){return"$$date"===t?new Date(e):"string"==typeof e||"number"==typeof e||"boolean"==typeof e||null===e?e:e&&e.$$date?e.$$date:e})}function a(t,e){var n;return"boolean"==typeof t||"number"==typeof t||"string"==typeof t||null===t||m.isDate(t)?t:m.isArray(t)?(n=[],t.forEach(function(t){n.push(a(t,e))}),n):"object"==typeof t?(n={},Object.keys(t).forEach(function(r){(!e||"$"!==r[0]&&-1===r.indexOf("."))&&(n[r]=a(t[r],e))}),n):void 0}function u(t){return"boolean"==typeof t||"number"==typeof t||"string"==typeof t||null===t||m.isDate(t)||m.isArray(t)}function s(t,e){return e>t?-1:t>e?1:0}function c(t,e){var n,r;for(n=0;n<Math.min(t.length,e.length);n+=1)if(r=f(t[n],e[n]),0!==r)return r;return s(t.length,e.length)}function f(t,e){var n,r,i,o;if(void 0===t)return void 0===e?0:-1;if(void 0===e)return void 0===t?0:1;if(null===t)return null===e?0:-1;if(null===e)return null===t?0:1;if("number"==typeof t)return"number"==typeof e?s(t,e):-1;if("number"==typeof e)return"number"==typeof t?s(t,e):1;if("string"==typeof t)return"string"==typeof e?s(t,e):-1;if("string"==typeof e)return"string"==typeof t?s(t,e):1;if("boolean"==typeof t)return"boolean"==typeof e?s(t,e):-1;if("boolean"==typeof e)return"boolean"==typeof t?s(t,e):1;if(m.isDate(t))return m.isDate(e)?s(t.getTime(),e.getTime()):-1;if(m.isDate(e))return m.isDate(t)?s(t.getTime(),e.getTime()):1;if(m.isArray(t))return m.isArray(e)?c(t,e):-1;if(m.isArray(e))return m.isArray(t)?c(t,e):1;for(n=Object.keys(t).sort(),r=Object.keys(e).sort(),o=0;o<Math.min(n.length,r.length);o+=1)if(i=f(t[n[o]],e[r[o]]),0!==i)return i;return s(n.length,r.length)}function l(t){return function(e,n,r){var i="string"==typeof n?n.split("."):n;1===i.length?_[t](e,n,r):(e[i[0]]=e[i[0]]||{},w[t](e[i[0]],i.slice(1),r))}}function h(t,e){var n,i,o=Object.keys(e),u=b.map(o,function(t){return t[0]}),s=b.filter(u,function(t){return"$"===t});if(-1!==o.indexOf("_id")&&e._id!==t._id)throw new Error("You cannot change a document's _id");if(0!==s.length&&s.length!==u.length)throw new Error("You cannot mix modifiers and normal fields");if(0===s.length?(n=a(e),n._id=t._id):(i=b.uniq(o),n=a(t),i.forEach(function(t){var r;if(!w[t])throw new Error("Unknown modifier "+t);if("object"!=typeof e[t])throw new Error("Modifier "+t+"'s argument must be an object");r=Object.keys(e[t]),r.forEach(function(r){w[t](n,r,e[t][r])})})),r(n),t._id!==n._id)throw new Error("You can't change a document's _id");return n}function p(t,e){var n,r,i="string"==typeof e?e.split("."):e;if(!t)return void 0;if(0===i.length)return t;if(1===i.length)return t[i[0]];if(m.isArray(t[i[0]])){if(n=parseInt(i[1],10),"number"==typeof n&&!isNaN(n))return p(t[i[0]][n],i.slice(2));for(r=new Array,n=0;n<t[i[0]].length;n+=1)r.push(p(t[i[0]][n],i.slice(1)));return r}return p(t[i[0]],i.slice(1))}function d(t,e){var n,r,i;if(null===t||"string"==typeof t||"boolean"==typeof t||"number"==typeof t||null===e||"string"==typeof e||"boolean"==typeof e||"number"==typeof e)return t===e;if(m.isDate(t)||m.isDate(e))return m.isDate(t)&&m.isDate(e)&&t.getTime()===e.getTime();if(m.isArray(t)||m.isArray(e)||void 0===t||void 0===e)return!1;try{n=Object.keys(t),r=Object.keys(e)}catch(o){return!1}if(n.length!==r.length)return!1;for(i=0;i<n.length;i+=1){if(-1===r.indexOf(n[i]))return!1;if(!d(t[n[i]],e[n[i]]))return!1}return!0}function y(t,e){return"string"==typeof t||"number"==typeof t||m.isDate(t)||"string"==typeof e||"number"==typeof e||m.isDate(e)?typeof t!=typeof e?!1:!0:!1}function v(t,e){var n,r,i,o;if(u(t)||u(e))return g({needAKey:t},"needAKey",e);for(n=Object.keys(e),o=0;o<n.length;o+=1)if(r=n[o],i=e[r],"$"===r[0]){if(!x[r])throw new Error("Unknown logical operator "+r);if(!x[r](t,i))return!1}else if(!g(t,r,i))return!1;return!0}function g(t,e,n,r){var i,o,a,u,s=p(t,e);if(m.isArray(s)&&!r){if(null!==n&&"object"==typeof n&&!m.isRegExp(n))for(o=Object.keys(n),i=0;i<o.length;i+=1)if(E[o[i]])return g(t,e,n,!0);for(i=0;i<s.length;i+=1)if(g({k:s[i]},"k",n))return!0;return!1}if(null!==n&&"object"==typeof n&&!m.isRegExp(n)){if(o=Object.keys(n),a=b.map(o,function(t){return t[0]}),u=b.filter(a,function(t){return"$"===t}),0!==u.length&&u.length!==a.length)throw new Error("You cannot mix operators and normal fields");if(u.length>0){for(i=0;i<o.length;i+=1){if(!k[o[i]])throw new Error("Unknown comparison function "+o[i]);if(!k[o[i]](s,n[o[i]]))return!1}return!0}}return m.isRegExp(n)?k.$regex(s,n):d(s,n)?!0:!1}var m=t("util"),b=t("underscore"),w={},_={},k={},x={},E={};_.$set=function(t,e,n){t[e]=n},_.$unset=function(t,e){delete t[e]},_.$push=function(t,e,n){if(t.hasOwnProperty(e)||(t[e]=[]),!m.isArray(t[e]))throw new Error("Can't $push an element on non-array values");if(null!==n&&"object"==typeof n&&n.$each){if(Object.keys(n).length>1)throw new Error("Can't use another field in conjunction with $each");if(!m.isArray(n.$each))throw new Error("$each requires an array value");n.$each.forEach(function(n){t[e].push(n)})}else t[e].push(n)},_.$addToSet=function(t,e,n){var r=!0;if(t.hasOwnProperty(e)||(t[e]=[]),!m.isArray(t[e]))throw new Error("Can't $addToSet an element on non-array values");if(null!==n&&"object"==typeof n&&n.$each){if(Object.keys(n).length>1)throw new Error("Can't use another field in conjunction with $each");if(!m.isArray(n.$each))throw new Error("$each requires an array value");n.$each.forEach(function(n){_.$addToSet(t,e,n)})}else t[e].forEach(function(t){0===f(t,n)&&(r=!1)}),r&&t[e].push(n)},_.$pop=function(t,e,n){if(!m.isArray(t[e]))throw new Error("Can't $pop an element from non-array values");if("number"!=typeof n)throw new Error(n+" isn't an integer, can't use it with $pop");0!==n&&(t[e]=n>0?t[e].slice(0,t[e].length-1):t[e].slice(1))},_.$pull=function(t,e,n){var r,i;if(!m.isArray(t[e]))throw new Error("Can't $pull an element from non-array values");for(r=t[e],i=r.length-1;i>=0;i-=1)v(r[i],n)&&r.splice(i,1)},_.$inc=function(t,e,n){if("number"!=typeof n)throw new Error(n+" must be a number");if("number"!=typeof t[e]){if(b.has(t,e))throw new Error("Don't use the $inc modifier on non-number fields");t[e]=n}else t[e]+=n},Object.keys(_).forEach(function(t){w[t]=l(t)}),k.$lt=function(t,e){return y(t,e)&&e>t},k.$lte=function(t,e){return y(t,e)&&e>=t},k.$gt=function(t,e){return y(t,e)&&t>e},k.$gte=function(t,e){return y(t,e)&&t>=e},k.$ne=function(t,e){return void 0===t?!0:!d(t,e)},k.$in=function(t,e){var n;if(!m.isArray(e))throw new Error("$in operator called with a non-array");for(n=0;n<e.length;n+=1)if(d(t,e[n]))return!0;return!1},k.$nin=function(t,e){if(!m.isArray(e))throw new Error("$nin operator called with a non-array");return!k.$in(t,e)},k.$regex=function(t,e){if(!m.isRegExp(e))throw new Error("$regex operator called with non regular expression");return"string"!=typeof t?!1:e.test(t)},k.$exists=function(t,e){return e=e||""===e?!0:!1,void 0===t?!e:e},k.$size=function(t,e){if(!m.isArray(t))return!1;if(0!==e%1)throw new Error("$size operator called without an integer");return t.length==e},E.$size=!0,x.$or=function(t,e){var n;if(!m.isArray(e))throw new Error("$or operator used without an array");for(n=0;n<e.length;n+=1)if(v(t,e[n]))return!0;return!1},x.$and=function(t,e){var n;if(!m.isArray(e))throw new Error("$and operator used without an array");for(n=0;n<e.length;n+=1)if(!v(t,e[n]))return!1;return!0},x.$not=function(t,e){return!v(t,e)},x.$where=function(t,e){var n;if(!b.isFunction(e))throw new Error("$where operator used without a function");if(n=e.call(t),!b.isBoolean(n))throw new Error("$where function must return boolean");return n},e.exports.serialize=i,e.exports.deserialize=o,e.exports.deepCopy=a,e.exports.checkObject=r,e.exports.isPrimitiveType=u,e.exports.modify=h,e.exports.getDotValue=p,e.exports.match=v,e.exports.areThingsEqual=d,e.exports.compareThings=f},{underscore:19,util:3}],11:[function(t,e){function n(t){var e,r,i;if(this.db=t.db,this.inMemoryOnly=this.db.inMemoryOnly,this.filename=this.db.filename,this.corruptAlertThreshold=void 0!==t.corruptAlertThreshold?t.corruptAlertThreshold:.1,!this.inMemoryOnly&&this.filename&&"~"===this.filename.charAt(this.filename.length-1))throw new Error("The datafile name can't end with a ~, which is reserved for crash safe backup files");if(t.afterSerialization&&!t.beforeDeserialization)throw new Error("Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss");if(!t.afterSerialization&&t.beforeDeserialization)throw new Error("Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss");for(this.afterSerialization=t.afterSerialization||function(t){return t},this.beforeDeserialization=t.beforeDeserialization||function(t){return t},e=1;30>e;e+=1)for(r=0;10>r;r+=1)if(i=s.uid(e),this.beforeDeserialization(this.afterSerialization(i))!==i)throw new Error("beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss");this.filename&&t.nodeWebkitAppName&&(console.log("=================================================================="),console.log("WARNING: The nodeWebkitAppName option is deprecated"),console.log("To get the path to the directory where Node Webkit stores the data"),console.log("for your app, use the internal nw.gui module like this"),console.log("require('nw.gui').App.dataPath"),console.log("See https://github.com/rogerwang/node-webkit/issues/500"),console.log("=================================================================="),this.filename=n.getNWAppFilename(t.nodeWebkitAppName,this.filename))
+}var r=t("__browserify_process"),i=t("./storage"),o=t("path"),a=t("./model"),u=t("async"),s=t("./customUtils"),c=t("./indexes");n.ensureDirectoryExists=function(t,e){var n=e||function(){};i.mkdirp(t,function(t){return n(t)})},n.getNWAppFilename=function(t,e){var n;switch(r.platform){case"win32":case"win64":if(n=r.env.LOCALAPPDATA||r.env.APPDATA,!n)throw new Error("Couldn't find the base application data folder");n=o.join(n,t);break;case"darwin":if(n=r.env.HOME,!n)throw new Error("Couldn't find the base application data directory");n=o.join(n,"Library","Application Support",t);break;case"linux":if(n=r.env.HOME,!n)throw new Error("Couldn't find the base application data directory");n=o.join(n,".config",t);break;default:throw new Error("Can't use the Node Webkit relative path for platform "+r.platform)}return o.join(n,"nedb-data",e)},n.prototype.persistCachedDatabase=function(t){var e=t||function(){},n="",r=this;return this.inMemoryOnly?e(null):(this.db.getAllData().forEach(function(t){n+=r.afterSerialization(a.serialize(t))+"\n"}),Object.keys(this.db.indexes).forEach(function(t){"_id"!=t&&(n+=r.afterSerialization(a.serialize({$$indexCreated:{fieldName:t,unique:r.db.indexes[t].unique,sparse:r.db.indexes[t].sparse}}))+"\n")}),i.crashSafeWriteFile(this.filename,n,e),void 0)},n.prototype.compactDatafile=function(){this.db.executor.push({"this":this,fn:this.persistCachedDatabase,arguments:[]})},n.prototype.setAutocompactionInterval=function(t){var e=this,n=5e3,r=Math.max(t||0,n);this.stopAutocompaction(),this.autocompactionIntervalId=setInterval(function(){e.compactDatafile()},r)},n.prototype.stopAutocompaction=function(){this.autocompactionIntervalId&&clearInterval(this.autocompactionIntervalId)},n.prototype.persistNewState=function(t,e){var n=this,r="",o=e||function(){};return n.inMemoryOnly?o(null):(t.forEach(function(t){r+=n.afterSerialization(a.serialize(t))+"\n"}),0===r.length?o(null):(i.appendFile(n.filename,r,"utf8",function(t){return o(t)}),void 0))},n.prototype.treatRawData=function(t){var e,n=t.split("\n"),r={},i=[],o={},u=-1;for(e=0;e<n.length;e+=1){var s;try{s=a.deserialize(this.beforeDeserialization(n[e])),s._id?s.$$deleted===!0?delete r[s._id]:r[s._id]=s:s.$$indexCreated&&void 0!=s.$$indexCreated.fieldName?o[s.$$indexCreated.fieldName]=s.$$indexCreated:"string"==typeof s.$$indexRemoved&&delete o[s.$$indexRemoved]}catch(c){u+=1}}if(n.length>0&&u/n.length>this.corruptAlertThreshold)throw new Error("More than "+Math.floor(100*this.corruptAlertThreshold)+"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss");return Object.keys(r).forEach(function(t){i.push(r[t])}),{data:i,indexes:o}},n.prototype.loadDatabase=function(t){var e=t||function(){},r=this;return r.db.resetIndexes(),r.inMemoryOnly?e(null):(u.waterfall([function(t){n.ensureDirectoryExists(o.dirname(r.filename),function(){i.ensureDatafileIntegrity(r.filename,function(){i.readFile(r.filename,"utf8",function(e,n){if(e)return t(e);try{var i=r.treatRawData(n)}catch(o){return t(o)}Object.keys(i.indexes).forEach(function(t){r.db.indexes[t]=new c(i.indexes[t])});try{r.db.resetIndexes(i.data)}catch(o){return r.db.resetIndexes(),t(o)}r.db.persistence.persistCachedDatabase(t)})})})}],function(t){return t?e(t):(r.db.executor.processBuffer(),e(null))}),void 0)},e.exports=n},{"./customUtils":6,"./indexes":9,"./model":10,"./storage":12,__browserify_process:4,async:13,path:2}],12:[function(t,e){function n(t,e){f.getItem(t,function(t,n){return null!==n?e(!0):e(!1)})}function r(t,e,n){f.getItem(t,function(r,i){null===i?f.removeItem(e,function(){return n()}):f.setItem(e,i,function(){f.removeItem(t,function(){return n()})})})}function i(t,e,n,r){"function"==typeof n&&(r=n),f.setItem(t,e,function(){return r()})}function o(t,e,n,r){"function"==typeof n&&(r=n),f.getItem(t,function(n,i){i=i||"",i+=e,f.setItem(t,i,function(){return r()})})}function a(t,e,n){"function"==typeof e&&(n=e),f.getItem(t,function(t,e){return n(null,e||"")})}function u(t,e){f.removeItem(t,function(){return e()})}function s(t,e){return e()}function c(t,e){return e(null)}var f=t("localforage");f.config({name:"NeDB",storeName:"nedbdata"}),e.exports.exists=n,e.exports.rename=r,e.exports.writeFile=i,e.exports.crashSafeWriteFile=i,e.exports.appendFile=o,e.exports.readFile=a,e.exports.unlink=u,e.exports.mkdirp=s,e.exports.ensureDatafileIntegrity=c},{localforage:18}],13:[function(e,n){var r=e("__browserify_process");!function(){function e(t){var e=!1;return function(){if(e)throw new Error("Callback was already called.");e=!0,t.apply(i,arguments)}}var i,o,a={};i=this,null!=i&&(o=i.async),a.noConflict=function(){return i.async=o,a};var u=function(t,e){if(t.forEach)return t.forEach(e);for(var n=0;n<t.length;n+=1)e(t[n],n,t)},s=function(t,e){if(t.map)return t.map(e);var n=[];return u(t,function(t,r,i){n.push(e(t,r,i))}),n},c=function(t,e,n){return t.reduce?t.reduce(e,n):(u(t,function(t,r,i){n=e(n,t,r,i)}),n)},f=function(t){if(Object.keys)return Object.keys(t);var e=[];for(var n in t)t.hasOwnProperty(n)&&e.push(n);return e};"undefined"!=typeof r&&r.nextTick?(a.nextTick=r.nextTick,a.setImmediate="undefined"!=typeof setImmediate?function(t){setImmediate(t)}:a.nextTick):"function"==typeof setImmediate?(a.nextTick=function(t){setImmediate(t)},a.setImmediate=a.nextTick):(a.nextTick=function(t){setTimeout(t,0)},a.setImmediate=a.nextTick),a.each=function(t,n,r){if(r=r||function(){},!t.length)return r();var i=0;u(t,function(o){n(o,e(function(e){e?(r(e),r=function(){}):(i+=1,i>=t.length&&r(null))}))})},a.forEach=a.each,a.eachSeries=function(t,e,n){if(n=n||function(){},!t.length)return n();var r=0,i=function(){e(t[r],function(e){e?(n(e),n=function(){}):(r+=1,r>=t.length?n(null):i())})};i()},a.forEachSeries=a.eachSeries,a.eachLimit=function(t,e,n,r){var i=l(e);i.apply(null,[t,n,r])},a.forEachLimit=a.eachLimit;var l=function(t){return function(e,n,r){if(r=r||function(){},!e.length||0>=t)return r();var i=0,o=0,a=0;!function u(){if(i>=e.length)return r();for(;t>a&&o<e.length;)o+=1,a+=1,n(e[o-1],function(t){t?(r(t),r=function(){}):(i+=1,a-=1,i>=e.length?r():u())})}()}},h=function(t){return function(){var e=Array.prototype.slice.call(arguments);return t.apply(null,[a.each].concat(e))}},p=function(t,e){return function(){var n=Array.prototype.slice.call(arguments);return e.apply(null,[l(t)].concat(n))}},d=function(t){return function(){var e=Array.prototype.slice.call(arguments);return t.apply(null,[a.eachSeries].concat(e))}},y=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n,r){i[t.index]=r,e(n)})},function(t){r(t,i)})};a.map=h(y),a.mapSeries=d(y),a.mapLimit=function(t,e,n,r){return v(e)(t,n,r)};var v=function(t){return p(t,y)};a.reduce=function(t,e,n,r){a.eachSeries(t,function(t,r){n(e,t,function(t,n){e=n,r(t)})},function(t){r(t,e)})},a.inject=a.reduce,a.foldl=a.reduce,a.reduceRight=function(t,e,n,r){var i=s(t,function(t){return t}).reverse();a.reduce(i,e,n,r)},a.foldr=a.reduceRight;var g=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n){n&&i.push(t),e()})},function(){r(s(i.sort(function(t,e){return t.index-e.index}),function(t){return t.value}))})};a.filter=h(g),a.filterSeries=d(g),a.select=a.filter,a.selectSeries=a.filterSeries;var m=function(t,e,n,r){var i=[];e=s(e,function(t,e){return{index:e,value:t}}),t(e,function(t,e){n(t.value,function(n){n||i.push(t),e()})},function(){r(s(i.sort(function(t,e){return t.index-e.index}),function(t){return t.value}))})};a.reject=h(m),a.rejectSeries=d(m);var b=function(t,e,n,r){t(e,function(t,e){n(t,function(n){n?(r(t),r=function(){}):e()})},function(){r()})};a.detect=h(b),a.detectSeries=d(b),a.some=function(t,e,n){a.each(t,function(t,r){e(t,function(t){t&&(n(!0),n=function(){}),r()})},function(){n(!1)})},a.any=a.some,a.every=function(t,e,n){a.each(t,function(t,r){e(t,function(t){t||(n(!1),n=function(){}),r()})},function(){n(!0)})},a.all=a.every,a.sortBy=function(t,e,n){a.map(t,function(t,n){e(t,function(e,r){e?n(e):n(null,{value:t,criteria:r})})},function(t,e){if(t)return n(t);var r=function(t,e){var n=t.criteria,r=e.criteria;return r>n?-1:n>r?1:0};n(null,s(e.sort(r),function(t){return t.value}))})},a.auto=function(t,e){e=e||function(){};var n=f(t);if(!n.length)return e(null);var r={},i=[],o=function(t){i.unshift(t)},s=function(t){for(var e=0;e<i.length;e+=1)if(i[e]===t)return i.splice(e,1),void 0},l=function(){u(i.slice(0),function(t){t()})};o(function(){f(r).length===n.length&&(e(null,r),e=function(){})}),u(n,function(n){var i=t[n]instanceof Function?[t[n]]:t[n],h=function(t){var i=Array.prototype.slice.call(arguments,1);if(i.length<=1&&(i=i[0]),t){var o={};u(f(r),function(t){o[t]=r[t]}),o[n]=i,e(t,o),e=function(){}}else r[n]=i,a.setImmediate(l)},p=i.slice(0,Math.abs(i.length-1))||[],d=function(){return c(p,function(t,e){return t&&r.hasOwnProperty(e)},!0)&&!r.hasOwnProperty(n)};if(d())i[i.length-1](h,r);else{var y=function(){d()&&(s(y),i[i.length-1](h,r))};o(y)}})},a.waterfall=function(t,e){if(e=e||function(){},t.constructor!==Array){var n=new Error("First argument to waterfall must be an array of functions");return e(n)}if(!t.length)return e();var r=function(t){return function(n){if(n)e.apply(null,arguments),e=function(){};else{var i=Array.prototype.slice.call(arguments,1),o=t.next();o?i.push(r(o)):i.push(e),a.setImmediate(function(){t.apply(null,i)})}}};r(a.iterator(t))()};var w=function(t,e,n){if(n=n||function(){},e.constructor===Array)t.map(e,function(t,e){t&&t(function(t){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),e.call(null,t,n)})},n);else{var r={};t.each(f(e),function(t,n){e[t](function(e){var i=Array.prototype.slice.call(arguments,1);i.length<=1&&(i=i[0]),r[t]=i,n(e)})},function(t){n(t,r)})}};a.parallel=function(t,e){w({map:a.map,each:a.each},t,e)},a.parallelLimit=function(t,e,n){w({map:v(e),each:l(e)},t,n)},a.series=function(t,e){if(e=e||function(){},t.constructor===Array)a.mapSeries(t,function(t,e){t&&t(function(t){var n=Array.prototype.slice.call(arguments,1);n.length<=1&&(n=n[0]),e.call(null,t,n)})},e);else{var n={};a.eachSeries(f(t),function(e,r){t[e](function(t){var i=Array.prototype.slice.call(arguments,1);i.length<=1&&(i=i[0]),n[e]=i,r(t)})},function(t){e(t,n)})}},a.iterator=function(t){var e=function(n){var r=function(){return t.length&&t[n].apply(null,arguments),r.next()};return r.next=function(){return n<t.length-1?e(n+1):null},r};return e(0)},a.apply=function(t){var e=Array.prototype.slice.call(arguments,1);return function(){return t.apply(null,e.concat(Array.prototype.slice.call(arguments)))}};var _=function(t,e,n,r){var i=[];t(e,function(t,e){n(t,function(t,n){i=i.concat(n||[]),e(t)})},function(t){r(t,i)})};a.concat=h(_),a.concatSeries=d(_),a.whilst=function(t,e,n){t()?e(function(r){return r?n(r):(a.whilst(t,e,n),void 0)}):n()},a.doWhilst=function(t,e,n){t(function(r){return r?n(r):(e()?a.doWhilst(t,e,n):n(),void 0)})},a.until=function(t,e,n){t()?n():e(function(r){return r?n(r):(a.until(t,e,n),void 0)})},a.doUntil=function(t,e,n){t(function(r){return r?n(r):(e()?n():a.doUntil(t,e,n),void 0)})},a.queue=function(t,n){function r(t,e,r,i){e.constructor!==Array&&(e=[e]),u(e,function(e){var o={data:e,callback:"function"==typeof i?i:null};r?t.tasks.unshift(o):t.tasks.push(o),t.saturated&&t.tasks.length===n&&t.saturated(),a.setImmediate(t.process)})}void 0===n&&(n=1);var i=0,o={tasks:[],concurrency:n,saturated:null,empty:null,drain:null,push:function(t,e){r(o,t,!1,e)},unshift:function(t,e){r(o,t,!0,e)},process:function(){if(i<o.concurrency&&o.tasks.length){var n=o.tasks.shift();o.empty&&0===o.tasks.length&&o.empty(),i+=1;var r=function(){i-=1,n.callback&&n.callback.apply(n,arguments),o.drain&&0===o.tasks.length+i&&o.drain(),o.process()},a=e(r);t(n.data,a)}},length:function(){return o.tasks.length},running:function(){return i}};return o},a.cargo=function(t,e){var n=!1,r=[],i={tasks:r,payload:e,saturated:null,empty:null,drain:null,push:function(t,n){t.constructor!==Array&&(t=[t]),u(t,function(t){r.push({data:t,callback:"function"==typeof n?n:null}),i.saturated&&r.length===e&&i.saturated()}),a.setImmediate(i.process)},process:function o(){if(!n){if(0===r.length)return i.drain&&i.drain(),void 0;var a="number"==typeof e?r.splice(0,e):r.splice(0),c=s(a,function(t){return t.data});i.empty&&i.empty(),n=!0,t(c,function(){n=!1;var t=arguments;u(a,function(e){e.callback&&e.callback.apply(null,t)}),o()})}},length:function(){return r.length},running:function(){return n}};return i};var k=function(t){return function(e){var n=Array.prototype.slice.call(arguments,1);e.apply(null,n.concat([function(e){var n=Array.prototype.slice.call(arguments,1);"undefined"!=typeof console&&(e?console.error&&console.error(e):console[t]&&u(n,function(e){console[t](e)}))}]))}};a.log=k("log"),a.dir=k("dir"),a.memoize=function(t,e){var n={},r={};e=e||function(t){return t};var i=function(){var i=Array.prototype.slice.call(arguments),o=i.pop(),a=e.apply(null,i);a in n?o.apply(null,n[a]):a in r?r[a].push(o):(r[a]=[o],t.apply(null,i.concat([function(){n[a]=arguments;var t=r[a];delete r[a];for(var e=0,i=t.length;i>e;e++)t[e].apply(null,arguments)}])))};return i.memo=n,i.unmemoized=t,i},a.unmemoize=function(t){return function(){return(t.unmemoized||t).apply(null,arguments)}},a.times=function(t,e,n){for(var r=[],i=0;t>i;i++)r.push(i);return a.map(r,e,n)},a.timesSeries=function(t,e,n){for(var r=[],i=0;t>i;i++)r.push(i);return a.mapSeries(r,e,n)},a.compose=function(){var t=Array.prototype.reverse.call(arguments);return function(){var e=this,n=Array.prototype.slice.call(arguments),r=n.pop();a.reduce(t,n,function(t,n,r){n.apply(e,t.concat([function(){var t=arguments[0],e=Array.prototype.slice.call(arguments,1);r(t,e)}]))},function(t,n){r.apply(e,[t].concat(n))})}};var x=function(t,e){var n=function(){var n=this,r=Array.prototype.slice.call(arguments),i=r.pop();return t(e,function(t,e){t.apply(n,r.concat([e]))},i)};if(arguments.length>2){var r=Array.prototype.slice.call(arguments,2);return n.apply(this,r)}return n};a.applyEach=h(x),a.applyEachSeries=d(x),a.forever=function(t,e){function n(r){if(r){if(e)return e(r);throw r}t(n)}n()},"undefined"!=typeof t&&t.amd?t([],function(){return a}):"undefined"!=typeof n&&n.exports?n.exports=a:i.async=a}()},{__browserify_process:4}],14:[function(t,e){e.exports.BinarySearchTree=t("./lib/bst"),e.exports.AVLTree=t("./lib/avltree")},{"./lib/avltree":15,"./lib/bst":16}],15:[function(t,e){function n(t){this.tree=new r(t)}function r(t){t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,t.hasOwnProperty("key")&&(this.key=t.key),this.data=t.hasOwnProperty("value")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||o.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||o.defaultCheckValueEquality}var i=t("./bst"),o=t("./customUtils"),a=t("util");t("underscore"),a.inherits(r,i),n._AVLTree=r,r.prototype.checkHeightCorrect=function(){var t,e;if(this.hasOwnProperty("key")){if(this.left&&void 0===this.left.height)throw new Error("Undefined height for node "+this.left.key);if(this.right&&void 0===this.right.height)throw new Error("Undefined height for node "+this.right.key);if(void 0===this.height)throw new Error("Undefined height for node "+this.key);if(t=this.left?this.left.height:0,e=this.right?this.right.height:0,this.height!==1+Math.max(t,e))throw new Error("Height constraint failed for node "+this.key);this.left&&this.left.checkHeightCorrect(),this.right&&this.right.checkHeightCorrect()}},r.prototype.balanceFactor=function(){var t=this.left?this.left.height:0,e=this.right?this.right.height:0;return t-e},r.prototype.checkBalanceFactors=function(){if(Math.abs(this.balanceFactor())>1)throw new Error("Tree is unbalanced at node "+this.key);this.left&&this.left.checkBalanceFactors(),this.right&&this.right.checkBalanceFactors()},r.prototype.checkIsAVLT=function(){r.super_.prototype.checkIsBST.call(this),this.checkHeightCorrect(),this.checkBalanceFactors()},n.prototype.checkIsAVLT=function(){this.tree.checkIsAVLT()},r.prototype.rightRotation=function(){var t,e,n,r,i=this,o=this.left;return o?(t=o.right,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.right=i,i.parent=o,i.left=t,t&&(t.parent=i),e=o.left?o.left.height:0,n=t?t.height:0,r=i.right?i.right.height:0,i.height=Math.max(n,r)+1,o.height=Math.max(e,i.height)+1,o):this},r.prototype.leftRotation=function(){var t,e,n,r,i=this,o=this.right;return o?(t=o.left,i.parent?(o.parent=i.parent,i.parent.left===i?i.parent.left=o:i.parent.right=o):o.parent=null,o.left=i,i.parent=o,i.right=t,t&&(t.parent=i),e=i.left?i.left.height:0,n=t?t.height:0,r=o.right?o.right.height:0,i.height=Math.max(e,n)+1,o.height=Math.max(r,i.height)+1,o):this},r.prototype.rightTooSmall=function(){return this.balanceFactor()<=1?this:(this.left.balanceFactor()<0&&this.left.leftRotation(),this.rightRotation())},r.prototype.leftTooSmall=function(){return this.balanceFactor()>=-1?this:(this.right.balanceFactor()>0&&this.right.rightRotation(),this.leftRotation())},r.prototype.rebalanceAlongPath=function(t){var e,n,r=this;if(!this.hasOwnProperty("key"))return delete this.height,this;for(n=t.length-1;n>=0;n-=1)t[n].height=1+Math.max(t[n].left?t[n].left.height:0,t[n].right?t[n].right.height:0),t[n].balanceFactor()>1&&(e=t[n].rightTooSmall(),0===n&&(r=e)),t[n].balanceFactor()<-1&&(e=t[n].leftTooSmall(),0===n&&(r=e));return r},r.prototype.insert=function(t,e){var n=[],r=this;if(!this.hasOwnProperty("key"))return this.key=t,this.data.push(e),this.height=1,this;for(;;){if(0===r.compareKeys(r.key,t)){if(r.unique){var i=new Error("Can't insert key "+t+", it violates the unique constraint");throw i.key=t,i.errorType="uniqueViolated",i}return r.data.push(e),this}if(n.push(r),r.compareKeys(t,r.key)<0){if(!r.left){n.push(r.createLeftChild({key:t,value:e}));break}r=r.left}else{if(!r.right){n.push(r.createRightChild({key:t,value:e}));break}r=r.right}}return this.rebalanceAlongPath(n)},n.prototype.insert=function(t,e){var n=this.tree.insert(t,e);n&&(this.tree=n)},r.prototype.delete=function(t,e){var n,r=[],i=this,o=[];if(!this.hasOwnProperty("key"))return this;for(;;){if(0===i.compareKeys(t,i.key))break;if(o.push(i),i.compareKeys(t,i.key)<0){if(!i.left)return this;i=i.left}else{if(!i.right)return this;i=i.right}}if(i.data.length>1&&e)return i.data.forEach(function(t){i.checkValueEquality(t,e)||r.push(t)}),i.data=r,this;if(!i.left&&!i.right)return i===this?(delete i.key,i.data=[],delete i.height,this):(i.parent.left===i?i.parent.left=null:i.parent.right=null,this.rebalanceAlongPath(o));if(!i.left||!i.right)return n=i.left?i.left:i.right,i===this?(n.parent=null,n):(i.parent.left===i?(i.parent.left=n,n.parent=i.parent):(i.parent.right=n,n.parent=i.parent),this.rebalanceAlongPath(o));if(o.push(i),n=i.left,!n.right)return i.key=n.key,i.data=n.data,i.left=n.left,n.left&&(n.left.parent=i),this.rebalanceAlongPath(o);for(;;){if(!n.right)break;o.push(n),n=n.right}return i.key=n.key,i.data=n.data,n.parent.right=n.left,n.left&&(n.left.parent=n.parent),this.rebalanceAlongPath(o)},n.prototype.delete=function(t,e){var n=this.tree.delete(t,e);n&&(this.tree=n)},["getNumberOfKeys","search","betweenBounds","prettyPrint","executeOnEveryNode"].forEach(function(t){n.prototype[t]=function(){return this.tree[t].apply(this.tree,arguments)}}),e.exports=n},{"./bst":16,"./customUtils":17,underscore:19,util:3}],16:[function(t,e){function n(t){t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,t.hasOwnProperty("key")&&(this.key=t.key),this.data=t.hasOwnProperty("value")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||i.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||i.defaultCheckValueEquality}function r(t,e){var n;for(n=0;n<e.length;n+=1)t.push(e[n])}var i=t("./customUtils");n.prototype.getMaxKeyDescendant=function(){return this.right?this.right.getMaxKeyDescendant():this},n.prototype.getMaxKey=function(){return this.getMaxKeyDescendant().key},n.prototype.getMinKeyDescendant=function(){return this.left?this.left.getMinKeyDescendant():this},n.prototype.getMinKey=function(){return this.getMinKeyDescendant().key},n.prototype.checkAllNodesFullfillCondition=function(t){this.hasOwnProperty("key")&&(t(this.key,this.data),this.left&&this.left.checkAllNodesFullfillCondition(t),this.right&&this.right.checkAllNodesFullfillCondition(t))},n.prototype.checkNodeOrdering=function(){var t=this;this.hasOwnProperty("key")&&(this.left&&(this.left.checkAllNodesFullfillCondition(function(e){if(t.compareKeys(e,t.key)>=0)throw new Error("Tree with root "+t.key+" is not a binary search tree")}),this.left.checkNodeOrdering()),this.right&&(this.right.checkAllNodesFullfillCondition(function(e){if(t.compareKeys(e,t.key)<=0)throw new Error("Tree with root "+t.key+" is not a binary search tree")}),this.right.checkNodeOrdering()))},n.prototype.checkInternalPointers=function(){if(this.left){if(this.left.parent!==this)throw new Error("Parent pointer broken for key "+this.key);this.left.checkInternalPointers()}if(this.right){if(this.right.parent!==this)throw new Error("Parent pointer broken for key "+this.key);this.right.checkInternalPointers()}},n.prototype.checkIsBST=function(){if(this.checkNodeOrdering(),this.checkInternalPointers(),this.parent)throw new Error("The root shouldn't have a parent")},n.prototype.getNumberOfKeys=function(){var t;return this.hasOwnProperty("key")?(t=1,this.left&&(t+=this.left.getNumberOfKeys()),this.right&&(t+=this.right.getNumberOfKeys()),t):0},n.prototype.createSimilar=function(t){return t=t||{},t.unique=this.unique,t.compareKeys=this.compareKeys,t.checkValueEquality=this.checkValueEquality,new this.constructor(t)},n.prototype.createLeftChild=function(t){var e=this.createSimilar(t);return e.parent=this,this.left=e,e},n.prototype.createRightChild=function(t){var e=this.createSimilar(t);return e.parent=this,this.right=e,e},n.prototype.insert=function(t,e){if(!this.hasOwnProperty("key"))return this.key=t,this.data.push(e),void 0;if(0===this.compareKeys(this.key,t)){if(this.unique){var n=new Error("Can't insert key "+t+", it violates the unique constraint");throw n.key=t,n.errorType="uniqueViolated",n}return this.data.push(e),void 0}this.compareKeys(t,this.key)<0?this.left?this.left.insert(t,e):this.createLeftChild({key:t,value:e}):this.right?this.right.insert(t,e):this.createRightChild({key:t,value:e})},n.prototype.search=function(t){return this.hasOwnProperty("key")?0===this.compareKeys(this.key,t)?this.data:this.compareKeys(t,this.key)<0?this.left?this.left.search(t):[]:this.right?this.right.search(t):[]:[]},n.prototype.getLowerBoundMatcher=function(t){var e=this;return t.hasOwnProperty("$gt")||t.hasOwnProperty("$gte")?t.hasOwnProperty("$gt")&&t.hasOwnProperty("$gte")?0===e.compareKeys(t.$gte,t.$gt)?function(n){return e.compareKeys(n,t.$gt)>0}:e.compareKeys(t.$gte,t.$gt)>0?function(n){return e.compareKeys(n,t.$gte)>=0}:function(n){return e.compareKeys(n,t.$gt)>0}:t.hasOwnProperty("$gt")?function(n){return e.compareKeys(n,t.$gt)>0}:function(n){return e.compareKeys(n,t.$gte)>=0}:function(){return!0}},n.prototype.getUpperBoundMatcher=function(t){var e=this;return t.hasOwnProperty("$lt")||t.hasOwnProperty("$lte")?t.hasOwnProperty("$lt")&&t.hasOwnProperty("$lte")?0===e.compareKeys(t.$lte,t.$lt)?function(n){return e.compareKeys(n,t.$lt)<0}:e.compareKeys(t.$lte,t.$lt)<0?function(n){return e.compareKeys(n,t.$lte)<=0}:function(n){return e.compareKeys(n,t.$lt)<0}:t.hasOwnProperty("$lt")?function(n){return e.compareKeys(n,t.$lt)<0}:function(n){return e.compareKeys(n,t.$lte)<=0}:function(){return!0}},n.prototype.betweenBounds=function(t,e,n){var i=[];return this.hasOwnProperty("key")?(e=e||this.getLowerBoundMatcher(t),n=n||this.getUpperBoundMatcher(t),e(this.key)&&this.left&&r(i,this.left.betweenBounds(t,e,n)),e(this.key)&&n(this.key)&&r(i,this.data),n(this.key)&&this.right&&r(i,this.right.betweenBounds(t,e,n)),i):[]},n.prototype.deleteIfLeaf=function(){return this.left||this.right?!1:this.parent?(this.parent.left===this?this.parent.left=null:this.parent.right=null,!0):(delete this.key,this.data=[],!0)},n.prototype.deleteIfOnlyOneChild=function(){var t;return this.left&&!this.right&&(t=this.left),!this.left&&this.right&&(t=this.right),t?this.parent?(this.parent.left===this?(this.parent.left=t,t.parent=this.parent):(this.parent.right=t,t.parent=this.parent),!0):(this.key=t.key,this.data=t.data,this.left=null,t.left&&(this.left=t.left,t.left.parent=this),this.right=null,t.right&&(this.right=t.right,t.right.parent=this),!0):!1},n.prototype.delete=function(t,e){var n,r=[],i=this;if(this.hasOwnProperty("key")){if(this.compareKeys(t,this.key)<0)return this.left&&this.left.delete(t,e),void 0;if(this.compareKeys(t,this.key)>0)return this.right&&this.right.delete(t,e),void 0;if(0!==!this.compareKeys(t,this.key))return this.data.length>1&&void 0!==e?(this.data.forEach(function(t){i.checkValueEquality(t,e)||r.push(t)}),i.data=r,void 0):(this.deleteIfLeaf()||this.deleteIfOnlyOneChild()||(Math.random()>=.5?(n=this.left.getMaxKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.left=n.left,n.left&&(n.left.parent=n.parent)):(n.parent.right=n.left,n.left&&(n.left.parent=n.parent))):(n=this.right.getMinKeyDescendant(),this.key=n.key,this.data=n.data,this===n.parent?(this.right=n.right,n.right&&(n.right.parent=n.parent)):(n.parent.left=n.right,n.right&&(n.right.parent=n.parent)))),void 0)}},n.prototype.executeOnEveryNode=function(t){this.left&&this.left.executeOnEveryNode(t),t(this),this.right&&this.right.executeOnEveryNode(t)},n.prototype.prettyPrint=function(t,e){e=e||"",console.log(e+"* "+this.key),t&&console.log(e+"* "+this.data),(this.left||this.right)&&(this.left?this.left.prettyPrint(t,e+"  "):console.log(e+"  *"),this.right?this.right.prettyPrint(t,e+"  "):console.log(e+"  *"))},e.exports=n},{"./customUtils":17}],17:[function(t,e){function n(t){var e,r;return 0===t?[]:1===t?[0]:(e=n(t-1),r=Math.floor(Math.random()*t),e.splice(r,0,t-1),e)}function r(t,e){if(e>t)return-1;if(t>e)return 1;if(t===e)return 0;var n=new Error("Couldn't compare elements");throw n.a=t,n.b=e,n}function i(t,e){return t===e}e.exports.getRandomArray=n,e.exports.defaultCompareKeysFunction=r,e.exports.defaultCheckValueEquality=i},{}],18:[function(e,n,r){var i=e("__browserify_process"),o=self;!function(){var t,e,n,r;!function(){var i={},o={};t=function(t,e,n){i[t]={deps:e,callback:n}},r=n=e=function(t){function n(e){if("."!==e.charAt(0))return e;for(var n=e.split("/"),r=t.split("/").slice(0,-1),i=0,o=n.length;o>i;i++){var a=n[i];if(".."===a)r.pop();else{if("."===a)continue;r.push(a)}}return r.join("/")}if(r._eak_seen=i,o[t])return o[t];if(o[t]={},!i[t])throw new Error("Could not find module "+t);for(var a,u=i[t],s=u.deps,c=u.callback,f=[],l=0,h=s.length;h>l;l++)"exports"===s[l]?f.push(a={}):f.push(e(n(s[l])));var p=c.apply(this,f);return o[t]=a||p}}(),t("promise/all",["./utils","exports"],function(t,e){"use strict";function n(t){var e=this;if(!r(t))throw new TypeError("You must pass an array to all.");return new e(function(e,n){function r(t){return function(e){o(t,e)}}function o(t,n){u[t]=n,0===--s&&e(u)}var a,u=[],s=t.length;0===s&&e([]);for(var c=0;c<t.length;c++)a=t[c],a&&i(a.then)?a.then(r(c),n):o(c,a)})}var r=t.isArray,i=t.isFunction;e.all=n}),t("promise/asap",["exports"],function(t){"use strict";function e(){return function(){i.nextTick(a)}}function n(){var t=0,e=new f(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function r(){return function(){l.setTimeout(a,1)}}function a(){for(var t=0;t<h.length;t++){var e=h[t],n=e[0],r=e[1];n(r)}h=[]}function u(t,e){var n=h.push([t,e]);1===n&&s()}var s,c="undefined"!=typeof window?window:{},f=c.MutationObserver||c.WebKitMutationObserver,l="undefined"!=typeof o?o:void 0===this?window:this,h=[];s="undefined"!=typeof i&&"[object process]"==={}.toString.call(i)?e():f?n():r(),t.asap=u}),t("promise/config",["exports"],function(t){"use strict";function e(t,e){return 2!==arguments.length?n[t]:(n[t]=e,void 0)}var n={instrument:!1};t.config=n,t.configure=e}),t("promise/polyfill",["./promise","./utils","exports"],function(t,e,n){"use strict";function r(){var t;t="undefined"!=typeof o?o:"undefined"!=typeof window&&window.document?window:self;var e="Promise"in t&&"resolve"in t.Promise&&"reject"in t.Promise&&"all"in t.Promise&&"race"in t.Promise&&function(){var e;return new t.Promise(function(t){e=t}),a(e)}();e||(t.Promise=i)}var i=t.Promise,a=e.isFunction;n.polyfill=r}),t("promise/promise",["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],function(t,e,n,r,i,o,a,u){"use strict";function s(t){if(!_(t))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof s))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._subscribers=[],c(t,this)}function c(t,e){function n(t){d(e,t)}function r(t){v(e,t)}try{t(n,r)}catch(i){r(i)}}function f(t,e,n,r){var i,o,a,u,s=_(n);if(s)try{i=n(r),a=!0}catch(c){u=!0,o=c}else i=r,a=!0;p(e,i)||(s&&a?d(e,i):u?v(e,o):t===I?d(e,i):t===D&&v(e,i))}function l(t,e,n,r){var i=t._subscribers,o=i.length;i[o]=e,i[o+I]=n,i[o+D]=r}function h(t,e){for(var n,r,i=t._subscribers,o=t._detail,a=0;a<i.length;a+=3)n=i[a],r=i[a+e],f(e,n,r,o);t._subscribers=null}function p(t,e){var n,r=null;try{if(t===e)throw new TypeError("A promises callback cannot return that same promise.");if(w(e)&&(r=e.then,_(r)))return r.call(e,function(r){return n?!0:(n=!0,e!==r?d(t,r):y(t,r),void 0)},function(e){return n?!0:(n=!0,v(t,e),void 0)}),!0}catch(i){return n?!0:(v(t,i),!0)}return!1}function d(t,e){t===e?y(t,e):p(t,e)||y(t,e)}function y(t,e){t._state===S&&(t._state=j,t._detail=e,b.async(g,t))}function v(t,e){t._state===S&&(t._state=j,t._detail=e,b.async(m,t))}function g(t){h(t,t._state=I)}function m(t){h(t,t._state=D)}var b=t.config;t.configure;var w=e.objectOrFunction,_=e.isFunction;e.now;var k=n.all,x=r.race,E=i.resolve,A=o.reject,O=a.asap;b.async=O;var S=void 0,j=0,I=1,D=2;s.prototype={constructor:s,_state:void 0,_detail:void 0,_subscribers:void 0,then:function(t,e){var n=this,r=new this.constructor(function(){});if(this._state){var i=arguments;b.async(function(){f(n._state,r,i[n._state-1],n._detail)})}else l(this,r,t,e);return r},"catch":function(t){return this.then(null,t)}},s.all=k,s.race=x,s.resolve=E,s.reject=A,u.Promise=s}),t("promise/race",["./utils","exports"],function(t,e){"use strict";function n(t){var e=this;if(!r(t))throw new TypeError("You must pass an array to race.");return new e(function(e,n){for(var r,i=0;i<t.length;i++)r=t[i],r&&"function"==typeof r.then?r.then(e,n):e(r)})}var r=t.isArray;e.race=n}),t("promise/reject",["exports"],function(t){"use strict";function e(t){var e=this;return new e(function(e,n){n(t)})}t.reject=e}),t("promise/resolve",["exports"],function(t){"use strict";function e(t){if(t&&"object"==typeof t&&t.constructor===this)return t;var e=this;return new e(function(e){e(t)})}t.resolve=e}),t("promise/utils",["exports"],function(t){"use strict";function e(t){return n(t)||"object"==typeof t&&null!==t}function n(t){return"function"==typeof t}function r(t){return"[object Array]"===Object.prototype.toString.call(t)}var i=Date.now||function(){return(new Date).getTime()};t.objectOrFunction=e,t.isFunction=n,t.isArray=r,t.now=i}),e("promise/polyfill").polyfill()}(),function(e,i){"object"==typeof r&&"object"==typeof n?n.exports=i():"function"==typeof t&&t.amd?t([],i):"object"==typeof r?r.localforage=i():e.localforage=i()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={exports:{},id:r,loaded:!1};return t[r].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";
+function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.__esModule=!0,function(){function t(t,e){t[e]=function(){var n=arguments;return t.ready().then(function(){return t[e].apply(t,n)})}}function i(){for(var t=1;t<arguments.length;t++){var e=arguments[t];if(e)for(var n in e)e.hasOwnProperty(n)&&(arguments[0][n]=h(e[n])?e[n].slice():e[n])}return arguments[0]}function o(t){for(var e in u)if(u.hasOwnProperty(e)&&u[e]===t)return!0;return!1}var a={},u={INDEXEDDB:"asyncStorage",LOCALSTORAGE:"localStorageWrapper",WEBSQL:"webSQLStorage"},s=[u.INDEXEDDB,u.WEBSQL,u.LOCALSTORAGE],c=["clear","getItem","iterate","key","keys","length","removeItem","setItem"],f={description:"",driver:s.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},l=function(t){var e=e||t.indexedDB||t.webkitIndexedDB||t.mozIndexedDB||t.OIndexedDB||t.msIndexedDB,n={};return n[u.WEBSQL]=!!t.openDatabase,n[u.INDEXEDDB]=!!function(){if("undefined"!=typeof t.openDatabase&&t.navigator&&t.navigator.userAgent&&/Safari/.test(t.navigator.userAgent)&&!/Chrome/.test(t.navigator.userAgent))return!1;try{return e&&"function"==typeof e.open&&"undefined"!=typeof t.IDBKeyRange}catch(n){return!1}}(),n[u.LOCALSTORAGE]=!!function(){try{return t.localStorage&&"setItem"in t.localStorage&&t.localStorage.setItem}catch(e){return!1}}(),n}(this),h=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},p=function(){function e(t){r(this,e),this.INDEXEDDB=u.INDEXEDDB,this.LOCALSTORAGE=u.LOCALSTORAGE,this.WEBSQL=u.WEBSQL,this._defaultConfig=i({},f),this._config=i({},this._defaultConfig,t),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver)}return e.prototype.config=function(t){if("object"==typeof t){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var e in t)"storeName"===e&&(t[e]=t[e].replace(/\W/g,"_")),this._config[e]=t[e];return"driver"in t&&t.driver&&this.setDriver(this._config.driver),!0}return"string"==typeof t?this._config[t]:this._config},e.prototype.defineDriver=function(t,e,n){var r=new Promise(function(e,n){try{var r=t._driver,i=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver"),u=new Error("Custom driver name already in use: "+t._driver);if(!t._driver)return n(i),void 0;if(o(t._driver))return n(u),void 0;for(var s=c.concat("_initStorage"),f=0;f<s.length;f++){var h=s[f];if(!h||!t[h]||"function"!=typeof t[h])return n(i),void 0}var p=Promise.resolve(!0);"_support"in t&&(p=t._support&&"function"==typeof t._support?t._support():Promise.resolve(!!t._support)),p.then(function(n){l[r]=n,a[r]=t,e()},n)}catch(d){n(d)}});return r.then(e,n),r},e.prototype.driver=function(){return this._driver||null},e.prototype.getDriver=function(t,e,r){var i=this,u=function(){if(o(t))switch(t){case i.INDEXEDDB:return new Promise(function(t){t(n(1))});case i.LOCALSTORAGE:return new Promise(function(t){t(n(2))});case i.WEBSQL:return new Promise(function(t){t(n(4))})}else if(a[t])return Promise.resolve(a[t]);return Promise.reject(new Error("Driver not found."))}();return u.then(e,r),u},e.prototype.getSerializer=function(t){var e=new Promise(function(t){t(n(3))});return t&&"function"==typeof t&&e.then(function(e){t(e)}),e},e.prototype.ready=function(t){var e=this,n=e._driverSet.then(function(){return null===e._ready&&(e._ready=e._initDriver()),e._ready});return n.then(t,t),n},e.prototype.setDriver=function(t,e,n){function r(){o._config.driver=o.driver()}function i(t){return function(){function e(){for(;n<t.length;){var i=t[n];return n++,o._dbInfo=null,o._ready=null,o.getDriver(i).then(function(t){return o._extend(t),r(),o._ready=o._initStorage(o._config),o._ready})["catch"](e)}r();var a=new Error("No available storage method found.");return o._driverSet=Promise.reject(a),o._driverSet}var n=0;return e()}}var o=this;h(t)||(t=[t]);var a=this._getSupportedDrivers(t),u=null!==this._driverSet?this._driverSet["catch"](function(){return Promise.resolve()}):Promise.resolve();return this._driverSet=u.then(function(){var t=a[0];return o._dbInfo=null,o._ready=null,o.getDriver(t).then(function(t){o._driver=t._driver,r(),o._wrapLibraryMethodsWithReady(),o._initDriver=i(a)})})["catch"](function(){r();var t=new Error("No available storage method found.");return o._driverSet=Promise.reject(t),o._driverSet}),this._driverSet.then(e,n),this._driverSet},e.prototype.supports=function(t){return!!l[t]},e.prototype._extend=function(t){i(this,t)},e.prototype._getSupportedDrivers=function(t){for(var e=[],n=0,r=t.length;r>n;n++){var i=t[n];this.supports(i)&&e.push(i)}return e},e.prototype._wrapLibraryMethodsWithReady=function(){for(var e=0;e<c.length;e++)t(this,c[e])},e.prototype.createInstance=function(t){return new e(t)},e}(),d=new p;e["default"]=d}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e){"use strict";e.__esModule=!0,function(){function t(t,e){t=t||[],e=e||{};try{return new Blob(t,e)}catch(n){if("TypeError"!==n.name)throw n;for(var r=x.BlobBuilder||x.MSBlobBuilder||x.MozBlobBuilder||x.WebKitBlobBuilder,i=new r,o=0;o<t.length;o+=1)i.append(t[o]);return i.getBlob(e.type)}}function n(t){for(var e=t.length,n=new ArrayBuffer(e),r=new Uint8Array(n),i=0;e>i;i++)r[i]=t.charCodeAt(i);return n}function r(t){return new Promise(function(e,n){var r=new XMLHttpRequest;r.open("GET",t),r.withCredentials=!0,r.responseType="arraybuffer",r.onreadystatechange=function(){return 4===r.readyState?200===r.status?e({response:r.response,type:r.getResponseHeader("Content-Type")}):(n({status:r.status,response:r.response}),void 0):void 0},r.send()})}function i(e){return new Promise(function(n,i){var o=t([""],{type:"image/png"}),a=e.transaction([S],"readwrite");a.objectStore(S).put(o,"key"),a.oncomplete=function(){var t=e.transaction([S],"readwrite"),o=t.objectStore(S).get("key");o.onerror=i,o.onsuccess=function(t){var e=t.target.result,i=URL.createObjectURL(e);r(i).then(function(t){n(!(!t||"image/png"!==t.type))},function(){n(!1)}).then(function(){URL.revokeObjectURL(i)})}}})["catch"](function(){return!1})}function o(t){return"boolean"==typeof A?Promise.resolve(A):i(t).then(function(t){return A=t})}function a(t){return new Promise(function(e,n){var r=new FileReader;r.onerror=n,r.onloadend=function(n){var r=btoa(n.target.result||"");e({__local_forage_encoded_blob:!0,data:r,type:t.type})},r.readAsBinaryString(t)})}function u(e){var r=n(atob(e.data));return t([r],{type:e.type})}function s(t){return t&&t.__local_forage_encoded_blob}function c(t){function e(){return Promise.resolve()}var n=this,r={db:null};if(t)for(var i in t)r[i]=t[i];O||(O={});var o=O[r.name];o||(o={forages:[],db:null},O[r.name]=o),o.forages.push(this);for(var a=[],u=0;u<o.forages.length;u++){var s=o.forages[u];s!==this&&a.push(s.ready()["catch"](e))}var c=o.forages.slice(0);return Promise.all(a).then(function(){return r.db=o.db,f(r)}).then(function(t){return r.db=t,p(r,n._defaultConfig.version)?l(r):t}).then(function(t){r.db=o.db=t,n._dbInfo=r;for(var e in c){var i=c[e];i!==n&&(i._dbInfo.db=r.db,i._dbInfo.version=r.version)}})}function f(t){return h(t,!1)}function l(t){return h(t,!0)}function h(t,e){return new Promise(function(n,r){if(t.db){if(!e)return n(t.db);t.db.close()}var i=[t.name];e&&i.push(t.version);var o=E.open.apply(E,i);e&&(o.onupgradeneeded=function(e){var n=o.result;try{n.createObjectStore(t.storeName),e.oldVersion<=1&&n.createObjectStore(S)}catch(r){if("ConstraintError"!==r.name)throw r;x.console.warn('The database "'+t.name+'"'+" has been upgraded from version "+e.oldVersion+" to version "+e.newVersion+', but the storage "'+t.storeName+'" already exists.')}}),o.onerror=function(){r(o.error)},o.onsuccess=function(){n(o.result)}})}function p(t,e){if(!t.db)return!0;var n=!t.db.objectStoreNames.contains(t.storeName),r=t.version<t.db.version,i=t.version>t.db.version;if(r&&(t.version!==e&&x.console.warn('The database "'+t.name+'"'+" can't be downgraded from version "+t.db.version+" to version "+t.version+"."),t.version=t.db.version),i||n){if(n){var o=t.db.version+1;o>t.version&&(t.version=o)}return!0}return!1}function d(t,e){var n=this;"string"!=typeof t&&(x.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readonly").objectStore(i.storeName),a=o.get(t);a.onsuccess=function(){var t=a.result;void 0===t&&(t=null),s(t)&&(t=u(t)),e(t)},a.onerror=function(){r(a.error)}})["catch"](r)});return k(r,e),r}function y(t,e){var n=this,r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readonly").objectStore(i.storeName),a=o.openCursor(),c=1;a.onsuccess=function(){var n=a.result;if(n){var r=n.value;s(r)&&(r=u(r));var i=t(r,n.key,c++);void 0!==i?e(i):n["continue"]()}else e()},a.onerror=function(){r(a.error)}})["catch"](r)});return k(r,e),r}function v(t,e,n){var r=this;"string"!=typeof t&&(x.console.warn(t+" used as a key, but it is not a string."),t=String(t));var i=new Promise(function(n,i){var u;r.ready().then(function(){return u=r._dbInfo,o(u.db)}).then(function(t){return!t&&e instanceof Blob?a(e):e}).then(function(e){var r=u.db.transaction(u.storeName,"readwrite"),o=r.objectStore(u.storeName);null===e&&(e=void 0);var a=o.put(e,t);r.oncomplete=function(){void 0===e&&(e=null),n(e)},r.onabort=r.onerror=function(){var t=a.error?a.error:a.transaction.error;i(t)}})["catch"](i)});return k(i,n),i}function g(t,e){var n=this;"string"!=typeof t&&(x.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readwrite"),a=o.objectStore(i.storeName),u=a["delete"](t);o.oncomplete=function(){e()},o.onerror=function(){r(u.error)},o.onabort=function(){var t=u.error?u.error:u.transaction.error;r(t)}})["catch"](r)});return k(r,e),r}function m(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo,i=r.db.transaction(r.storeName,"readwrite"),o=i.objectStore(r.storeName),a=o.clear();i.oncomplete=function(){t()},i.onabort=i.onerror=function(){var t=a.error?a.error:a.transaction.error;n(t)}})["catch"](n)});return k(n,t),n}function b(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo,i=r.db.transaction(r.storeName,"readonly").objectStore(r.storeName),o=i.count();o.onsuccess=function(){t(o.result)},o.onerror=function(){n(o.error)}})["catch"](n)});return k(n,t),n}function w(t,e){var n=this,r=new Promise(function(e,r){return 0>t?(e(null),void 0):(n.ready().then(function(){var i=n._dbInfo,o=i.db.transaction(i.storeName,"readonly").objectStore(i.storeName),a=!1,u=o.openCursor();u.onsuccess=function(){var n=u.result;return n?(0===t?e(n.key):a?e(n.key):(a=!0,n.advance(t)),void 0):(e(null),void 0)},u.onerror=function(){r(u.error)}})["catch"](r),void 0)});return k(r,e),r}function _(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo,i=r.db.transaction(r.storeName,"readonly").objectStore(r.storeName),o=i.openCursor(),a=[];o.onsuccess=function(){var e=o.result;return e?(a.push(e.key),e["continue"](),void 0):(t(a),void 0)},o.onerror=function(){n(o.error)}})["catch"](n)});return k(n,t),n}function k(t,e){e&&t.then(function(t){e(null,t)},function(t){e(t)})}var x=this,E=E||this.indexedDB||this.webkitIndexedDB||this.mozIndexedDB||this.OIndexedDB||this.msIndexedDB;if(E){var A,O,S="local-forage-detect-blob-support",j={_driver:"asyncStorage",_initStorage:c,iterate:y,getItem:d,setItem:v,removeItem:g,clear:m,length:b,key:w,keys:_};e["default"]=j}}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e,n){"use strict";e.__esModule=!0,function(){function t(t){var e=this,r={};if(t)for(var i in t)r[i]=t[i];return r.keyPrefix=r.name+"/",r.storeName!==e._defaultConfig.storeName&&(r.keyPrefix+=r.storeName+"/"),e._dbInfo=r,new Promise(function(t){t(n(3))}).then(function(t){return r.serializer=t,Promise.resolve()})}function r(t){var e=this,n=e.ready().then(function(){for(var t=e._dbInfo.keyPrefix,n=p.length-1;n>=0;n--){var r=p.key(n);0===r.indexOf(t)&&p.removeItem(r)}});return l(n,t),n}function i(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=n.ready().then(function(){var e=n._dbInfo,r=p.getItem(e.keyPrefix+t);return r&&(r=e.serializer.deserialize(r)),r});return l(r,e),r}function o(t,e){var n=this,r=n.ready().then(function(){for(var e=n._dbInfo,r=e.keyPrefix,i=r.length,o=p.length,a=1,u=0;o>u;u++){var s=p.key(u);if(0===s.indexOf(r)){var c=p.getItem(s);if(c&&(c=e.serializer.deserialize(c)),c=t(c,s.substring(i),a++),void 0!==c)return c}}});return l(r,e),r}function a(t,e){var n=this,r=n.ready().then(function(){var e,r=n._dbInfo;try{e=p.key(t)}catch(i){e=null}return e&&(e=e.substring(r.keyPrefix.length)),e});return l(r,e),r}function u(t){var e=this,n=e.ready().then(function(){for(var t=e._dbInfo,n=p.length,r=[],i=0;n>i;i++)0===p.key(i).indexOf(t.keyPrefix)&&r.push(p.key(i).substring(t.keyPrefix.length));return r});return l(n,t),n}function s(t){var e=this,n=e.keys().then(function(t){return t.length});return l(n,t),n}function c(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=n.ready().then(function(){var e=n._dbInfo;p.removeItem(e.keyPrefix+t)});return l(r,e),r}function f(t,e,n){var r=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var i=r.ready().then(function(){void 0===e&&(e=null);var n=e;return new Promise(function(i,o){var a=r._dbInfo;a.serializer.serialize(e,function(e,r){if(r)o(r);else try{p.setItem(a.keyPrefix+t,e),i(n)}catch(u){("QuotaExceededError"===u.name||"NS_ERROR_DOM_QUOTA_REACHED"===u.name)&&o(u),o(u)}})})});return l(i,n),i}function l(t,e){e&&t.then(function(t){e(null,t)},function(t){e(t)})}var h=this,p=null;try{if(!(this.localStorage&&"setItem"in this.localStorage))return;p=this.localStorage}catch(d){return}var y={_driver:"localStorageWrapper",_initStorage:t,iterate:o,getItem:i,setItem:f,removeItem:c,clear:r,length:s,key:a,keys:u};e["default"]=y}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e){"use strict";e.__esModule=!0,function(){function t(t,e){t=t||[],e=e||{};try{return new Blob(t,e)}catch(n){if("TypeError"!==n.name)throw n;for(var r=x.BlobBuilder||x.MSBlobBuilder||x.MozBlobBuilder||x.WebKitBlobBuilder,i=new r,o=0;o<t.length;o+=1)i.append(t[o]);return i.getBlob(e.type)}}function n(t,e){var n="";if(t&&(n=t.toString()),t&&("[object ArrayBuffer]"===t.toString()||t.buffer&&"[object ArrayBuffer]"===t.buffer.toString())){var r,i=c;t instanceof ArrayBuffer?(r=t,i+=l):(r=t.buffer,"[object Int8Array]"===n?i+=p:"[object Uint8Array]"===n?i+=d:"[object Uint8ClampedArray]"===n?i+=y:"[object Int16Array]"===n?i+=v:"[object Uint16Array]"===n?i+=m:"[object Int32Array]"===n?i+=g:"[object Uint32Array]"===n?i+=b:"[object Float32Array]"===n?i+=w:"[object Float64Array]"===n?i+=_:e(new Error("Failed to get type for BinaryArray"))),e(i+o(r))}else if("[object Blob]"===n){var a=new FileReader;a.onload=function(){var n=u+t.type+"~"+o(this.result);e(c+h+n)},a.readAsArrayBuffer(t)}else try{e(JSON.stringify(t))}catch(s){console.error("Couldn't convert value into a JSON string: ",t),e(null,s)}}function r(e){if(e.substring(0,f)!==c)return JSON.parse(e);var n,r=e.substring(k),o=e.substring(f,k);if(o===h&&s.test(r)){var a=r.match(s);n=a[1],r=r.substring(a[0].length)}var u=i(r);switch(o){case l:return u;case h:return t([u],{type:n});case p:return new Int8Array(u);case d:return new Uint8Array(u);case y:return new Uint8ClampedArray(u);case v:return new Int16Array(u);case m:return new Uint16Array(u);case g:return new Int32Array(u);case b:return new Uint32Array(u);case w:return new Float32Array(u);case _:return new Float64Array(u);default:throw new Error("Unkown type: "+o)}}function i(t){var e,n,r,i,o,u=.75*t.length,s=t.length,c=0;"="===t[t.length-1]&&(u--,"="===t[t.length-2]&&u--);var f=new ArrayBuffer(u),l=new Uint8Array(f);for(e=0;s>e;e+=4)n=a.indexOf(t[e]),r=a.indexOf(t[e+1]),i=a.indexOf(t[e+2]),o=a.indexOf(t[e+3]),l[c++]=n<<2|r>>4,l[c++]=(15&r)<<4|i>>2,l[c++]=(3&i)<<6|63&o;return f}function o(t){var e,n=new Uint8Array(t),r="";for(e=0;e<n.length;e+=3)r+=a[n[e]>>2],r+=a[(3&n[e])<<4|n[e+1]>>4],r+=a[(15&n[e+1])<<2|n[e+2]>>6],r+=a[63&n[e+2]];return 2===n.length%3?r=r.substring(0,r.length-1)+"=":1===n.length%3&&(r=r.substring(0,r.length-2)+"=="),r}var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",u="~~local_forage_type~",s=/^~~local_forage_type~([^~]+)~/,c="__lfsc__:",f=c.length,l="arbf",h="blob",p="si08",d="ui08",y="uic8",v="si16",g="si32",m="ur16",b="ui32",w="fl32",_="fl64",k=f+l.length,x=this,E={serialize:n,deserialize:r,stringToBuffer:i,bufferToString:o};e["default"]=E}.call("undefined"!=typeof window?window:self),t.exports=e["default"]},function(t,e,n){"use strict";e.__esModule=!0,function(){function t(t){var e=this,r={db:null};if(t)for(var i in t)r[i]="string"!=typeof t[i]?t[i].toString():t[i];var o=new Promise(function(n,i){try{r.db=p(r.name,String(r.version),r.description,r.size)}catch(o){return e.setDriver(e.LOCALSTORAGE).then(function(){return e._initStorage(t)}).then(n)["catch"](i)}r.db.transaction(function(t){t.executeSql("CREATE TABLE IF NOT EXISTS "+r.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],function(){e._dbInfo=r,n()},function(t,e){i(e)})})});return new Promise(function(t){t(n(3))}).then(function(t){return r.serializer=t,o})}function r(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("SELECT * FROM "+i.storeName+" WHERE key = ? LIMIT 1",[t],function(t,n){var r=n.rows.length?n.rows.item(0).value:null;r&&(r=i.serializer.deserialize(r)),e(r)},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function i(t,e){var n=this,r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("SELECT * FROM "+i.storeName,[],function(n,r){for(var o=r.rows,a=o.length,u=0;a>u;u++){var s=o.item(u),c=s.value;if(c&&(c=i.serializer.deserialize(c)),c=t(c,s.key,u+1),void 0!==c)return e(c),void 0}e()},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function o(t,e,n){var r=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var i=new Promise(function(n,i){r.ready().then(function(){void 0===e&&(e=null);var o=e,a=r._dbInfo;a.serializer.serialize(e,function(e,r){r?i(r):a.db.transaction(function(r){r.executeSql("INSERT OR REPLACE INTO "+a.storeName+" (key, value) VALUES (?, ?)",[t,e],function(){n(o)},function(t,e){i(e)})},function(t){t.code===t.QUOTA_ERR&&i(t)})})})["catch"](i)});return l(i,n),i}function a(t,e){var n=this;"string"!=typeof t&&(h.console.warn(t+" used as a key, but it is not a string."),t=String(t));var r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("DELETE FROM "+i.storeName+" WHERE key = ?",[t],function(){e()},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function u(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo;r.db.transaction(function(e){e.executeSql("DELETE FROM "+r.storeName,[],function(){t()},function(t,e){n(e)})})})["catch"](n)});return l(n,t),n}function s(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo;r.db.transaction(function(e){e.executeSql("SELECT COUNT(key) as c FROM "+r.storeName,[],function(e,n){var r=n.rows.item(0).c;t(r)},function(t,e){n(e)})})})["catch"](n)});return l(n,t),n}function c(t,e){var n=this,r=new Promise(function(e,r){n.ready().then(function(){var i=n._dbInfo;i.db.transaction(function(n){n.executeSql("SELECT key FROM "+i.storeName+" WHERE id = ? LIMIT 1",[t+1],function(t,n){var r=n.rows.length?n.rows.item(0).key:null;e(r)},function(t,e){r(e)})})})["catch"](r)});return l(r,e),r}function f(t){var e=this,n=new Promise(function(t,n){e.ready().then(function(){var r=e._dbInfo;r.db.transaction(function(e){e.executeSql("SELECT key FROM "+r.storeName,[],function(e,n){for(var r=[],i=0;i<n.rows.length;i++)r.push(n.rows.item(i).key);t(r)},function(t,e){n(e)})})})["catch"](n)});return l(n,t),n}function l(t,e){e&&t.then(function(t){e(null,t)},function(t){e(t)})}var h=this,p=this.openDatabase;if(p){var d={_driver:"webSQLStorage",_initStorage:t,iterate:i,getItem:r,setItem:o,removeItem:a,clear:u,length:s,key:c,keys:f};e["default"]=d}}.call("undefined"!=typeof window?window:self),t.exports=e["default"]}])})},{__browserify_process:4}],19:[function(t,e,n){!function(){var t=this,r=t._,i={},o=Array.prototype,a=Object.prototype,u=Function.prototype,s=o.push,c=o.slice,f=o.concat,l=a.toString,h=a.hasOwnProperty,p=o.forEach,d=o.map,y=o.reduce,v=o.reduceRight,g=o.filter,m=o.every,b=o.some,w=o.indexOf,_=o.lastIndexOf,k=Array.isArray,x=Object.keys,E=u.bind,A=function(t){return t instanceof A?t:this instanceof A?(this._wrapped=t,void 0):new A(t)};"undefined"!=typeof n?("undefined"!=typeof e&&e.exports&&(n=e.exports=A),n._=A):t._=A,A.VERSION="1.4.4";var O=A.each=A.forEach=function(t,e,n){if(null!=t)if(p&&t.forEach===p)t.forEach(e,n);else if(t.length===+t.length){for(var r=0,o=t.length;o>r;r++)if(e.call(n,t[r],r,t)===i)return}else for(var a in t)if(A.has(t,a)&&e.call(n,t[a],a,t)===i)return};A.map=A.collect=function(t,e,n){var r=[];return null==t?r:d&&t.map===d?t.map(e,n):(O(t,function(t,i,o){r[r.length]=e.call(n,t,i,o)}),r)};var S="Reduce of empty array with no initial value";A.reduce=A.foldl=A.inject=function(t,e,n,r){var i=arguments.length>2;if(null==t&&(t=[]),y&&t.reduce===y)return r&&(e=A.bind(e,r)),i?t.reduce(e,n):t.reduce(e);if(O(t,function(t,o,a){i?n=e.call(r,n,t,o,a):(n=t,i=!0)}),!i)throw new TypeError(S);return n},A.reduceRight=A.foldr=function(t,e,n,r){var i=arguments.length>2;if(null==t&&(t=[]),v&&t.reduceRight===v)return r&&(e=A.bind(e,r)),i?t.reduceRight(e,n):t.reduceRight(e);var o=t.length;if(o!==+o){var a=A.keys(t);o=a.length}if(O(t,function(u,s,c){s=a?a[--o]:--o,i?n=e.call(r,n,t[s],s,c):(n=t[s],i=!0)}),!i)throw new TypeError(S);return n},A.find=A.detect=function(t,e,n){var r;return j(t,function(t,i,o){return e.call(n,t,i,o)?(r=t,!0):void 0}),r},A.filter=A.select=function(t,e,n){var r=[];return null==t?r:g&&t.filter===g?t.filter(e,n):(O(t,function(t,i,o){e.call(n,t,i,o)&&(r[r.length]=t)}),r)},A.reject=function(t,e,n){return A.filter(t,function(t,r,i){return!e.call(n,t,r,i)},n)},A.every=A.all=function(t,e,n){e||(e=A.identity);var r=!0;return null==t?r:m&&t.every===m?t.every(e,n):(O(t,function(t,o,a){return(r=r&&e.call(n,t,o,a))?void 0:i}),!!r)};var j=A.some=A.any=function(t,e,n){e||(e=A.identity);var r=!1;return null==t?r:b&&t.some===b?t.some(e,n):(O(t,function(t,o,a){return r||(r=e.call(n,t,o,a))?i:void 0}),!!r)};A.contains=A.include=function(t,e){return null==t?!1:w&&t.indexOf===w?-1!=t.indexOf(e):j(t,function(t){return t===e})},A.invoke=function(t,e){var n=c.call(arguments,2),r=A.isFunction(e);return A.map(t,function(t){return(r?e:t[e]).apply(t,n)})},A.pluck=function(t,e){return A.map(t,function(t){return t[e]})},A.where=function(t,e,n){return A.isEmpty(e)?n?null:[]:A[n?"find":"filter"](t,function(t){for(var n in e)if(e[n]!==t[n])return!1;return!0})},A.findWhere=function(t,e){return A.where(t,e,!0)},A.max=function(t,e,n){if(!e&&A.isArray(t)&&t[0]===+t[0]&&t.length<65535)return Math.max.apply(Math,t);if(!e&&A.isEmpty(t))return-1/0;var r={computed:-1/0,value:-1/0};return O(t,function(t,i,o){var a=e?e.call(n,t,i,o):t;a>=r.computed&&(r={value:t,computed:a})}),r.value},A.min=function(t,e,n){if(!e&&A.isArray(t)&&t[0]===+t[0]&&t.length<65535)return Math.min.apply(Math,t);if(!e&&A.isEmpty(t))return 1/0;var r={computed:1/0,value:1/0};return O(t,function(t,i,o){var a=e?e.call(n,t,i,o):t;a<r.computed&&(r={value:t,computed:a})}),r.value},A.shuffle=function(t){var e,n=0,r=[];return O(t,function(t){e=A.random(n++),r[n-1]=r[e],r[e]=t}),r};var I=function(t){return A.isFunction(t)?t:function(e){return e[t]}};A.sortBy=function(t,e,n){var r=I(e);return A.pluck(A.map(t,function(t,e,i){return{value:t,index:e,criteria:r.call(n,t,e,i)}}).sort(function(t,e){var n=t.criteria,r=e.criteria;if(n!==r){if(n>r||void 0===n)return 1;if(r>n||void 0===r)return-1}return t.index<e.index?-1:1}),"value")};var D=function(t,e,n,r){var i={},o=I(e||A.identity);return O(t,function(e,a){var u=o.call(n,e,a,t);r(i,u,e)}),i};A.groupBy=function(t,e,n){return D(t,e,n,function(t,e,n){(A.has(t,e)?t[e]:t[e]=[]).push(n)})},A.countBy=function(t,e,n){return D(t,e,n,function(t,e){A.has(t,e)||(t[e]=0),t[e]++})},A.sortedIndex=function(t,e,n,r){n=null==n?A.identity:I(n);for(var i=n.call(r,e),o=0,a=t.length;a>o;){var u=o+a>>>1;n.call(r,t[u])<i?o=u+1:a=u}return o},A.toArray=function(t){return t?A.isArray(t)?c.call(t):t.length===+t.length?A.map(t,A.identity):A.values(t):[]},A.size=function(t){return null==t?0:t.length===+t.length?t.length:A.keys(t).length},A.first=A.head=A.take=function(t,e,n){return null==t?void 0:null==e||n?t[0]:c.call(t,0,e)},A.initial=function(t,e,n){return c.call(t,0,t.length-(null==e||n?1:e))},A.last=function(t,e,n){return null==t?void 0:null==e||n?t[t.length-1]:c.call(t,Math.max(t.length-e,0))},A.rest=A.tail=A.drop=function(t,e,n){return c.call(t,null==e||n?1:e)},A.compact=function(t){return A.filter(t,A.identity)};var $=function(t,e,n){return O(t,function(t){A.isArray(t)?e?s.apply(n,t):$(t,e,n):n.push(t)}),n};A.flatten=function(t,e){return $(t,e,[])},A.without=function(t){return A.difference(t,c.call(arguments,1))},A.uniq=A.unique=function(t,e,n,r){A.isFunction(e)&&(r=n,n=e,e=!1);var i=n?A.map(t,n,r):t,o=[],a=[];return O(i,function(n,r){(e?r&&a[a.length-1]===n:A.contains(a,n))||(a.push(n),o.push(t[r]))}),o},A.union=function(){return A.uniq(f.apply(o,arguments))},A.intersection=function(t){var e=c.call(arguments,1);return A.filter(A.uniq(t),function(t){return A.every(e,function(e){return A.indexOf(e,t)>=0})})},A.difference=function(t){var e=f.apply(o,c.call(arguments,1));return A.filter(t,function(t){return!A.contains(e,t)})},A.zip=function(){for(var t=c.call(arguments),e=A.max(A.pluck(t,"length")),n=new Array(e),r=0;e>r;r++)n[r]=A.pluck(t,""+r);return n},A.object=function(t,e){if(null==t)return{};for(var n={},r=0,i=t.length;i>r;r++)e?n[t[r]]=e[r]:n[t[r][0]]=t[r][1];return n},A.indexOf=function(t,e,n){if(null==t)return-1;var r=0,i=t.length;if(n){if("number"!=typeof n)return r=A.sortedIndex(t,e),t[r]===e?r:-1;r=0>n?Math.max(0,i+n):n}if(w&&t.indexOf===w)return t.indexOf(e,n);for(;i>r;r++)if(t[r]===e)return r;return-1},A.lastIndexOf=function(t,e,n){if(null==t)return-1;var r=null!=n;if(_&&t.lastIndexOf===_)return r?t.lastIndexOf(e,n):t.lastIndexOf(e);for(var i=r?n:t.length;i--;)if(t[i]===e)return i;return-1},A.range=function(t,e,n){arguments.length<=1&&(e=t||0,t=0),n=arguments[2]||1;for(var r=Math.max(Math.ceil((e-t)/n),0),i=0,o=new Array(r);r>i;)o[i++]=t,t+=n;return o},A.bind=function(t,e){if(t.bind===E&&E)return E.apply(t,c.call(arguments,1));var n=c.call(arguments,2);return function(){return t.apply(e,n.concat(c.call(arguments)))}},A.partial=function(t){var e=c.call(arguments,1);return function(){return t.apply(this,e.concat(c.call(arguments)))}},A.bindAll=function(t){var e=c.call(arguments,1);return 0===e.length&&(e=A.functions(t)),O(e,function(e){t[e]=A.bind(t[e],t)}),t},A.memoize=function(t,e){var n={};return e||(e=A.identity),function(){var r=e.apply(this,arguments);return A.has(n,r)?n[r]:n[r]=t.apply(this,arguments)}},A.delay=function(t,e){var n=c.call(arguments,2);return setTimeout(function(){return t.apply(null,n)},e)},A.defer=function(t){return A.delay.apply(A,[t,1].concat(c.call(arguments,1)))},A.throttle=function(t,e){var n,r,i,o,a=0,u=function(){a=new Date,i=null,o=t.apply(n,r)};return function(){var s=new Date,c=e-(s-a);return n=this,r=arguments,0>=c?(clearTimeout(i),i=null,a=s,o=t.apply(n,r)):i||(i=setTimeout(u,c)),o}},A.debounce=function(t,e,n){var r,i;return function(){var o=this,a=arguments,u=function(){r=null,n||(i=t.apply(o,a))},s=n&&!r;return clearTimeout(r),r=setTimeout(u,e),s&&(i=t.apply(o,a)),i}},A.once=function(t){var e,n=!1;return function(){return n?e:(n=!0,e=t.apply(this,arguments),t=null,e)}},A.wrap=function(t,e){return function(){var n=[t];return s.apply(n,arguments),e.apply(this,n)}},A.compose=function(){var t=arguments;return function(){for(var e=arguments,n=t.length-1;n>=0;n--)e=[t[n].apply(this,e)];return e[0]}},A.after=function(t,e){return 0>=t?e():function(){return--t<1?e.apply(this,arguments):void 0}},A.keys=x||function(t){if(t!==Object(t))throw new TypeError("Invalid object");var e=[];for(var n in t)A.has(t,n)&&(e[e.length]=n);return e},A.values=function(t){var e=[];for(var n in t)A.has(t,n)&&e.push(t[n]);return e},A.pairs=function(t){var e=[];for(var n in t)A.has(t,n)&&e.push([n,t[n]]);return e},A.invert=function(t){var e={};for(var n in t)A.has(t,n)&&(e[t[n]]=n);return e},A.functions=A.methods=function(t){var e=[];for(var n in t)A.isFunction(t[n])&&e.push(n);return e.sort()},A.extend=function(t){return O(c.call(arguments,1),function(e){if(e)for(var n in e)t[n]=e[n]}),t},A.pick=function(t){var e={},n=f.apply(o,c.call(arguments,1));return O(n,function(n){n in t&&(e[n]=t[n])}),e},A.omit=function(t){var e={},n=f.apply(o,c.call(arguments,1));for(var r in t)A.contains(n,r)||(e[r]=t[r]);return e},A.defaults=function(t){return O(c.call(arguments,1),function(e){if(e)for(var n in e)null==t[n]&&(t[n]=e[n])}),t},A.clone=function(t){return A.isObject(t)?A.isArray(t)?t.slice():A.extend({},t):t},A.tap=function(t,e){return e(t),t};var N=function(t,e,n,r){if(t===e)return 0!==t||1/t==1/e;if(null==t||null==e)return t===e;t instanceof A&&(t=t._wrapped),e instanceof A&&(e=e._wrapped);var i=l.call(t);if(i!=l.call(e))return!1;switch(i){case"[object String]":return t==String(e);case"[object Number]":return t!=+t?e!=+e:0==t?1/t==1/e:t==+e;case"[object Date]":case"[object Boolean]":return+t==+e;case"[object RegExp]":return t.source==e.source&&t.global==e.global&&t.multiline==e.multiline&&t.ignoreCase==e.ignoreCase}if("object"!=typeof t||"object"!=typeof e)return!1;for(var o=n.length;o--;)if(n[o]==t)return r[o]==e;n.push(t),r.push(e);var a=0,u=!0;if("[object Array]"==i){if(a=t.length,u=a==e.length)for(;a--&&(u=N(t[a],e[a],n,r)););}else{var s=t.constructor,c=e.constructor;if(s!==c&&!(A.isFunction(s)&&s instanceof s&&A.isFunction(c)&&c instanceof c))return!1;for(var f in t)if(A.has(t,f)&&(a++,!(u=A.has(e,f)&&N(t[f],e[f],n,r))))break;if(u){for(f in e)if(A.has(e,f)&&!a--)break;u=!a}}return n.pop(),r.pop(),u};A.isEqual=function(t,e){return N(t,e,[],[])},A.isEmpty=function(t){if(null==t)return!0;if(A.isArray(t)||A.isString(t))return 0===t.length;for(var e in t)if(A.has(t,e))return!1;return!0},A.isElement=function(t){return!(!t||1!==t.nodeType)},A.isArray=k||function(t){return"[object Array]"==l.call(t)},A.isObject=function(t){return t===Object(t)},O(["Arguments","Function","String","Number","Date","RegExp"],function(t){A["is"+t]=function(e){return l.call(e)=="[object "+t+"]"}}),A.isArguments(arguments)||(A.isArguments=function(t){return!(!t||!A.has(t,"callee"))}),"function"!=typeof/./&&(A.isFunction=function(t){return"function"==typeof t}),A.isFinite=function(t){return isFinite(t)&&!isNaN(parseFloat(t))},A.isNaN=function(t){return A.isNumber(t)&&t!=+t},A.isBoolean=function(t){return t===!0||t===!1||"[object Boolean]"==l.call(t)},A.isNull=function(t){return null===t},A.isUndefined=function(t){return void 0===t},A.has=function(t,e){return h.call(t,e)},A.noConflict=function(){return t._=r,this},A.identity=function(t){return t},A.times=function(t,e,n){for(var r=Array(t),i=0;t>i;i++)r[i]=e.call(n,i);return r},A.random=function(t,e){return null==e&&(e=t,t=0),t+Math.floor(Math.random()*(e-t+1))
+};var P={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};P.unescape=A.invert(P.escape);var T={escape:new RegExp("["+A.keys(P.escape).join("")+"]","g"),unescape:new RegExp("("+A.keys(P.unescape).join("|")+")","g")};A.each(["escape","unescape"],function(t){A[t]=function(e){return null==e?"":(""+e).replace(T[t],function(e){return P[t][e]})}}),A.result=function(t,e){if(null==t)return null;var n=t[e];return A.isFunction(n)?n.call(t):n},A.mixin=function(t){O(A.functions(t),function(e){var n=A[e]=t[e];A.prototype[e]=function(){var t=[this._wrapped];return s.apply(t,arguments),R.call(this,n.apply(A,t))}})};var C=0;A.uniqueId=function(t){var e=++C+"";return t?t+e:e},A.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var M=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},F=/\\|'|\r|\n|\t|\u2028|\u2029/g;A.template=function(t,e,n){var r;n=A.defaults({},n,A.templateSettings);var i=new RegExp([(n.escape||M).source,(n.interpolate||M).source,(n.evaluate||M).source].join("|")+"|$","g"),o=0,a="__p+='";t.replace(i,function(e,n,r,i,u){return a+=t.slice(o,u).replace(F,function(t){return"\\"+B[t]}),n&&(a+="'+\n((__t=("+n+"))==null?'':_.escape(__t))+\n'"),r&&(a+="'+\n((__t=("+r+"))==null?'':__t)+\n'"),i&&(a+="';\n"+i+"\n__p+='"),o=u+e.length,e}),a+="';\n",n.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{r=new Function(n.variable||"obj","_",a)}catch(u){throw u.source=a,u}if(e)return r(e,A);var s=function(t){return r.call(this,t,A)};return s.source="function("+(n.variable||"obj")+"){\n"+a+"}",s},A.chain=function(t){return A(t).chain()};var R=function(t){return this._chain?A(t).chain():t};A.mixin(A),O(["pop","push","reverse","shift","sort","splice","unshift"],function(t){var e=o[t];A.prototype[t]=function(){var n=this._wrapped;return e.apply(n,arguments),"shift"!=t&&"splice"!=t||0!==n.length||delete n[0],R.call(this,n)}}),O(["concat","join","slice"],function(t){var e=o[t];A.prototype[t]=function(){return R.call(this,e.apply(this._wrapped,arguments))}}),A.extend(A.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}.call(this)},{}]},{},[7])(7)});
\ No newline at end of file
diff --git a/browser-version/package-lock.json b/browser-version/package-lock.json
deleted file mode 100644
index a2d8f81..0000000
--- a/browser-version/package-lock.json
+++ /dev/null
@@ -1,629 +0,0 @@
-{
-  "requires": true,
-  "lockfileVersion": 1,
-  "dependencies": {
-    "Base64": {
-      "version": "0.1.4",
-      "resolved": "https://registry.npmjs.org/Base64/-/Base64-0.1.4.tgz",
-      "integrity": "sha1-6fbGvvVn/WNepBYqsU3TKedKpt4="
-    },
-    "JSONStream": {
-      "version": "0.6.4",
-      "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-0.6.4.tgz",
-      "integrity": "sha1-SyyAY/j1Enh7I3X37p22kgj6Lcs=",
-      "requires": {
-        "jsonparse": "0.0.5",
-        "through": "~2.2.7"
-      },
-      "dependencies": {
-        "through": {
-          "version": "2.2.7",
-          "resolved": "https://registry.npmjs.org/through/-/through-2.2.7.tgz",
-          "integrity": "sha1-bo4hIAGR1OtqmfbwEN9Gqhxusr0="
-        }
-      }
-    },
-    "amdefine": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/amdefine/-/amdefine-1.0.1.tgz",
-      "integrity": "sha1-SlKCrBZHKek2Gbz9OtFR+BfOkfU="
-    },
-    "astw": {
-      "version": "0.0.0",
-      "resolved": "https://registry.npmjs.org/astw/-/astw-0.0.0.tgz",
-      "integrity": "sha1-RJCGaj7xFqr5GtumPKfd9wttWb0=",
-      "requires": {
-        "esprima": "1.0.2"
-      }
-    },
-    "async": {
-      "version": "0.2.10",
-      "resolved": "https://registry.npmjs.org/async/-/async-0.2.10.tgz",
-      "integrity": "sha1-trvgsGdLnXGXCMo43owjfLUmw9E="
-    },
-    "base64-js": {
-      "version": "0.0.2",
-      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-0.0.2.tgz",
-      "integrity": "sha1-Ak8Pcq+iW3X5wO5zzU9V7Bvtl4Q="
-    },
-    "bops": {
-      "version": "0.0.6",
-      "resolved": "https://registry.npmjs.org/bops/-/bops-0.0.6.tgz",
-      "integrity": "sha1-CC0dVfoB5g29wuvC26N/ZZVUzzo=",
-      "requires": {
-        "base64-js": "0.0.2",
-        "to-utf8": "0.0.1"
-      }
-    },
-    "browser-builtins": {
-      "version": "1.0.7",
-      "resolved": "https://registry.npmjs.org/browser-builtins/-/browser-builtins-1.0.7.tgz",
-      "integrity": "sha1-xU3/T/D9espBH8a8LW4B9UR+Y9M=",
-      "requires": {
-        "buffer-browserify": "0.1.x",
-        "console-browserify": "0.1.x",
-        "constants-browserify": "0.0.x",
-        "crypto-browserify": "1.0.x",
-        "http-browserify": "0.1.x",
-        "punycode": "1.2.x",
-        "resolve": "0.3.x",
-        "vm-browserify": "0.0.x",
-        "zlib-browserify": "0.0.x"
-      }
-    },
-    "browser-pack": {
-      "version": "0.9.4",
-      "resolved": "https://registry.npmjs.org/browser-pack/-/browser-pack-0.9.4.tgz",
-      "integrity": "sha1-yMycox894Gd/1UVJOvi97hS2Dxs=",
-      "requires": {
-        "JSONStream": "~0.6.4",
-        "combine-source-map": "~0.1.1",
-        "through": "~2.3.4"
-      }
-    },
-    "browser-resolve": {
-      "version": "1.1.4",
-      "resolved": "https://registry.npmjs.org/browser-resolve/-/browser-resolve-1.1.4.tgz",
-      "integrity": "sha1-/Ds5/7BgwonYZmiHC1EybfDnatw=",
-      "requires": {
-        "resolve": "0.5.1"
-      },
-      "dependencies": {
-        "resolve": {
-          "version": "0.5.1",
-          "resolved": "https://registry.npmjs.org/resolve/-/resolve-0.5.1.tgz",
-          "integrity": "sha1-FeSiIsQja81M+FRUQSwtD7ZSRXY="
-        }
-      }
-    },
-    "browserify": {
-      "version": "2.25.1",
-      "resolved": "https://registry.npmjs.org/browserify/-/browserify-2.25.1.tgz",
-      "integrity": "sha1-7sEaU9M4yvgcQU2FgXk/zCTVT7s=",
-      "requires": {
-        "JSONStream": "~0.6.4",
-        "browser-builtins": "~1.0.1",
-        "browser-pack": "~0.9.4",
-        "browser-resolve": "~1.1.0",
-        "concat-stream": "~1.0.0",
-        "deps-sort": "~0.1.1",
-        "duplexer": "~0.1.1",
-        "event-stream": "~3.0.15",
-        "inherits": "~1.0.0",
-        "insert-module-globals": "~1.2.0",
-        "module-deps": "~1.0.1",
-        "optimist": "~0.5.1",
-        "parents": "~0.0.1",
-        "shell-quote": "~0.0.1",
-        "syntax-error": "~0.0.0",
-        "through": "~2.3.4",
-        "umd": "~1.1.0"
-      }
-    },
-    "buffer-browserify": {
-      "version": "0.1.0",
-      "resolved": "https://registry.npmjs.org/buffer-browserify/-/buffer-browserify-0.1.0.tgz",
-      "integrity": "sha1-rirwPfaIaV+ja+BfWSyBoGMpjd8=",
-      "requires": {
-        "base64-js": "0.0.2"
-      }
-    },
-    "callsite": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/callsite/-/callsite-1.0.0.tgz",
-      "integrity": "sha1-KAOY5dZkvXQDi28JBRU+borxvCA="
-    },
-    "combine-source-map": {
-      "version": "0.1.3",
-      "resolved": "https://registry.npmjs.org/combine-source-map/-/combine-source-map-0.1.3.tgz",
-      "integrity": "sha1-3bdZOg8WcriCEnAiUBR7xOnqlc8=",
-      "requires": {
-        "convert-source-map": "~0.2.3",
-        "inline-source-map": "~0.2.1",
-        "parse-base64vlq-mappings": "~0.1.1"
-      }
-    },
-    "commondir": {
-      "version": "0.0.2",
-      "resolved": "https://registry.npmjs.org/commondir/-/commondir-0.0.2.tgz",
-      "integrity": "sha1-xJyIgMb+loRLs1Jd0ucxQFDDie4="
-    },
-    "concat-stream": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-1.0.1.tgz",
-      "integrity": "sha1-AYsYvBx9BzotyCqkhEI0GixN158=",
-      "requires": {
-        "bops": "0.0.6"
-      }
-    },
-    "console-browserify": {
-      "version": "0.1.6",
-      "resolved": "https://registry.npmjs.org/console-browserify/-/console-browserify-0.1.6.tgz",
-      "integrity": "sha1-0SijwLuINQ61YmxufHGm8P1ImDw="
-    },
-    "constants-browserify": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/constants-browserify/-/constants-browserify-0.0.1.tgz",
-      "integrity": "sha1-kld9tSe6bEzwpFaNhLwDH0QeIfI="
-    },
-    "convert-source-map": {
-      "version": "0.2.6",
-      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-0.2.6.tgz",
-      "integrity": "sha1-rg7XNuimNEpYtQqJRyPeXIUd4tQ="
-    },
-    "crypto-browserify": {
-      "version": "1.0.9",
-      "resolved": "https://registry.npmjs.org/crypto-browserify/-/crypto-browserify-1.0.9.tgz",
-      "integrity": "sha1-zFRJaF37hesRyYKKzHy4erW7/MA="
-    },
-    "deep-equal": {
-      "version": "0.0.0",
-      "resolved": "https://registry.npmjs.org/deep-equal/-/deep-equal-0.0.0.tgz",
-      "integrity": "sha1-mWedO70EcVb81FDT0B7rkGhpHoM="
-    },
-    "defined": {
-      "version": "0.0.0",
-      "resolved": "https://registry.npmjs.org/defined/-/defined-0.0.0.tgz",
-      "integrity": "sha1-817qfXBekzuvE7LwOz+D2SFAOz4="
-    },
-    "deps-sort": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/deps-sort/-/deps-sort-0.1.2.tgz",
-      "integrity": "sha1-2qL7YUoXyWN9gB4vVTOa43DzYRo=",
-      "requires": {
-        "JSONStream": "~0.6.4",
-        "minimist": "~0.0.1",
-        "through": "~2.3.4"
-      }
-    },
-    "detective": {
-      "version": "2.1.2",
-      "resolved": "https://registry.npmjs.org/detective/-/detective-2.1.2.tgz",
-      "integrity": "sha1-0irZ8YyC77P1X+4uJEiD2mu7jjc=",
-      "requires": {
-        "escodegen": "0.0.15",
-        "esprima": "1.0.2"
-      }
-    },
-    "duplexer": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/duplexer/-/duplexer-0.1.1.tgz",
-      "integrity": "sha1-rOb/gIwc5mtX0ev5eXessCM0z8E="
-    },
-    "escodegen": {
-      "version": "0.0.15",
-      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-0.0.15.tgz",
-      "integrity": "sha1-/9qcsmtws098wZ8diHVlOa+1Q70=",
-      "requires": {
-        "esprima": ">= 1.0.0",
-        "source-map": ">= 0.1.2"
-      }
-    },
-    "esprima": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/esprima/-/esprima-1.0.2.tgz",
-      "integrity": "sha1-gDm/nOrE2dLBX2IyZPspK1UCzq8="
-    },
-    "event-stream": {
-      "version": "3.0.20",
-      "resolved": "http://registry.npmjs.org/event-stream/-/event-stream-3.0.20.tgz",
-      "integrity": "sha1-A4u7LqnqkDhbJvvBhU0LU58qvqM=",
-      "requires": {
-        "duplexer": "~0.1.1",
-        "from": "~0",
-        "map-stream": "~0.0.3",
-        "pause-stream": "0.0.11",
-        "split": "0.2",
-        "stream-combiner": "~0.0.3",
-        "through": "~2.3.1"
-      }
-    },
-    "from": {
-      "version": "0.1.7",
-      "resolved": "https://registry.npmjs.org/from/-/from-0.1.7.tgz",
-      "integrity": "sha1-g8YK/Fi5xWmXAH7Rp2izqzA6RP4="
-    },
-    "fs-extra": {
-      "version": "0.6.4",
-      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-0.6.4.tgz",
-      "integrity": "sha1-9G8MdbeEH40gCzNIzU1pHVoJnRU=",
-      "requires": {
-        "jsonfile": "~1.0.1",
-        "mkdirp": "0.3.x",
-        "ncp": "~0.4.2",
-        "rimraf": "~2.2.0"
-      }
-    },
-    "http-browserify": {
-      "version": "0.1.14",
-      "resolved": "https://registry.npmjs.org/http-browserify/-/http-browserify-0.1.14.tgz",
-      "integrity": "sha1-nIs/lAAiBFR8fL5Saa/i6mL3HH8=",
-      "requires": {
-        "Base64": "~0.1.2",
-        "concat-stream": "~1.0.0"
-      }
-    },
-    "immediate": {
-      "version": "3.0.6",
-      "resolved": "https://registry.npmjs.org/immediate/-/immediate-3.0.6.tgz",
-      "integrity": "sha1-nbHb0Pr43m++D13V5Wu2BigN5ps="
-    },
-    "indexof": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/indexof/-/indexof-0.0.1.tgz",
-      "integrity": "sha1-gtwzbSMrkGIXnQWrMpOmYFn9Q10="
-    },
-    "inherits": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/inherits/-/inherits-1.0.2.tgz",
-      "integrity": "sha1-ykMJ2t7mtUzAuNJH6NfHoJdb3Js="
-    },
-    "inline-source-map": {
-      "version": "0.2.5",
-      "resolved": "https://registry.npmjs.org/inline-source-map/-/inline-source-map-0.2.5.tgz",
-      "integrity": "sha1-JC/2wYufsJNPep6DwUIZxhwTFnA=",
-      "requires": {
-        "source-map": "~0.1.25"
-      }
-    },
-    "insert-module-globals": {
-      "version": "1.2.1",
-      "resolved": "https://registry.npmjs.org/insert-module-globals/-/insert-module-globals-1.2.1.tgz",
-      "integrity": "sha1-CbSMZu0yamwbvOA1mEM8YMfCTRM=",
-      "requires": {
-        "JSONStream": "~0.4.3",
-        "commondir": "~0.0.1",
-        "duplexer": "~0.0.3",
-        "lexical-scope": "~0.0.5",
-        "process": "~0.5.1",
-        "through": "~2.2.0"
-      },
-      "dependencies": {
-        "JSONStream": {
-          "version": "0.4.4",
-          "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-0.4.4.tgz",
-          "integrity": "sha1-zCzxGShsRb4VBCPLwSjUgOm1SuI=",
-          "requires": {
-            "jsonparse": "0.0.5"
-          }
-        },
-        "duplexer": {
-          "version": "0.0.4",
-          "resolved": "https://registry.npmjs.org/duplexer/-/duplexer-0.0.4.tgz",
-          "integrity": "sha1-r8t/H4uNdPggcmFx1dZKyeSo/yA="
-        },
-        "through": {
-          "version": "2.2.7",
-          "resolved": "https://registry.npmjs.org/through/-/through-2.2.7.tgz",
-          "integrity": "sha1-bo4hIAGR1OtqmfbwEN9Gqhxusr0="
-        }
-      }
-    },
-    "jsonfile": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-1.0.1.tgz",
-      "integrity": "sha1-6l7+QLg2kLmGZ2FKc5L8YOhCwN0="
-    },
-    "jsonify": {
-      "version": "0.0.0",
-      "resolved": "https://registry.npmjs.org/jsonify/-/jsonify-0.0.0.tgz",
-      "integrity": "sha1-LHS27kHZPKUbe1qu6PUDYx0lKnM="
-    },
-    "jsonparse": {
-      "version": "0.0.5",
-      "resolved": "https://registry.npmjs.org/jsonparse/-/jsonparse-0.0.5.tgz",
-      "integrity": "sha1-MwVCrT8KZUZlt3jz6y2an6UHrGQ="
-    },
-    "lexical-scope": {
-      "version": "0.0.15",
-      "resolved": "https://registry.npmjs.org/lexical-scope/-/lexical-scope-0.0.15.tgz",
-      "integrity": "sha1-yllZl6rth7FVywQfSNwEOPSKBNw=",
-      "requires": {
-        "astw": "~0.0.0"
-      }
-    },
-    "lie": {
-      "version": "3.1.1",
-      "resolved": "https://registry.npmjs.org/lie/-/lie-3.1.1.tgz",
-      "integrity": "sha1-mkNrLMd0bKWd56QfpGmz77dr2H4=",
-      "requires": {
-        "immediate": "~3.0.5"
-      }
-    },
-    "localforage": {
-      "version": "1.7.1",
-      "resolved": "https://registry.npmjs.org/localforage/-/localforage-1.7.1.tgz",
-      "integrity": "sha1-5JJ+BCMCuGTbMPMhHxO1xvDell0=",
-      "requires": {
-        "lie": "3.1.1"
-      }
-    },
-    "map-stream": {
-      "version": "0.0.7",
-      "resolved": "https://registry.npmjs.org/map-stream/-/map-stream-0.0.7.tgz",
-      "integrity": "sha1-ih8HiW2CsQkmvTdEokIACfiJdKg="
-    },
-    "minimist": {
-      "version": "0.0.10",
-      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10.tgz",
-      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
-    },
-    "mkdirp": {
-      "version": "0.3.5",
-      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.3.5.tgz",
-      "integrity": "sha1-3j5fiWHIjHh+4TaN+EmsRBPsqNc="
-    },
-    "module-deps": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/module-deps/-/module-deps-1.0.2.tgz",
-      "integrity": "sha1-Xug8/XC6iDhp+my664IzSo8Gn8s=",
-      "requires": {
-        "JSONStream": "~0.6.4",
-        "browser-resolve": "~1.1.0",
-        "concat-stream": "~1.0.0",
-        "detective": "~2.1.2",
-        "minimist": "~0.0.1",
-        "resolve": "~0.4.0",
-        "through": "~2.3.4"
-      },
-      "dependencies": {
-        "resolve": {
-          "version": "0.4.3",
-          "resolved": "https://registry.npmjs.org/resolve/-/resolve-0.4.3.tgz",
-          "integrity": "sha1-3K2tIC58rMJGfjo4gAIR9C+cE98="
-        }
-      }
-    },
-    "ncp": {
-      "version": "0.4.2",
-      "resolved": "https://registry.npmjs.org/ncp/-/ncp-0.4.2.tgz",
-      "integrity": "sha1-q8xsvT7C7Spyn/bnwfqPAXhKhXQ="
-    },
-    "optimist": {
-      "version": "0.5.2",
-      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.5.2.tgz",
-      "integrity": "sha1-hcjBRUszFeSniUfoV7HfAzRQv7w=",
-      "requires": {
-        "wordwrap": "~0.0.2"
-      }
-    },
-    "parents": {
-      "version": "0.0.3",
-      "resolved": "https://registry.npmjs.org/parents/-/parents-0.0.3.tgz",
-      "integrity": "sha1-+iEvAk2fpjGNu2tM5nbIvkk7nEM=",
-      "requires": {
-        "path-platform": "^0.0.1"
-      }
-    },
-    "parse-base64vlq-mappings": {
-      "version": "0.1.4",
-      "resolved": "https://registry.npmjs.org/parse-base64vlq-mappings/-/parse-base64vlq-mappings-0.1.4.tgz",
-      "integrity": "sha1-/PXd3tOaAQ3449xgnIbtAQF9+pg="
-    },
-    "path-platform": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/path-platform/-/path-platform-0.0.1.tgz",
-      "integrity": "sha1-tVhdfDxGPYmqAGDYZhHPGv1hfio="
-    },
-    "pause-stream": {
-      "version": "0.0.11",
-      "resolved": "https://registry.npmjs.org/pause-stream/-/pause-stream-0.0.11.tgz",
-      "integrity": "sha1-/lo0sMvOErWqaitAPuLnO2AvFEU=",
-      "requires": {
-        "through": "~2.3"
-      }
-    },
-    "process": {
-      "version": "0.5.2",
-      "resolved": "https://registry.npmjs.org/process/-/process-0.5.2.tgz",
-      "integrity": "sha1-FjjYqONML0QKkduVq5rrZ3/Bhc8="
-    },
-    "punycode": {
-      "version": "1.2.4",
-      "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.2.4.tgz",
-      "integrity": "sha1-VACKyXKux0F13vnLpt9/qdORh0A="
-    },
-    "resolve": {
-      "version": "0.3.1",
-      "resolved": "https://registry.npmjs.org/resolve/-/resolve-0.3.1.tgz",
-      "integrity": "sha1-NMY0R8ZkxwWY0cmxJvxDsqJDEKQ="
-    },
-    "rfile": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/rfile/-/rfile-1.0.0.tgz",
-      "integrity": "sha1-WXCM+Qyh50xUw8/Fw2/bmBBDUmE=",
-      "requires": {
-        "callsite": "~1.0.0",
-        "resolve": "~0.3.0"
-      }
-    },
-    "rimraf": {
-      "version": "2.2.8",
-      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.2.8.tgz",
-      "integrity": "sha1-5Dm+Kq7jJzIZUnMPmaiSnk/FBYI="
-    },
-    "ruglify": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/ruglify/-/ruglify-1.0.0.tgz",
-      "integrity": "sha1-3Ikw4qlUSidDAcyZcldMDQmGtnU=",
-      "requires": {
-        "rfile": "~1.0",
-        "uglify-js": "~2.2"
-      },
-      "dependencies": {
-        "optimist": {
-          "version": "0.3.7",
-          "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.3.7.tgz",
-          "integrity": "sha1-yQlBrVnkJzMokjB00s8ufLxuwNk=",
-          "requires": {
-            "wordwrap": "~0.0.2"
-          }
-        },
-        "uglify-js": {
-          "version": "2.2.5",
-          "resolved": "https://registry.npmjs.org/uglify-js/-/uglify-js-2.2.5.tgz",
-          "integrity": "sha1-puAqcNg5eSuXgEiLe4sYTAlcmcc=",
-          "requires": {
-            "optimist": "~0.3.5",
-            "source-map": "~0.1.7"
-          }
-        }
-      }
-    },
-    "shell-quote": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/shell-quote/-/shell-quote-0.0.1.tgz",
-      "integrity": "sha1-GkEZbzwDM8SCMjWT1ohuzxU92YY="
-    },
-    "source-map": {
-      "version": "0.1.43",
-      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.1.43.tgz",
-      "integrity": "sha1-wkvBRspRfBRx9drL4lcbK3+eM0Y=",
-      "requires": {
-        "amdefine": ">=0.0.4"
-      }
-    },
-    "split": {
-      "version": "0.2.10",
-      "resolved": "https://registry.npmjs.org/split/-/split-0.2.10.tgz",
-      "integrity": "sha1-Zwl8YB1pfOE2j0GPBs0gHPBSGlc=",
-      "requires": {
-        "through": "2"
-      }
-    },
-    "stream-combiner": {
-      "version": "0.0.4",
-      "resolved": "https://registry.npmjs.org/stream-combiner/-/stream-combiner-0.0.4.tgz",
-      "integrity": "sha1-TV5DPBhSYd3mI8o/RMWGvPXErRQ=",
-      "requires": {
-        "duplexer": "~0.1.1"
-      }
-    },
-    "syntax-error": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/syntax-error/-/syntax-error-0.0.1.tgz",
-      "integrity": "sha1-AZ0HU0jNjFt58GA8c+U4kafFI10=",
-      "requires": {
-        "esprima": "~0.9.9"
-      },
-      "dependencies": {
-        "esprima": {
-          "version": "0.9.9",
-          "resolved": "https://registry.npmjs.org/esprima/-/esprima-0.9.9.tgz",
-          "integrity": "sha1-G5CSXJddYy1ygpOcO7nDpCPDBJA="
-        }
-      }
-    },
-    "tape": {
-      "version": "0.2.2",
-      "resolved": "https://registry.npmjs.org/tape/-/tape-0.2.2.tgz",
-      "integrity": "sha1-ZMz6S37PSgBgAH5hcW1CR4FnFjc=",
-      "requires": {
-        "deep-equal": "~0.0.0",
-        "defined": "~0.0.0",
-        "jsonify": "~0.0.0"
-      }
-    },
-    "through": {
-      "version": "2.3.8",
-      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
-      "integrity": "sha1-DdTJ/6q8NXlgsbckEV1+Doai4fU="
-    },
-    "to-utf8": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/to-utf8/-/to-utf8-0.0.1.tgz",
-      "integrity": "sha1-0Xrqcv8vujm55DYBvns/9y4ImFI="
-    },
-    "uglify-js": {
-      "version": "2.3.6",
-      "resolved": "https://registry.npmjs.org/uglify-js/-/uglify-js-2.3.6.tgz",
-      "integrity": "sha1-+gmEdwtCi3qbKoBY9GNV0U/vIRo=",
-      "requires": {
-        "async": "~0.2.6",
-        "optimist": "~0.3.5",
-        "source-map": "~0.1.7"
-      },
-      "dependencies": {
-        "optimist": {
-          "version": "0.3.7",
-          "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.3.7.tgz",
-          "integrity": "sha1-yQlBrVnkJzMokjB00s8ufLxuwNk=",
-          "requires": {
-            "wordwrap": "~0.0.2"
-          }
-        }
-      }
-    },
-    "umd": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/umd/-/umd-1.1.1.tgz",
-      "integrity": "sha1-SBtkZVsbPbDB85ECJcOAT8bX7Fg=",
-      "requires": {
-        "rfile": "~1.0.0",
-        "ruglify": "~1.0.0",
-        "through": "~2.3.1",
-        "uglify-js": "~2.2.5"
-      },
-      "dependencies": {
-        "optimist": {
-          "version": "0.3.7",
-          "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.3.7.tgz",
-          "integrity": "sha1-yQlBrVnkJzMokjB00s8ufLxuwNk=",
-          "requires": {
-            "wordwrap": "~0.0.2"
-          }
-        },
-        "uglify-js": {
-          "version": "2.2.5",
-          "resolved": "https://registry.npmjs.org/uglify-js/-/uglify-js-2.2.5.tgz",
-          "integrity": "sha1-puAqcNg5eSuXgEiLe4sYTAlcmcc=",
-          "requires": {
-            "optimist": "~0.3.5",
-            "source-map": "~0.1.7"
-          }
-        }
-      }
-    },
-    "vm-browserify": {
-      "version": "0.0.4",
-      "resolved": "https://registry.npmjs.org/vm-browserify/-/vm-browserify-0.0.4.tgz",
-      "integrity": "sha1-XX6kW7755Kb/ZflUOOCofDV9WnM=",
-      "requires": {
-        "indexof": "0.0.1"
-      }
-    },
-    "wordwrap": {
-      "version": "0.0.3",
-      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
-      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
-    },
-    "zlib-browserify": {
-      "version": "0.0.3",
-      "resolved": "https://registry.npmjs.org/zlib-browserify/-/zlib-browserify-0.0.3.tgz",
-      "integrity": "sha1-JAzNv9AgP6hCsTDe77FBQSLIzFA=",
-      "requires": {
-        "tape": "~0.2.2"
-      }
-    }
-  }
-}
diff --git a/browser-version/package.json b/browser-version/package.json
index fb4485b..83882e4 100755
--- a/browser-version/package.json
+++ b/browser-version/package.json
@@ -1,9 +1,8 @@
 {
   "dependencies": {
     "async": "~0.2.9",
-    "browserify": "~2.25.0",
     "fs-extra": "~0.6.3",
-    "localforage": "^1.7.1",
-    "uglify-js": "~2.3.6"
+    "uglify-js": "~2.3.6",
+    "browserify": "~2.25.0"
   }
 }
diff --git a/browser-version/test/localforage.js b/browser-version/test/localforage.js
old mode 100644
new mode 100755
index c8e3e68..3cc388f
--- a/browser-version/test/localforage.js
+++ b/browser-version/test/localforage.js
@@ -1,2797 +1,2758 @@
 /*!
     localForage -- Offline Storage, Improved
-    Version 1.7.1
-    https://localforage.github.io/localForage
-    (c) 2013-2017 Mozilla, Apache License 2.0
+    Version 1.3.0
+    https://mozilla.github.io/localForage
+    (c) 2013-2015 Mozilla, Apache License 2.0
 */
-(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
-(function (global){
-'use strict';
-var Mutation = global.MutationObserver || global.WebKitMutationObserver;
-
-var scheduleDrain;
-
-{
-  if (Mutation) {
-    var called = 0;
-    var observer = new Mutation(nextTick);
-    var element = global.document.createTextNode('');
-    observer.observe(element, {
-      characterData: true
-    });
-    scheduleDrain = function () {
-      element.data = (called = ++called % 2);
-    };
-  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
-    var channel = new global.MessageChannel();
-    channel.port1.onmessage = nextTick;
-    scheduleDrain = function () {
-      channel.port2.postMessage(0);
-    };
-  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
-    scheduleDrain = function () {
-
-      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
-      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
-      var scriptEl = global.document.createElement('script');
-      scriptEl.onreadystatechange = function () {
-        nextTick();
-
-        scriptEl.onreadystatechange = null;
-        scriptEl.parentNode.removeChild(scriptEl);
-        scriptEl = null;
-      };
-      global.document.documentElement.appendChild(scriptEl);
-    };
-  } else {
-    scheduleDrain = function () {
-      setTimeout(nextTick, 0);
-    };
-  }
-}
-
-var draining;
-var queue = [];
-//named nextTick for less confusing stack traces
-function nextTick() {
-  draining = true;
-  var i, oldQueue;
-  var len = queue.length;
-  while (len) {
-    oldQueue = queue;
-    queue = [];
-    i = -1;
-    while (++i < len) {
-      oldQueue[i]();
-    }
-    len = queue.length;
-  }
-  draining = false;
-}
-
-module.exports = immediate;
-function immediate(task) {
-  if (queue.push(task) === 1 && !draining) {
-    scheduleDrain();
-  }
-}
-
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{}],2:[function(_dereq_,module,exports){
-'use strict';
-var immediate = _dereq_(1);
-
-/* istanbul ignore next */
-function INTERNAL() {}
-
-var handlers = {};
-
-var REJECTED = ['REJECTED'];
-var FULFILLED = ['FULFILLED'];
-var PENDING = ['PENDING'];
-
-module.exports = Promise;
-
-function Promise(resolver) {
-  if (typeof resolver !== 'function') {
-    throw new TypeError('resolver must be a function');
-  }
-  this.state = PENDING;
-  this.queue = [];
-  this.outcome = void 0;
-  if (resolver !== INTERNAL) {
-    safelyResolveThenable(this, resolver);
-  }
-}
-
-Promise.prototype["catch"] = function (onRejected) {
-  return this.then(null, onRejected);
-};
-Promise.prototype.then = function (onFulfilled, onRejected) {
-  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
-    typeof onRejected !== 'function' && this.state === REJECTED) {
-    return this;
-  }
-  var promise = new this.constructor(INTERNAL);
-  if (this.state !== PENDING) {
-    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
-    unwrap(promise, resolver, this.outcome);
-  } else {
-    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
-  }
-
-  return promise;
-};
-function QueueItem(promise, onFulfilled, onRejected) {
-  this.promise = promise;
-  if (typeof onFulfilled === 'function') {
-    this.onFulfilled = onFulfilled;
-    this.callFulfilled = this.otherCallFulfilled;
-  }
-  if (typeof onRejected === 'function') {
-    this.onRejected = onRejected;
-    this.callRejected = this.otherCallRejected;
-  }
-}
-QueueItem.prototype.callFulfilled = function (value) {
-  handlers.resolve(this.promise, value);
-};
-QueueItem.prototype.otherCallFulfilled = function (value) {
-  unwrap(this.promise, this.onFulfilled, value);
-};
-QueueItem.prototype.callRejected = function (value) {
-  handlers.reject(this.promise, value);
-};
-QueueItem.prototype.otherCallRejected = function (value) {
-  unwrap(this.promise, this.onRejected, value);
-};
-
-function unwrap(promise, func, value) {
-  immediate(function () {
-    var returnValue;
-    try {
-      returnValue = func(value);
-    } catch (e) {
-      return handlers.reject(promise, e);
-    }
-    if (returnValue === promise) {
-      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
-    } else {
-      handlers.resolve(promise, returnValue);
-    }
-  });
-}
-
-handlers.resolve = function (self, value) {
-  var result = tryCatch(getThen, value);
-  if (result.status === 'error') {
-    return handlers.reject(self, result.value);
-  }
-  var thenable = result.value;
-
-  if (thenable) {
-    safelyResolveThenable(self, thenable);
-  } else {
-    self.state = FULFILLED;
-    self.outcome = value;
-    var i = -1;
-    var len = self.queue.length;
-    while (++i < len) {
-      self.queue[i].callFulfilled(value);
-    }
-  }
-  return self;
-};
-handlers.reject = function (self, error) {
-  self.state = REJECTED;
-  self.outcome = error;
-  var i = -1;
-  var len = self.queue.length;
-  while (++i < len) {
-    self.queue[i].callRejected(error);
-  }
-  return self;
-};
-
-function getThen(obj) {
-  // Make sure we only access the accessor once as required by the spec
-  var then = obj && obj.then;
-  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
-    return function appyThen() {
-      then.apply(obj, arguments);
-    };
-  }
-}
-
-function safelyResolveThenable(self, thenable) {
-  // Either fulfill, reject or reject with error
-  var called = false;
-  function onError(value) {
-    if (called) {
-      return;
-    }
-    called = true;
-    handlers.reject(self, value);
-  }
+(function() {
+var define, requireModule, require, requirejs;
 
-  function onSuccess(value) {
-    if (called) {
-      return;
-    }
-    called = true;
-    handlers.resolve(self, value);
-  }
-
-  function tryToUnwrap() {
-    thenable(onSuccess, onError);
-  }
-
-  var result = tryCatch(tryToUnwrap);
-  if (result.status === 'error') {
-    onError(result.value);
-  }
-}
-
-function tryCatch(func, value) {
-  var out = {};
-  try {
-    out.value = func(value);
-    out.status = 'success';
-  } catch (e) {
-    out.status = 'error';
-    out.value = e;
-  }
-  return out;
-}
-
-Promise.resolve = resolve;
-function resolve(value) {
-  if (value instanceof this) {
-    return value;
-  }
-  return handlers.resolve(new this(INTERNAL), value);
-}
-
-Promise.reject = reject;
-function reject(reason) {
-  var promise = new this(INTERNAL);
-  return handlers.reject(promise, reason);
-}
-
-Promise.all = all;
-function all(iterable) {
-  var self = this;
-  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
-    return this.reject(new TypeError('must be an array'));
-  }
-
-  var len = iterable.length;
-  var called = false;
-  if (!len) {
-    return this.resolve([]);
-  }
-
-  var values = new Array(len);
-  var resolved = 0;
-  var i = -1;
-  var promise = new this(INTERNAL);
-
-  while (++i < len) {
-    allResolver(iterable[i], i);
-  }
-  return promise;
-  function allResolver(value, i) {
-    self.resolve(value).then(resolveFromAll, function (error) {
-      if (!called) {
-        called = true;
-        handlers.reject(promise, error);
-      }
-    });
-    function resolveFromAll(outValue) {
-      values[i] = outValue;
-      if (++resolved === len && !called) {
-        called = true;
-        handlers.resolve(promise, values);
-      }
-    }
-  }
-}
-
-Promise.race = race;
-function race(iterable) {
-  var self = this;
-  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
-    return this.reject(new TypeError('must be an array'));
-  }
-
-  var len = iterable.length;
-  var called = false;
-  if (!len) {
-    return this.resolve([]);
-  }
-
-  var i = -1;
-  var promise = new this(INTERNAL);
-
-  while (++i < len) {
-    resolver(iterable[i]);
-  }
-  return promise;
-  function resolver(value) {
-    self.resolve(value).then(function (response) {
-      if (!called) {
-        called = true;
-        handlers.resolve(promise, response);
-      }
-    }, function (error) {
-      if (!called) {
-        called = true;
-        handlers.reject(promise, error);
-      }
-    });
-  }
-}
-
-},{"1":1}],3:[function(_dereq_,module,exports){
-(function (global){
-'use strict';
-if (typeof global.Promise !== 'function') {
-  global.Promise = _dereq_(2);
-}
-
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"2":2}],4:[function(_dereq_,module,exports){
-'use strict';
-
-var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
-
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
-
-function getIDB() {
-    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
-    try {
-        if (typeof indexedDB !== 'undefined') {
-            return indexedDB;
-        }
-        if (typeof webkitIndexedDB !== 'undefined') {
-            return webkitIndexedDB;
-        }
-        if (typeof mozIndexedDB !== 'undefined') {
-            return mozIndexedDB;
-        }
-        if (typeof OIndexedDB !== 'undefined') {
-            return OIndexedDB;
-        }
-        if (typeof msIndexedDB !== 'undefined') {
-            return msIndexedDB;
-        }
-    } catch (e) {
-        return;
-    }
-}
+(function() {
+  var registry = {}, seen = {};
 
-var idb = getIDB();
+  define = function(name, deps, callback) {
+    registry[name] = { deps: deps, callback: callback };
+  };
 
-function isIndexedDBValid() {
-    try {
-        // Initialize IndexedDB; fall back to vendor-prefixed versions
-        // if needed.
-        if (!idb) {
-            return false;
-        }
-        // We mimic PouchDB here;
-        //
-        // We test for openDatabase because IE Mobile identifies itself
-        // as Safari. Oh the lulz...
-        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
-
-        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;
-
-        // Safari <10.1 does not meet our requirements for IDB support (#5572)
-        // since Safari 10.1 shipped with fetch, we can use that to detect it
-        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
-        // some outdated implementations of IDB that appear on Samsung
-        // and HTC Android devices <4.4 are missing IDBKeyRange
-        // See: https://github.com/mozilla/localForage/issues/128
-        // See: https://github.com/mozilla/localForage/issues/272
-        typeof IDBKeyRange !== 'undefined';
-    } catch (e) {
-        return false;
-    }
-}
-
-// Abstracts constructing a Blob object, so it also works in older
-// browsers that don't support the native Blob constructor. (i.e.
-// old QtWebKit versions, at least).
-// Abstracts constructing a Blob object, so it also works in older
-// browsers that don't support the native Blob constructor. (i.e.
-// old QtWebKit versions, at least).
-function createBlob(parts, properties) {
-    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
-    parts = parts || [];
-    properties = properties || {};
-    try {
-        return new Blob(parts, properties);
-    } catch (e) {
-        if (e.name !== 'TypeError') {
-            throw e;
-        }
-        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
-        var builder = new Builder();
-        for (var i = 0; i < parts.length; i += 1) {
-            builder.append(parts[i]);
-        }
-        return builder.getBlob(properties.type);
-    }
-}
-
-// This is CommonJS because lie is an external dependency, so Rollup
-// can just ignore it.
-if (typeof Promise === 'undefined') {
-    // In the "nopromises" build this will just throw if you don't have
-    // a global promise object, but it would throw anyway later.
-    _dereq_(3);
-}
-var Promise$1 = Promise;
-
-function executeCallback(promise, callback) {
-    if (callback) {
-        promise.then(function (result) {
-            callback(null, result);
-        }, function (error) {
-            callback(error);
-        });
-    }
-}
+  requirejs = require = requireModule = function(name) {
+  requirejs._eak_seen = registry;
 
-function executeTwoCallbacks(promise, callback, errorCallback) {
-    if (typeof callback === 'function') {
-        promise.then(callback);
-    }
-
-    if (typeof errorCallback === 'function') {
-        promise["catch"](errorCallback);
-    }
-}
+    if (seen[name]) { return seen[name]; }
+    seen[name] = {};
 
-function normalizeKey(key) {
-    // Cast the key to a string, as that's all we can set as a key.
-    if (typeof key !== 'string') {
-        console.warn(key + ' used as a key, but it is not a string.');
-        key = String(key);
+    if (!registry[name]) {
+      throw new Error("Could not find module " + name);
     }
 
-    return key;
-}
-
-function getCallback() {
-    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
-        return arguments[arguments.length - 1];
-    }
-}
-
-// Some code originally from async_storage.js in
-// [Gaia](https://github.com/mozilla-b2g/gaia).
-
-var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
-var supportsBlobs = void 0;
-var dbContexts = {};
-var toString = Object.prototype.toString;
-
-// Transaction Modes
-var READ_ONLY = 'readonly';
-var READ_WRITE = 'readwrite';
-
-// Transform a binary string to an array buffer, because otherwise
-// weird stuff happens when you try to work with the binary string directly.
-// It is known.
-// From http://stackoverflow.com/questions/14967647/ (continues on next line)
-// encode-decode-image-with-base64-breaks-image (2013-04-21)
-function _binStringToArrayBuffer(bin) {
-    var length = bin.length;
-    var buf = new ArrayBuffer(length);
-    var arr = new Uint8Array(buf);
-    for (var i = 0; i < length; i++) {
-        arr[i] = bin.charCodeAt(i);
-    }
-    return buf;
-}
-
-//
-// Blobs are not supported in all versions of IndexedDB, notably
-// Chrome <37 and Android <5. In those versions, storing a blob will throw.
-//
-// Various other blob bugs exist in Chrome v37-42 (inclusive).
-// Detecting them is expensive and confusing to users, and Chrome 37-42
-// is at very low usage worldwide, so we do a hacky userAgent check instead.
-//
-// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
-// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
-// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
-//
-// Code borrowed from PouchDB. See:
-// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
-//
-function _checkBlobSupportWithoutCaching(idb) {
-    return new Promise$1(function (resolve) {
-        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
-        var blob = createBlob(['']);
-        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
-
-        txn.onabort = function (e) {
-            // If the transaction aborts now its due to not being able to
-            // write to the database, likely due to the disk being full
-            e.preventDefault();
-            e.stopPropagation();
-            resolve(false);
-        };
-
-        txn.oncomplete = function () {
-            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
-            var matchedEdge = navigator.userAgent.match(/Edge\//);
-            // MS Edge pretends to be Chrome 42:
-            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
-            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
-        };
-    })["catch"](function () {
-        return false; // error, so assume unsupported
-    });
-}
-
-function _checkBlobSupport(idb) {
-    if (typeof supportsBlobs === 'boolean') {
-        return Promise$1.resolve(supportsBlobs);
+    var mod = registry[name],
+        deps = mod.deps,
+        callback = mod.callback,
+        reified = [],
+        exports;
+
+    for (var i=0, l=deps.length; i<l; i++) {
+      if (deps[i] === 'exports') {
+        reified.push(exports = {});
+      } else {
+        reified.push(requireModule(resolve(deps[i])));
+      }
     }
-    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
-        supportsBlobs = value;
-        return supportsBlobs;
-    });
-}
-
-function _deferReadiness(dbInfo) {
-    var dbContext = dbContexts[dbInfo.name];
 
-    // Create a deferred object representing the current database operation.
-    var deferredOperation = {};
+    var value = callback.apply(this, reified);
+    return seen[name] = exports || value;
 
-    deferredOperation.promise = new Promise$1(function (resolve, reject) {
-        deferredOperation.resolve = resolve;
-        deferredOperation.reject = reject;
-    });
+    function resolve(child) {
+      if (child.charAt(0) !== '.') { return child; }
+      var parts = child.split("/");
+      var parentBase = name.split("/").slice(0, -1);
 
-    // Enqueue the deferred operation.
-    dbContext.deferredOperations.push(deferredOperation);
+      for (var i=0, l=parts.length; i<l; i++) {
+        var part = parts[i];
 
-    // Chain its promise to the database readiness.
-    if (!dbContext.dbReady) {
-        dbContext.dbReady = deferredOperation.promise;
-    } else {
-        dbContext.dbReady = dbContext.dbReady.then(function () {
-            return deferredOperation.promise;
-        });
-    }
-}
-
-function _advanceReadiness(dbInfo) {
-    var dbContext = dbContexts[dbInfo.name];
-
-    // Dequeue a deferred operation.
-    var deferredOperation = dbContext.deferredOperations.pop();
+        if (part === '..') { parentBase.pop(); }
+        else if (part === '.') { continue; }
+        else { parentBase.push(part); }
+      }
 
-    // Resolve its promise (which is part of the database readiness
-    // chain of promises).
-    if (deferredOperation) {
-        deferredOperation.resolve();
-        return deferredOperation.promise;
+      return parentBase.join("/");
     }
-}
-
-function _rejectReadiness(dbInfo, err) {
-    var dbContext = dbContexts[dbInfo.name];
+  };
+})();
+
+define("promise/all", 
+  ["./utils","exports"],
+  function(__dependency1__, __exports__) {
+    "use strict";
+    /* global toString */
+
+    var isArray = __dependency1__.isArray;
+    var isFunction = __dependency1__.isFunction;
+
+    /**
+      Returns a promise that is fulfilled when all the given promises have been
+      fulfilled, or rejected if any of them become rejected. The return promise
+      is fulfilled with an array that gives all the values in the order they were
+      passed in the `promises` array argument.
+      Example:
+      ```javascript
+      var promise1 = RSVP.resolve(1);
+      var promise2 = RSVP.resolve(2);
+      var promise3 = RSVP.resolve(3);
+      var promises = [ promise1, promise2, promise3 ];
+      RSVP.all(promises).then(function(array){
+        // The array here would be [ 1, 2, 3 ];
+      });
+      ```
+      If any of the `promises` given to `RSVP.all` are rejected, the first promise
+      that is rejected will be given as an argument to the returned promises's
+      rejection handler. For example:
+      Example:
+      ```javascript
+      var promise1 = RSVP.resolve(1);
+      var promise2 = RSVP.reject(new Error("2"));
+      var promise3 = RSVP.reject(new Error("3"));
+      var promises = [ promise1, promise2, promise3 ];
+      RSVP.all(promises).then(function(array){
+        // Code here never runs because there are rejected promises!
+      }, function(error) {
+        // error.message === "2"
+      });
+      ```
+      @method all
+      @for RSVP
+      @param {Array} promises
+      @param {String} label
+      @return {Promise} promise that is fulfilled when all `promises` have been
+      fulfilled, or rejected if any of them become rejected.
+    */
+    function all(promises) {
+      /*jshint validthis:true */
+      var Promise = this;
+
+      if (!isArray(promises)) {
+        throw new TypeError('You must pass an array to all.');
+      }
 
-    // Dequeue a deferred operation.
-    var deferredOperation = dbContext.deferredOperations.pop();
+      return new Promise(function(resolve, reject) {
+        var results = [], remaining = promises.length,
+        promise;
 
-    // Reject its promise (which is part of the database readiness
-    // chain of promises).
-    if (deferredOperation) {
-        deferredOperation.reject(err);
-        return deferredOperation.promise;
-    }
-}
-
-function _getConnection(dbInfo, upgradeNeeded) {
-    return new Promise$1(function (resolve, reject) {
-        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
-
-        if (dbInfo.db) {
-            if (upgradeNeeded) {
-                _deferReadiness(dbInfo);
-                dbInfo.db.close();
-            } else {
-                return resolve(dbInfo.db);
-            }
+        if (remaining === 0) {
+          resolve([]);
         }
 
-        var dbArgs = [dbInfo.name];
-
-        if (upgradeNeeded) {
-            dbArgs.push(dbInfo.version);
+        function resolver(index) {
+          return function(value) {
+            resolveAll(index, value);
+          };
         }
 
-        var openreq = idb.open.apply(idb, dbArgs);
-
-        if (upgradeNeeded) {
-            openreq.onupgradeneeded = function (e) {
-                var db = openreq.result;
-                try {
-                    db.createObjectStore(dbInfo.storeName);
-                    if (e.oldVersion <= 1) {
-                        // Added when support for blob shims was added
-                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
-                    }
-                } catch (ex) {
-                    if (ex.name === 'ConstraintError') {
-                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
-                    } else {
-                        throw ex;
-                    }
-                }
-            };
+        function resolveAll(index, value) {
+          results[index] = value;
+          if (--remaining === 0) {
+            resolve(results);
+          }
         }
 
-        openreq.onerror = function (e) {
-            e.preventDefault();
-            reject(openreq.error);
-        };
-
-        openreq.onsuccess = function () {
-            resolve(openreq.result);
-            _advanceReadiness(dbInfo);
-        };
-    });
-}
-
-function _getOriginalConnection(dbInfo) {
-    return _getConnection(dbInfo, false);
-}
-
-function _getUpgradedConnection(dbInfo) {
-    return _getConnection(dbInfo, true);
-}
+        for (var i = 0; i < promises.length; i++) {
+          promise = promises[i];
 
-function _isUpgradeNeeded(dbInfo, defaultVersion) {
-    if (!dbInfo.db) {
-        return true;
+          if (promise && isFunction(promise.then)) {
+            promise.then(resolver(i), reject);
+          } else {
+            resolveAll(i, promise);
+          }
+        }
+      });
     }
 
-    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
-    var isDowngrade = dbInfo.version < dbInfo.db.version;
-    var isUpgrade = dbInfo.version > dbInfo.db.version;
-
-    if (isDowngrade) {
-        // If the version is not the default one
-        // then warn for impossible downgrade.
-        if (dbInfo.version !== defaultVersion) {
-            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
-        }
-        // Align the versions to prevent errors.
-        dbInfo.version = dbInfo.db.version;
+    __exports__.all = all;
+  });
+define("promise/asap", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    var browserGlobal = (typeof window !== 'undefined') ? window : {};
+    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
+    var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);
+
+    // node
+    function useNextTick() {
+      return function() {
+        process.nextTick(flush);
+      };
     }
 
-    if (isUpgrade || isNewStore) {
-        // If the store is new then increment the version (if needed).
-        // This will trigger an "upgradeneeded" event which is required
-        // for creating a store.
-        if (isNewStore) {
-            var incVersion = dbInfo.db.version + 1;
-            if (incVersion > dbInfo.version) {
-                dbInfo.version = incVersion;
-            }
-        }
+    function useMutationObserver() {
+      var iterations = 0;
+      var observer = new BrowserMutationObserver(flush);
+      var node = document.createTextNode('');
+      observer.observe(node, { characterData: true });
 
-        return true;
+      return function() {
+        node.data = (iterations = ++iterations % 2);
+      };
     }
 
-    return false;
-}
-
-// encode a blob for indexeddb engines that don't support blobs
-function _encodeBlob(blob) {
-    return new Promise$1(function (resolve, reject) {
-        var reader = new FileReader();
-        reader.onerror = reject;
-        reader.onloadend = function (e) {
-            var base64 = btoa(e.target.result || '');
-            resolve({
-                __local_forage_encoded_blob: true,
-                data: base64,
-                type: blob.type
-            });
-        };
-        reader.readAsBinaryString(blob);
-    });
-}
-
-// decode an encoded blob
-function _decodeBlob(encodedBlob) {
-    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
-    return createBlob([arrayBuff], { type: encodedBlob.type });
-}
-
-// is this one of our fancy encoded blobs?
-function _isEncodedBlob(value) {
-    return value && value.__local_forage_encoded_blob;
-}
-
-// Specialize the default `ready()` function by making it dependent
-// on the current database operations. Thus, the driver will be actually
-// ready when it's been initialized (default) *and* there are no pending
-// operations on the database (initiated by some other instances).
-function _fullyReady(callback) {
-    var self = this;
-
-    var promise = self._initReady().then(function () {
-        var dbContext = dbContexts[self._dbInfo.name];
-
-        if (dbContext && dbContext.dbReady) {
-            return dbContext.dbReady;
-        }
-    });
-
-    executeTwoCallbacks(promise, callback, callback);
-    return promise;
-}
-
-// Try to establish a new db connection to replace the
-// current one which is broken (i.e. experiencing
-// InvalidStateError while creating a transaction).
-function _tryReconnect(dbInfo) {
-    _deferReadiness(dbInfo);
-
-    var dbContext = dbContexts[dbInfo.name];
-    var forages = dbContext.forages;
-
-    for (var i = 0; i < forages.length; i++) {
-        var forage = forages[i];
-        if (forage._dbInfo.db) {
-            forage._dbInfo.db.close();
-            forage._dbInfo.db = null;
-        }
+    function useSetTimeout() {
+      return function() {
+        local.setTimeout(flush, 1);
+      };
     }
-    dbInfo.db = null;
 
-    return _getOriginalConnection(dbInfo).then(function (db) {
-        dbInfo.db = db;
-        if (_isUpgradeNeeded(dbInfo)) {
-            // Reopen the database for upgrading.
-            return _getUpgradedConnection(dbInfo);
-        }
-        return db;
-    }).then(function (db) {
-        // store the latest db reference
-        // in case the db was upgraded
-        dbInfo.db = dbContext.db = db;
-        for (var i = 0; i < forages.length; i++) {
-            forages[i]._dbInfo.db = db;
-        }
-    })["catch"](function (err) {
-        _rejectReadiness(dbInfo, err);
-        throw err;
-    });
-}
-
-// FF doesn't like Promises (micro-tasks) and IDDB store operations,
-// so we have to do it with callbacks
-function createTransaction(dbInfo, mode, callback, retries) {
-    if (retries === undefined) {
-        retries = 1;
+    var queue = [];
+    function flush() {
+      for (var i = 0; i < queue.length; i++) {
+        var tuple = queue[i];
+        var callback = tuple[0], arg = tuple[1];
+        callback(arg);
+      }
+      queue = [];
     }
 
-    try {
-        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
-        callback(null, tx);
-    } catch (err) {
-        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
-            return Promise$1.resolve().then(function () {
-                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
-                    // increase the db version, to create the new ObjectStore
-                    if (dbInfo.db) {
-                        dbInfo.version = dbInfo.db.version + 1;
-                    }
-                    // Reopen the database for upgrading.
-                    return _getUpgradedConnection(dbInfo);
-                }
-            }).then(function () {
-                return _tryReconnect(dbInfo).then(function () {
-                    createTransaction(dbInfo, mode, callback, retries - 1);
-                });
-            })["catch"](callback);
-        }
+    var scheduleFlush;
 
-        callback(err);
+    // Decide what async method to use to triggering processing of queued callbacks:
+    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
+      scheduleFlush = useNextTick();
+    } else if (BrowserMutationObserver) {
+      scheduleFlush = useMutationObserver();
+    } else {
+      scheduleFlush = useSetTimeout();
     }
-}
-
-function createDbContext() {
-    return {
-        // Running localForages sharing a database.
-        forages: [],
-        // Shared database.
-        db: null,
-        // Database readiness (promise).
-        dbReady: null,
-        // Deferred operations on the database.
-        deferredOperations: []
-    };
-}
-
-// Open the IndexedDB database (automatically creates one if one didn't
-// previously exist), using any options set in the config.
-function _initStorage(options) {
-    var self = this;
-    var dbInfo = {
-        db: null
-    };
 
-    if (options) {
-        for (var i in options) {
-            dbInfo[i] = options[i];
-        }
+    function asap(callback, arg) {
+      var length = queue.push([callback, arg]);
+      if (length === 1) {
+        // If length is 1, that means that we need to schedule an async flush.
+        // If additional callbacks are queued before the queue is flushed, they
+        // will be processed by this flush that we are scheduling.
+        scheduleFlush();
+      }
     }
 
-    // Get the current context of the database;
-    var dbContext = dbContexts[dbInfo.name];
+    __exports__.asap = asap;
+  });
+define("promise/config", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    var config = {
+      instrument: false
+    };
 
-    // ...or create a new context.
-    if (!dbContext) {
-        dbContext = createDbContext();
-        // Register the new context in the global container.
-        dbContexts[dbInfo.name] = dbContext;
+    function configure(name, value) {
+      if (arguments.length === 2) {
+        config[name] = value;
+      } else {
+        return config[name];
+      }
     }
 
-    // Register itself as a running localForage in the current context.
-    dbContext.forages.push(self);
+    __exports__.config = config;
+    __exports__.configure = configure;
+  });
+define("promise/polyfill", 
+  ["./promise","./utils","exports"],
+  function(__dependency1__, __dependency2__, __exports__) {
+    "use strict";
+    /*global self*/
+    var RSVPPromise = __dependency1__.Promise;
+    var isFunction = __dependency2__.isFunction;
+
+    function polyfill() {
+      var local;
+
+      if (typeof global !== 'undefined') {
+        local = global;
+      } else if (typeof window !== 'undefined' && window.document) {
+        local = window;
+      } else {
+        local = self;
+      }
 
-    // Replace the default `ready()` function with the specialized one.
-    if (!self._initReady) {
-        self._initReady = self.ready;
-        self.ready = _fullyReady;
+      var es6PromiseSupport = 
+        "Promise" in local &&
+        // Some of these methods are missing from
+        // Firefox/Chrome experimental implementations
+        "resolve" in local.Promise &&
+        "reject" in local.Promise &&
+        "all" in local.Promise &&
+        "race" in local.Promise &&
+        // Older version of the spec had a resolver object
+        // as the arg rather than a function
+        (function() {
+          var resolve;
+          new local.Promise(function(r) { resolve = r; });
+          return isFunction(resolve);
+        }());
+
+      if (!es6PromiseSupport) {
+        local.Promise = RSVPPromise;
+      }
     }
 
-    // Create an array of initialization states of the related localForages.
-    var initPromises = [];
+    __exports__.polyfill = polyfill;
+  });
+define("promise/promise", 
+  ["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],
+  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
+    "use strict";
+    var config = __dependency1__.config;
+    var configure = __dependency1__.configure;
+    var objectOrFunction = __dependency2__.objectOrFunction;
+    var isFunction = __dependency2__.isFunction;
+    var now = __dependency2__.now;
+    var all = __dependency3__.all;
+    var race = __dependency4__.race;
+    var staticResolve = __dependency5__.resolve;
+    var staticReject = __dependency6__.reject;
+    var asap = __dependency7__.asap;
+
+    var counter = 0;
+
+    config.async = asap; // default async is asap;
+
+    function Promise(resolver) {
+      if (!isFunction(resolver)) {
+        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
+      }
 
-    function ignoreErrors() {
-        // Don't handle errors here,
-        // just makes sure related localForages aren't pending.
-        return Promise$1.resolve();
-    }
+      if (!(this instanceof Promise)) {
+        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
+      }
 
-    for (var j = 0; j < dbContext.forages.length; j++) {
-        var forage = dbContext.forages[j];
-        if (forage !== self) {
-            // Don't wait for itself...
-            initPromises.push(forage._initReady()["catch"](ignoreErrors));
-        }
+      this._subscribers = [];
+
+      invokeResolver(resolver, this);
     }
 
-    // Take a snapshot of the related localForages.
-    var forages = dbContext.forages.slice(0);
-
-    // Initialize the connection process only when
-    // all the related localForages aren't pending.
-    return Promise$1.all(initPromises).then(function () {
-        dbInfo.db = dbContext.db;
-        // Get the connection or open a new one without upgrade.
-        return _getOriginalConnection(dbInfo);
-    }).then(function (db) {
-        dbInfo.db = db;
-        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
-            // Reopen the database for upgrading.
-            return _getUpgradedConnection(dbInfo);
-        }
-        return db;
-    }).then(function (db) {
-        dbInfo.db = dbContext.db = db;
-        self._dbInfo = dbInfo;
-        // Share the final connection amongst related localForages.
-        for (var k = 0; k < forages.length; k++) {
-            var forage = forages[k];
-            if (forage !== self) {
-                // Self is already up-to-date.
-                forage._dbInfo.db = dbInfo.db;
-                forage._dbInfo.version = dbInfo.version;
-            }
-        }
-    });
-}
-
-function getItem(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.get(key);
-
-                    req.onsuccess = function () {
-                        var value = req.result;
-                        if (value === undefined) {
-                            value = null;
-                        }
-                        if (_isEncodedBlob(value)) {
-                            value = _decodeBlob(value);
-                        }
-                        resolve(value);
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Iterate over all items stored in database.
-function iterate(iterator, callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.openCursor();
-                    var iterationNumber = 1;
-
-                    req.onsuccess = function () {
-                        var cursor = req.result;
-
-                        if (cursor) {
-                            var value = cursor.value;
-                            if (_isEncodedBlob(value)) {
-                                value = _decodeBlob(value);
-                            }
-                            var result = iterator(value, cursor.key, iterationNumber++);
-
-                            // when the iterator callback retuns any
-                            // (non-`undefined`) value, then we stop
-                            // the iteration immediately
-                            if (result !== void 0) {
-                                resolve(result);
-                            } else {
-                                cursor["continue"]();
-                            }
-                        } else {
-                            resolve();
-                        }
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-
-    return promise;
-}
-
-function setItem(key, value, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        var dbInfo;
-        self.ready().then(function () {
-            dbInfo = self._dbInfo;
-            if (toString.call(value) === '[object Blob]') {
-                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
-                    if (blobSupport) {
-                        return value;
-                    }
-                    return _encodeBlob(value);
-                });
-            }
-            return value;
-        }).then(function (value) {
-            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-
-                    // The reason we don't _save_ null is because IE 10 does
-                    // not support saving the `null` type in IndexedDB. How
-                    // ironic, given the bug below!
-                    // See: https://github.com/mozilla/localForage/issues/161
-                    if (value === null) {
-                        value = undefined;
-                    }
-
-                    var req = store.put(value, key);
-
-                    transaction.oncomplete = function () {
-                        // Cast to undefined so the value passed to
-                        // callback/promise is the same as what one would get out
-                        // of `getItem()` later. This leads to some weirdness
-                        // (setItem('foo', undefined) will return `null`), but
-                        // it's not my fault localStorage is our baseline and that
-                        // it's weird.
-                        if (value === undefined) {
-                            value = null;
-                        }
-
-                        resolve(value);
-                    };
-                    transaction.onabort = transaction.onerror = function () {
-                        var err = req.error ? req.error : req.transaction.error;
-                        reject(err);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function removeItem(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    // We use a Grunt task to make this safe for IE and some
-                    // versions of Android (including those used by Cordova).
-                    // Normally IE won't like `.delete()` and will insist on
-                    // using `['delete']()`, but we have a build step that
-                    // fixes this for us now.
-                    var req = store["delete"](key);
-                    transaction.oncomplete = function () {
-                        resolve();
-                    };
-
-                    transaction.onerror = function () {
-                        reject(req.error);
-                    };
-
-                    // The request will be also be aborted if we've exceeded our storage
-                    // space.
-                    transaction.onabort = function () {
-                        var err = req.error ? req.error : req.transaction.error;
-                        reject(err);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function clear(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.clear();
-
-                    transaction.oncomplete = function () {
-                        resolve();
-                    };
-
-                    transaction.onabort = transaction.onerror = function () {
-                        var err = req.error ? req.error : req.transaction.error;
-                        reject(err);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function length(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.count();
-
-                    req.onsuccess = function () {
-                        resolve(req.result);
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
+    function invokeResolver(resolver, promise) {
+      function resolvePromise(value) {
+        resolve(promise, value);
+      }
 
-    executeCallback(promise, callback);
-    return promise;
-}
+      function rejectPromise(reason) {
+        reject(promise, reason);
+      }
 
-function key(n, callback) {
-    var self = this;
+      try {
+        resolver(resolvePromise, rejectPromise);
+      } catch(e) {
+        rejectPromise(e);
+      }
+    }
 
-    var promise = new Promise$1(function (resolve, reject) {
-        if (n < 0) {
-            resolve(null);
+    function invokeCallback(settled, promise, callback, detail) {
+      var hasCallback = isFunction(callback),
+          value, error, succeeded, failed;
 
-            return;
+      if (hasCallback) {
+        try {
+          value = callback(detail);
+          succeeded = true;
+        } catch(e) {
+          failed = true;
+          error = e;
         }
+      } else {
+        value = detail;
+        succeeded = true;
+      }
 
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var advanced = false;
-                    var req = store.openCursor();
-
-                    req.onsuccess = function () {
-                        var cursor = req.result;
-                        if (!cursor) {
-                            // this means there weren't enough keys
-                            resolve(null);
-
-                            return;
-                        }
-
-                        if (n === 0) {
-                            // We have the first key, return it if that's what they
-                            // wanted.
-                            resolve(cursor.key);
-                        } else {
-                            if (!advanced) {
-                                // Otherwise, ask the cursor to skip ahead n
-                                // records.
-                                advanced = true;
-                                cursor.advance(n);
-                            } else {
-                                // When we get here, we've got the nth key.
-                                resolve(cursor.key);
-                            }
-                        }
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function keys(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
-                if (err) {
-                    return reject(err);
-                }
-
-                try {
-                    var store = transaction.objectStore(self._dbInfo.storeName);
-                    var req = store.openCursor();
-                    var keys = [];
-
-                    req.onsuccess = function () {
-                        var cursor = req.result;
-
-                        if (!cursor) {
-                            resolve(keys);
-                            return;
-                        }
-
-                        keys.push(cursor.key);
-                        cursor["continue"]();
-                    };
-
-                    req.onerror = function () {
-                        reject(req.error);
-                    };
-                } catch (e) {
-                    reject(e);
-                }
-            });
-        })["catch"](reject);
-    });
+      if (handleThenable(promise, value)) {
+        return;
+      } else if (hasCallback && succeeded) {
+        resolve(promise, value);
+      } else if (failed) {
+        reject(promise, error);
+      } else if (settled === FULFILLED) {
+        resolve(promise, value);
+      } else if (settled === REJECTED) {
+        reject(promise, value);
+      }
+    }
 
-    executeCallback(promise, callback);
-    return promise;
-}
+    var PENDING   = void 0;
+    var SEALED    = 0;
+    var FULFILLED = 1;
+    var REJECTED  = 2;
 
-function dropInstance(options, callback) {
-    callback = getCallback.apply(this, arguments);
+    function subscribe(parent, child, onFulfillment, onRejection) {
+      var subscribers = parent._subscribers;
+      var length = subscribers.length;
 
-    var currentConfig = this.config();
-    options = typeof options !== 'function' && options || {};
-    if (!options.name) {
-        options.name = options.name || currentConfig.name;
-        options.storeName = options.storeName || currentConfig.storeName;
+      subscribers[length] = child;
+      subscribers[length + FULFILLED] = onFulfillment;
+      subscribers[length + REJECTED]  = onRejection;
     }
 
-    var self = this;
-    var promise;
-    if (!options.name) {
-        promise = Promise$1.reject('Invalid arguments');
-    } else {
-        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;
-
-        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
-            var dbContext = dbContexts[options.name];
-            var forages = dbContext.forages;
-            dbContext.db = db;
-            for (var i = 0; i < forages.length; i++) {
-                forages[i]._dbInfo.db = db;
-            }
-            return db;
-        });
-
-        if (!options.storeName) {
-            promise = dbPromise.then(function (db) {
-                _deferReadiness(options);
-
-                var dbContext = dbContexts[options.name];
-                var forages = dbContext.forages;
-
-                db.close();
-                for (var i = 0; i < forages.length; i++) {
-                    var forage = forages[i];
-                    forage._dbInfo.db = null;
-                }
-
-                var dropDBPromise = new Promise$1(function (resolve, reject) {
-                    var req = idb.deleteDatabase(options.name);
-
-                    req.onerror = req.onblocked = function (err) {
-                        var db = req.result;
-                        if (db) {
-                            db.close();
-                        }
-                        reject(err);
-                    };
-
-                    req.onsuccess = function () {
-                        var db = req.result;
-                        if (db) {
-                            db.close();
-                        }
-                        resolve(db);
-                    };
-                });
-
-                return dropDBPromise.then(function (db) {
-                    dbContext.db = db;
-                    for (var i = 0; i < forages.length; i++) {
-                        var _forage = forages[i];
-                        _advanceReadiness(_forage._dbInfo);
-                    }
-                })["catch"](function (err) {
-                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
-                    throw err;
-                });
-            });
-        } else {
-            promise = dbPromise.then(function (db) {
-                if (!db.objectStoreNames.contains(options.storeName)) {
-                    return;
-                }
-
-                var newVersion = db.version + 1;
-
-                _deferReadiness(options);
-
-                var dbContext = dbContexts[options.name];
-                var forages = dbContext.forages;
-
-                db.close();
-                for (var i = 0; i < forages.length; i++) {
-                    var forage = forages[i];
-                    forage._dbInfo.db = null;
-                    forage._dbInfo.version = newVersion;
-                }
-
-                var dropObjectPromise = new Promise$1(function (resolve, reject) {
-                    var req = idb.open(options.name, newVersion);
-
-                    req.onerror = function (err) {
-                        var db = req.result;
-                        db.close();
-                        reject(err);
-                    };
-
-                    req.onupgradeneeded = function () {
-                        var db = req.result;
-                        db.deleteObjectStore(options.storeName);
-                    };
-
-                    req.onsuccess = function () {
-                        var db = req.result;
-                        db.close();
-                        resolve(db);
-                    };
-                });
-
-                return dropObjectPromise.then(function (db) {
-                    dbContext.db = db;
-                    for (var j = 0; j < forages.length; j++) {
-                        var _forage2 = forages[j];
-                        _forage2._dbInfo.db = db;
-                        _advanceReadiness(_forage2._dbInfo);
-                    }
-                })["catch"](function (err) {
-                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
-                    throw err;
-                });
-            });
-        }
-    }
+    function publish(promise, settled) {
+      var child, callback, subscribers = promise._subscribers, detail = promise._detail;
 
-    executeCallback(promise, callback);
-    return promise;
-}
-
-var asyncStorage = {
-    _driver: 'asyncStorage',
-    _initStorage: _initStorage,
-    _support: isIndexedDBValid(),
-    iterate: iterate,
-    getItem: getItem,
-    setItem: setItem,
-    removeItem: removeItem,
-    clear: clear,
-    length: length,
-    key: key,
-    keys: keys,
-    dropInstance: dropInstance
-};
-
-function isWebSQLValid() {
-    return typeof openDatabase === 'function';
-}
-
-// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
-// it to Base64, so this is how we store it to prevent very strange errors with less
-// verbose ways of binary <-> string data storage.
-var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
-
-var BLOB_TYPE_PREFIX = '~~local_forage_type~';
-var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
-
-var SERIALIZED_MARKER = '__lfsc__:';
-var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
-
-// OMG the serializations!
-var TYPE_ARRAYBUFFER = 'arbf';
-var TYPE_BLOB = 'blob';
-var TYPE_INT8ARRAY = 'si08';
-var TYPE_UINT8ARRAY = 'ui08';
-var TYPE_UINT8CLAMPEDARRAY = 'uic8';
-var TYPE_INT16ARRAY = 'si16';
-var TYPE_INT32ARRAY = 'si32';
-var TYPE_UINT16ARRAY = 'ur16';
-var TYPE_UINT32ARRAY = 'ui32';
-var TYPE_FLOAT32ARRAY = 'fl32';
-var TYPE_FLOAT64ARRAY = 'fl64';
-var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
-
-var toString$1 = Object.prototype.toString;
-
-function stringToBuffer(serializedString) {
-    // Fill the string into a ArrayBuffer.
-    var bufferLength = serializedString.length * 0.75;
-    var len = serializedString.length;
-    var i;
-    var p = 0;
-    var encoded1, encoded2, encoded3, encoded4;
-
-    if (serializedString[serializedString.length - 1] === '=') {
-        bufferLength--;
-        if (serializedString[serializedString.length - 2] === '=') {
-            bufferLength--;
-        }
-    }
+      for (var i = 0; i < subscribers.length; i += 3) {
+        child = subscribers[i];
+        callback = subscribers[i + settled];
 
-    var buffer = new ArrayBuffer(bufferLength);
-    var bytes = new Uint8Array(buffer);
-
-    for (i = 0; i < len; i += 4) {
-        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
-        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
-        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
-        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
+        invokeCallback(settled, child, callback, detail);
+      }
 
-        /*jslint bitwise: true */
-        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
-        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
-        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
-    }
-    return buffer;
-}
-
-// Converts a buffer to a string to store, serialized, in the backend
-// storage library.
-function bufferToString(buffer) {
-    // base64-arraybuffer
-    var bytes = new Uint8Array(buffer);
-    var base64String = '';
-    var i;
-
-    for (i = 0; i < bytes.length; i += 3) {
-        /*jslint bitwise: true */
-        base64String += BASE_CHARS[bytes[i] >> 2];
-        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
-        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
-        base64String += BASE_CHARS[bytes[i + 2] & 63];
+      promise._subscribers = null;
     }
 
-    if (bytes.length % 3 === 2) {
-        base64String = base64String.substring(0, base64String.length - 1) + '=';
-    } else if (bytes.length % 3 === 1) {
-        base64String = base64String.substring(0, base64String.length - 2) + '==';
-    }
+    Promise.prototype = {
+      constructor: Promise,
 
-    return base64String;
-}
+      _state: undefined,
+      _detail: undefined,
+      _subscribers: undefined,
 
-// Serialize a value, afterwards executing a callback (which usually
-// instructs the `setItem()` callback/promise to be executed). This is how
-// we store binary data with localStorage.
-function serialize(value, callback) {
-    var valueType = '';
-    if (value) {
-        valueType = toString$1.call(value);
-    }
+      then: function(onFulfillment, onRejection) {
+        var promise = this;
+
+        var thenPromise = new this.constructor(function() {});
 
-    // Cannot use `value instanceof ArrayBuffer` or such here, as these
-    // checks fail when running the tests using casper.js...
-    //
-    // TODO: See why those tests fail and use a better solution.
-    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
-        // Convert binary arrays to a string and prefix the string with
-        // a special marker.
-        var buffer;
-        var marker = SERIALIZED_MARKER;
-
-        if (value instanceof ArrayBuffer) {
-            buffer = value;
-            marker += TYPE_ARRAYBUFFER;
+        if (this._state) {
+          var callbacks = arguments;
+          config.async(function invokePromiseCallback() {
+            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
+          });
         } else {
-            buffer = value.buffer;
-
-            if (valueType === '[object Int8Array]') {
-                marker += TYPE_INT8ARRAY;
-            } else if (valueType === '[object Uint8Array]') {
-                marker += TYPE_UINT8ARRAY;
-            } else if (valueType === '[object Uint8ClampedArray]') {
-                marker += TYPE_UINT8CLAMPEDARRAY;
-            } else if (valueType === '[object Int16Array]') {
-                marker += TYPE_INT16ARRAY;
-            } else if (valueType === '[object Uint16Array]') {
-                marker += TYPE_UINT16ARRAY;
-            } else if (valueType === '[object Int32Array]') {
-                marker += TYPE_INT32ARRAY;
-            } else if (valueType === '[object Uint32Array]') {
-                marker += TYPE_UINT32ARRAY;
-            } else if (valueType === '[object Float32Array]') {
-                marker += TYPE_FLOAT32ARRAY;
-            } else if (valueType === '[object Float64Array]') {
-                marker += TYPE_FLOAT64ARRAY;
-            } else {
-                callback(new Error('Failed to get type for BinaryArray'));
-            }
+          subscribe(this, thenPromise, onFulfillment, onRejection);
         }
 
-        callback(marker + bufferToString(buffer));
-    } else if (valueType === '[object Blob]') {
-        // Conver the blob to a binaryArray and then to a string.
-        var fileReader = new FileReader();
+        return thenPromise;
+      },
 
-        fileReader.onload = function () {
-            // Backwards-compatible prefix for the blob type.
-            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);
+      'catch': function(onRejection) {
+        return this.then(null, onRejection);
+      }
+    };
 
-            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
-        };
+    Promise.all = all;
+    Promise.race = race;
+    Promise.resolve = staticResolve;
+    Promise.reject = staticReject;
 
-        fileReader.readAsArrayBuffer(value);
-    } else {
-        try {
-            callback(JSON.stringify(value));
-        } catch (e) {
-            console.error("Couldn't convert value into a JSON string: ", value);
+    function handleThenable(promise, value) {
+      var then = null,
+      resolved;
 
-            callback(null, e);
+      try {
+        if (promise === value) {
+          throw new TypeError("A promises callback cannot return that same promise.");
         }
-    }
-}
-
-// Deserialize data we've inserted into a value column/field. We place
-// special markers into our strings to mark them as encoded; this isn't
-// as nice as a meta field, but it's the only sane thing we can do whilst
-// keeping localStorage support intact.
-//
-// Oftentimes this will just deserialize JSON content, but if we have a
-// special marker (SERIALIZED_MARKER, defined above), we will extract
-// some kind of arraybuffer/binary data/typed array out of the string.
-function deserialize(value) {
-    // If we haven't marked this string as being specially serialized (i.e.
-    // something other than serialized JSON), we can just return it and be
-    // done with it.
-    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
-        return JSON.parse(value);
-    }
 
-    // The following code deals with deserializing some kind of Blob or
-    // TypedArray. First we separate out the type of data we're dealing
-    // with from the data itself.
-    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
-    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
-
-    var blobType;
-    // Backwards-compatible blob type serialization strategy.
-    // DBs created with older versions of localForage will simply not have the blob type.
-    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
-        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
-        blobType = matcher[1];
-        serializedString = serializedString.substring(matcher[0].length);
-    }
-    var buffer = stringToBuffer(serializedString);
-
-    // Return the right type based on the code/type set during
-    // serialization.
-    switch (type) {
-        case TYPE_ARRAYBUFFER:
-            return buffer;
-        case TYPE_BLOB:
-            return createBlob([buffer], { type: blobType });
-        case TYPE_INT8ARRAY:
-            return new Int8Array(buffer);
-        case TYPE_UINT8ARRAY:
-            return new Uint8Array(buffer);
-        case TYPE_UINT8CLAMPEDARRAY:
-            return new Uint8ClampedArray(buffer);
-        case TYPE_INT16ARRAY:
-            return new Int16Array(buffer);
-        case TYPE_UINT16ARRAY:
-            return new Uint16Array(buffer);
-        case TYPE_INT32ARRAY:
-            return new Int32Array(buffer);
-        case TYPE_UINT32ARRAY:
-            return new Uint32Array(buffer);
-        case TYPE_FLOAT32ARRAY:
-            return new Float32Array(buffer);
-        case TYPE_FLOAT64ARRAY:
-            return new Float64Array(buffer);
-        default:
-            throw new Error('Unkown type: ' + type);
-    }
-}
-
-var localforageSerializer = {
-    serialize: serialize,
-    deserialize: deserialize,
-    stringToBuffer: stringToBuffer,
-    bufferToString: bufferToString
-};
-
-/*
- * Includes code from:
- *
- * base64-arraybuffer
- * https://github.com/niklasvh/base64-arraybuffer
- *
- * Copyright (c) 2012 Niklas von Hertzen
- * Licensed under the MIT license.
- */
-
-function createDbTable(t, dbInfo, callback, errorCallback) {
-    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
-}
-
-// Open the WebSQL database (automatically creates one if one didn't
-// previously exist), using any options set in the config.
-function _initStorage$1(options) {
-    var self = this;
-    var dbInfo = {
-        db: null
-    };
+        if (objectOrFunction(value)) {
+          then = value.then;
 
-    if (options) {
-        for (var i in options) {
-            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
-        }
-    }
+          if (isFunction(then)) {
+            then.call(value, function(val) {
+              if (resolved) { return true; }
+              resolved = true;
 
-    var dbInfoPromise = new Promise$1(function (resolve, reject) {
-        // Open the database; the openDatabase API will automatically
-        // create it for us if it doesn't exist.
-        try {
-            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
-        } catch (e) {
-            return reject(e);
-        }
+              if (value !== val) {
+                resolve(promise, val);
+              } else {
+                fulfill(promise, val);
+              }
+            }, function(val) {
+              if (resolved) { return true; }
+              resolved = true;
 
-        // Create our key/value table if it doesn't exist.
-        dbInfo.db.transaction(function (t) {
-            createDbTable(t, dbInfo, function () {
-                self._dbInfo = dbInfo;
-                resolve();
-            }, function (t, error) {
-                reject(error);
+              reject(promise, val);
             });
-        }, reject);
-    });
-
-    dbInfo.serializer = localforageSerializer;
-    return dbInfoPromise;
-}
-
-function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
-    t.executeSql(sqlStatement, args, callback, function (t, error) {
-        if (error.code === error.SYNTAX_ERR) {
-            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [name], function (t, results) {
-                if (!results.rows.length) {
-                    // if the table is missing (was deleted)
-                    // re-create it table and retry
-                    createDbTable(t, dbInfo, function () {
-                        t.executeSql(sqlStatement, args, callback, errorCallback);
-                    }, errorCallback);
-                } else {
-                    errorCallback(t, error);
-                }
-            }, errorCallback);
-        } else {
-            errorCallback(t, error);
+
+            return true;
+          }
         }
-    }, errorCallback);
-}
-
-function getItem$1(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
-                    var result = results.rows.length ? results.rows.item(0).value : null;
-
-                    // Check to see if this is serialized content we need to
-                    // unpack.
-                    if (result) {
-                        result = dbInfo.serializer.deserialize(result);
-                    }
-
-                    resolve(result);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function iterate$1(iterator, callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
-                    var rows = results.rows;
-                    var length = rows.length;
-
-                    for (var i = 0; i < length; i++) {
-                        var item = rows.item(i);
-                        var result = item.value;
-
-                        // Check to see if this is serialized content
-                        // we need to unpack.
-                        if (result) {
-                            result = dbInfo.serializer.deserialize(result);
-                        }
-
-                        result = iterator(result, item.key, i + 1);
-
-                        // void(0) prevents problems with redefinition
-                        // of `undefined`.
-                        if (result !== void 0) {
-                            resolve(result);
-                            return;
-                        }
-                    }
-
-                    resolve();
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function _setItem(key, value, callback, retriesLeft) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            // The localStorage API doesn't return undefined values in an
-            // "expected" way, so undefined is always cast to null in all
-            // drivers. See: https://github.com/mozilla/localForage/pull/42
-            if (value === undefined) {
-                value = null;
-            }
-
-            // Save the original value to pass to the callback.
-            var originalValue = value;
-
-            var dbInfo = self._dbInfo;
-            dbInfo.serializer.serialize(value, function (value, error) {
-                if (error) {
-                    reject(error);
-                } else {
-                    dbInfo.db.transaction(function (t) {
-                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
-                            resolve(originalValue);
-                        }, function (t, error) {
-                            reject(error);
-                        });
-                    }, function (sqlError) {
-                        // The transaction failed; check
-                        // to see if it's a quota error.
-                        if (sqlError.code === sqlError.QUOTA_ERR) {
-                            // We reject the callback outright for now, but
-                            // it's worth trying to re-run the transaction.
-                            // Even if the user accepts the prompt to use
-                            // more storage on Safari, this error will
-                            // be called.
-                            //
-                            // Try to re-run the transaction.
-                            if (retriesLeft > 0) {
-                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
-                                return;
-                            }
-                            reject(sqlError);
-                        }
-                    });
-                }
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function setItem$1(key, value, callback) {
-    return _setItem.apply(this, [key, value, callback, 1]);
-}
-
-function removeItem$1(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
-                    resolve();
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Deletes every item in the table.
-// TODO: Find out if this resets the AUTO_INCREMENT number.
-function clear$1(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
-                    resolve();
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Does a simple `COUNT(key)` to get the number of items stored in
-// localForage.
-function length$1(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                // Ahhh, SQL makes this one soooooo easy.
-                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
-                    var result = results.rows.item(0).c;
-                    resolve(result);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Return the key located at key index X; essentially gets the key from a
-// `WHERE id = ?`. This is the most efficient way I can think to implement
-// this rarely-used (in my experience) part of the API, but it can seem
-// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
-// the ID of each key will change every time it's updated. Perhaps a stored
-// procedure for the `setItem()` SQL would solve this problem?
-// TODO: Don't change ID on `setItem()`.
-function key$1(n, callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
-                    var result = results.rows.length ? results.rows.item(0).key : null;
-                    resolve(result);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function keys$1(callback) {
-    var self = this;
-
-    var promise = new Promise$1(function (resolve, reject) {
-        self.ready().then(function () {
-            var dbInfo = self._dbInfo;
-            dbInfo.db.transaction(function (t) {
-                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
-                    var keys = [];
-
-                    for (var i = 0; i < results.rows.length; i++) {
-                        keys.push(results.rows.item(i).key);
-                    }
-
-                    resolve(keys);
-                }, function (t, error) {
-                    reject(error);
-                });
-            });
-        })["catch"](reject);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// https://www.w3.org/TR/webdatabase/#databases
-// > There is no way to enumerate or delete the databases available for an origin from this API.
-function getAllStoreNames(db) {
-    return new Promise$1(function (resolve, reject) {
-        db.transaction(function (t) {
-            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
-                var storeNames = [];
-
-                for (var i = 0; i < results.rows.length; i++) {
-                    storeNames.push(results.rows.item(i).name);
-                }
-
-                resolve({
-                    db: db,
-                    storeNames: storeNames
-                });
-            }, function (t, error) {
-                reject(error);
-            });
-        }, function (sqlError) {
-            reject(sqlError);
-        });
-    });
-}
-
-function dropInstance$1(options, callback) {
-    callback = getCallback.apply(this, arguments);
-
-    var currentConfig = this.config();
-    options = typeof options !== 'function' && options || {};
-    if (!options.name) {
-        options.name = options.name || currentConfig.name;
-        options.storeName = options.storeName || currentConfig.storeName;
-    }
+      } catch (error) {
+        if (resolved) { return true; }
+        reject(promise, error);
+        return true;
+      }
 
-    var self = this;
-    var promise;
-    if (!options.name) {
-        promise = Promise$1.reject('Invalid arguments');
-    } else {
-        promise = new Promise$1(function (resolve) {
-            var db;
-            if (options.name === currentConfig.name) {
-                // use the db reference of the current instance
-                db = self._dbInfo.db;
-            } else {
-                db = openDatabase(options.name, '', '', 0);
-            }
-
-            if (!options.storeName) {
-                // drop all database tables
-                resolve(getAllStoreNames(db));
-            } else {
-                resolve({
-                    db: db,
-                    storeNames: [options.storeName]
-                });
-            }
-        }).then(function (operationInfo) {
-            return new Promise$1(function (resolve, reject) {
-                operationInfo.db.transaction(function (t) {
-                    function dropTable(storeName) {
-                        return new Promise$1(function (resolve, reject) {
-                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
-                                resolve();
-                            }, function (t, error) {
-                                reject(error);
-                            });
-                        });
-                    }
-
-                    var operations = [];
-                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
-                        operations.push(dropTable(operationInfo.storeNames[i]));
-                    }
-
-                    Promise$1.all(operations).then(function () {
-                        resolve();
-                    })["catch"](function (e) {
-                        reject(e);
-                    });
-                }, function (sqlError) {
-                    reject(sqlError);
-                });
-            });
-        });
+      return false;
     }
 
-    executeCallback(promise, callback);
-    return promise;
-}
-
-var webSQLStorage = {
-    _driver: 'webSQLStorage',
-    _initStorage: _initStorage$1,
-    _support: isWebSQLValid(),
-    iterate: iterate$1,
-    getItem: getItem$1,
-    setItem: setItem$1,
-    removeItem: removeItem$1,
-    clear: clear$1,
-    length: length$1,
-    key: key$1,
-    keys: keys$1,
-    dropInstance: dropInstance$1
-};
-
-function isLocalStorageValid() {
-    try {
-        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
-        // in IE8 typeof localStorage.setItem === 'object'
-        !!localStorage.setItem;
-    } catch (e) {
-        return false;
+    function resolve(promise, value) {
+      if (promise === value) {
+        fulfill(promise, value);
+      } else if (!handleThenable(promise, value)) {
+        fulfill(promise, value);
+      }
     }
-}
 
-function _getKeyPrefix(options, defaultConfig) {
-    var keyPrefix = options.name + '/';
+    function fulfill(promise, value) {
+      if (promise._state !== PENDING) { return; }
+      promise._state = SEALED;
+      promise._detail = value;
 
-    if (options.storeName !== defaultConfig.storeName) {
-        keyPrefix += options.storeName + '/';
+      config.async(publishFulfillment, promise);
     }
-    return keyPrefix;
-}
 
-// Check if localStorage throws when saving an item
-function checkIfLocalStorageThrows() {
-    var localStorageTestKey = '_localforage_support_test';
+    function reject(promise, reason) {
+      if (promise._state !== PENDING) { return; }
+      promise._state = SEALED;
+      promise._detail = reason;
 
-    try {
-        localStorage.setItem(localStorageTestKey, true);
-        localStorage.removeItem(localStorageTestKey);
-
-        return false;
-    } catch (e) {
-        return true;
-    }
-}
-
-// Check if localStorage is usable and allows to save an item
-// This method checks if localStorage is usable in Safari Private Browsing
-// mode, or in any other case where the available quota for localStorage
-// is 0 and there wasn't any saved items yet.
-function _isLocalStorageUsable() {
-    return !checkIfLocalStorageThrows() || localStorage.length > 0;
-}
-
-// Config the localStorage backend, using options set in the config.
-function _initStorage$2(options) {
-    var self = this;
-    var dbInfo = {};
-    if (options) {
-        for (var i in options) {
-            dbInfo[i] = options[i];
-        }
+      config.async(publishRejection, promise);
     }
 
-    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);
-
-    if (!_isLocalStorageUsable()) {
-        return Promise$1.reject();
+    function publishFulfillment(promise) {
+      publish(promise, promise._state = FULFILLED);
     }
 
-    self._dbInfo = dbInfo;
-    dbInfo.serializer = localforageSerializer;
-
-    return Promise$1.resolve();
-}
-
-// Remove all keys from the datastore, effectively destroying all data in
-// the app's key/value store!
-function clear$2(callback) {
-    var self = this;
-    var promise = self.ready().then(function () {
-        var keyPrefix = self._dbInfo.keyPrefix;
-
-        for (var i = localStorage.length - 1; i >= 0; i--) {
-            var key = localStorage.key(i);
-
-            if (key.indexOf(keyPrefix) === 0) {
-                localStorage.removeItem(key);
-            }
-        }
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Retrieve an item from the store. Unlike the original async_storage
-// library in Gaia, we don't modify return values at all. If a key's value
-// is `undefined`, we pass that value to the callback function.
-function getItem$2(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var result = localStorage.getItem(dbInfo.keyPrefix + key);
-
-        // If a result was found, parse it from the serialized
-        // string into a JS object. If result isn't truthy, the key
-        // is likely undefined and we'll pass it straight to the
-        // callback.
-        if (result) {
-            result = dbInfo.serializer.deserialize(result);
-        }
-
-        return result;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Iterate over all items in the store.
-function iterate$2(iterator, callback) {
-    var self = this;
-
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var keyPrefix = dbInfo.keyPrefix;
-        var keyPrefixLength = keyPrefix.length;
-        var length = localStorage.length;
-
-        // We use a dedicated iterator instead of the `i` variable below
-        // so other keys we fetch in localStorage aren't counted in
-        // the `iterationNumber` argument passed to the `iterate()`
-        // callback.
-        //
-        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
-        var iterationNumber = 1;
-
-        for (var i = 0; i < length; i++) {
-            var key = localStorage.key(i);
-            if (key.indexOf(keyPrefix) !== 0) {
-                continue;
-            }
-            var value = localStorage.getItem(key);
-
-            // If a result was found, parse it from the serialized
-            // string into a JS object. If result isn't truthy, the
-            // key is likely undefined and we'll pass it straight
-            // to the iterator.
-            if (value) {
-                value = dbInfo.serializer.deserialize(value);
-            }
-
-            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);
-
-            if (value !== void 0) {
-                return value;
-            }
-        }
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Same as localStorage's key() method, except takes a callback.
-function key$2(n, callback) {
-    var self = this;
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var result;
-        try {
-            result = localStorage.key(n);
-        } catch (error) {
-            result = null;
-        }
+    function publishRejection(promise) {
+      publish(promise, promise._state = REJECTED);
+    }
 
-        // Remove the prefix from the key, if a key is found.
-        if (result) {
-            result = result.substring(dbInfo.keyPrefix.length);
-        }
+    __exports__.Promise = Promise;
+  });
+define("promise/race", 
+  ["./utils","exports"],
+  function(__dependency1__, __exports__) {
+    "use strict";
+    /* global toString */
+    var isArray = __dependency1__.isArray;
+
+    /**
+      `RSVP.race` allows you to watch a series of promises and act as soon as the
+      first promise given to the `promises` argument fulfills or rejects.
+      Example:
+      ```javascript
+      var promise1 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          resolve("promise 1");
+        }, 200);
+      });
+      var promise2 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          resolve("promise 2");
+        }, 100);
+      });
+      RSVP.race([promise1, promise2]).then(function(result){
+        // result === "promise 2" because it was resolved before promise1
+        // was resolved.
+      });
+      ```
+      `RSVP.race` is deterministic in that only the state of the first completed
+      promise matters. For example, even if other promises given to the `promises`
+      array argument are resolved, but the first completed promise has become
+      rejected before the other promises became fulfilled, the returned promise
+      will become rejected:
+      ```javascript
+      var promise1 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          resolve("promise 1");
+        }, 200);
+      });
+      var promise2 = new RSVP.Promise(function(resolve, reject){
+        setTimeout(function(){
+          reject(new Error("promise 2"));
+        }, 100);
+      });
+      RSVP.race([promise1, promise2]).then(function(result){
+        // Code here never runs because there are rejected promises!
+      }, function(reason){
+        // reason.message === "promise2" because promise 2 became rejected before
+        // promise 1 became fulfilled
+      });
+      ```
+      @method race
+      @for RSVP
+      @param {Array} promises array of promises to observe
+      @param {String} label optional string for describing the promise returned.
+      Useful for tooling.
+      @return {Promise} a promise that becomes fulfilled with the value the first
+      completed promises is resolved with if the first completed promise was
+      fulfilled, or rejected with the reason that the first completed promise
+      was rejected with.
+    */
+    function race(promises) {
+      /*jshint validthis:true */
+      var Promise = this;
+
+      if (!isArray(promises)) {
+        throw new TypeError('You must pass an array to race.');
+      }
+      return new Promise(function(resolve, reject) {
+        var results = [], promise;
 
-        return result;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function keys$2(callback) {
-    var self = this;
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        var length = localStorage.length;
-        var keys = [];
-
-        for (var i = 0; i < length; i++) {
-            var itemKey = localStorage.key(i);
-            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
-                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
-            }
-        }
+        for (var i = 0; i < promises.length; i++) {
+          promise = promises[i];
 
-        return keys;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Supply the number of keys in the datastore to the callback function.
-function length$2(callback) {
-    var self = this;
-    var promise = self.keys().then(function (keys) {
-        return keys.length;
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Remove an item from the store, nice and simple.
-function removeItem$2(key, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = self.ready().then(function () {
-        var dbInfo = self._dbInfo;
-        localStorage.removeItem(dbInfo.keyPrefix + key);
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-// Set a key's value and run an optional callback once the value is set.
-// Unlike Gaia's implementation, the callback function is passed the value,
-// in case you want to operate on that value only after you're sure it
-// saved, or something like that.
-function setItem$2(key, value, callback) {
-    var self = this;
-
-    key = normalizeKey(key);
-
-    var promise = self.ready().then(function () {
-        // Convert undefined values to null.
-        // https://github.com/mozilla/localForage/pull/42
-        if (value === undefined) {
-            value = null;
+          if (promise && typeof promise.then === 'function') {
+            promise.then(resolve, reject);
+          } else {
+            resolve(promise);
+          }
         }
-
-        // Save the original value to pass to the callback.
-        var originalValue = value;
-
-        return new Promise$1(function (resolve, reject) {
-            var dbInfo = self._dbInfo;
-            dbInfo.serializer.serialize(value, function (value, error) {
-                if (error) {
-                    reject(error);
-                } else {
-                    try {
-                        localStorage.setItem(dbInfo.keyPrefix + key, value);
-                        resolve(originalValue);
-                    } catch (e) {
-                        // localStorage capacity exceeded.
-                        // TODO: Make this a specific error/event.
-                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
-                            reject(e);
-                        }
-                        reject(e);
-                    }
-                }
-            });
-        });
-    });
-
-    executeCallback(promise, callback);
-    return promise;
-}
-
-function dropInstance$2(options, callback) {
-    callback = getCallback.apply(this, arguments);
-
-    options = typeof options !== 'function' && options || {};
-    if (!options.name) {
-        var currentConfig = this.config();
-        options.name = options.name || currentConfig.name;
-        options.storeName = options.storeName || currentConfig.storeName;
-    }
-
-    var self = this;
-    var promise;
-    if (!options.name) {
-        promise = Promise$1.reject('Invalid arguments');
-    } else {
-        promise = new Promise$1(function (resolve) {
-            if (!options.storeName) {
-                resolve(options.name + '/');
-            } else {
-                resolve(_getKeyPrefix(options, self._defaultConfig));
-            }
-        }).then(function (keyPrefix) {
-            for (var i = localStorage.length - 1; i >= 0; i--) {
-                var key = localStorage.key(i);
-
-                if (key.indexOf(keyPrefix) === 0) {
-                    localStorage.removeItem(key);
-                }
-            }
-        });
+      });
     }
 
-    executeCallback(promise, callback);
-    return promise;
-}
-
-var localStorageWrapper = {
-    _driver: 'localStorageWrapper',
-    _initStorage: _initStorage$2,
-    _support: isLocalStorageValid(),
-    iterate: iterate$2,
-    getItem: getItem$2,
-    setItem: setItem$2,
-    removeItem: removeItem$2,
-    clear: clear$2,
-    length: length$2,
-    key: key$2,
-    keys: keys$2,
-    dropInstance: dropInstance$2
-};
-
-var sameValue = function sameValue(x, y) {
-    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
-};
-
-var includes = function includes(array, searchElement) {
-    var len = array.length;
-    var i = 0;
-    while (i < len) {
-        if (sameValue(array[i], searchElement)) {
-            return true;
-        }
-        i++;
+    __exports__.race = race;
+  });
+define("promise/reject", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    /**
+      `RSVP.reject` returns a promise that will become rejected with the passed
+      `reason`. `RSVP.reject` is essentially shorthand for the following:
+      ```javascript
+      var promise = new RSVP.Promise(function(resolve, reject){
+        reject(new Error('WHOOPS'));
+      });
+      promise.then(function(value){
+        // Code here doesn't run because the promise is rejected!
+      }, function(reason){
+        // reason.message === 'WHOOPS'
+      });
+      ```
+      Instead of writing the above, your code now simply becomes the following:
+      ```javascript
+      var promise = RSVP.reject(new Error('WHOOPS'));
+      promise.then(function(value){
+        // Code here doesn't run because the promise is rejected!
+      }, function(reason){
+        // reason.message === 'WHOOPS'
+      });
+      ```
+      @method reject
+      @for RSVP
+      @param {Any} reason value that the returned promise will be rejected with.
+      @param {String} label optional string for identifying the returned promise.
+      Useful for tooling.
+      @return {Promise} a promise that will become rejected with the given
+      `reason`.
+    */
+    function reject(reason) {
+      /*jshint validthis:true */
+      var Promise = this;
+
+      return new Promise(function (resolve, reject) {
+        reject(reason);
+      });
     }
 
-    return false;
-};
-
-var isArray = Array.isArray || function (arg) {
-    return Object.prototype.toString.call(arg) === '[object Array]';
-};
-
-// Drivers are stored here when `defineDriver()` is called.
-// They are shared across all instances of localForage.
-var DefinedDrivers = {};
-
-var DriverSupport = {};
-
-var DefaultDrivers = {
-    INDEXEDDB: asyncStorage,
-    WEBSQL: webSQLStorage,
-    LOCALSTORAGE: localStorageWrapper
-};
-
-var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
-
-var OptionalDriverMethods = ['dropInstance'];
-
-var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);
+    __exports__.reject = reject;
+  });
+define("promise/resolve", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    function resolve(value) {
+      /*jshint validthis:true */
+      if (value && typeof value === 'object' && value.constructor === this) {
+        return value;
+      }
 
-var DefaultConfig = {
-    description: '',
-    driver: DefaultDriverOrder.slice(),
-    name: 'localforage',
-    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
-    // we can use without a prompt.
-    size: 4980736,
-    storeName: 'keyvaluepairs',
-    version: 1.0
-};
+      var Promise = this;
 
-function callWhenReady(localForageInstance, libraryMethod) {
-    localForageInstance[libraryMethod] = function () {
-        var _args = arguments;
-        return localForageInstance.ready().then(function () {
-            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
-        });
-    };
-}
-
-function extend() {
-    for (var i = 1; i < arguments.length; i++) {
-        var arg = arguments[i];
-
-        if (arg) {
-            for (var _key in arg) {
-                if (arg.hasOwnProperty(_key)) {
-                    if (isArray(arg[_key])) {
-                        arguments[0][_key] = arg[_key].slice();
-                    } else {
-                        arguments[0][_key] = arg[_key];
-                    }
-                }
-            }
-        }
+      return new Promise(function(resolve) {
+        resolve(value);
+      });
     }
 
-    return arguments[0];
-}
-
-var LocalForage = function () {
-    function LocalForage(options) {
-        _classCallCheck(this, LocalForage);
-
-        for (var driverTypeKey in DefaultDrivers) {
-            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
-                var driver = DefaultDrivers[driverTypeKey];
-                var driverName = driver._driver;
-                this[driverTypeKey] = driverName;
-
-                if (!DefinedDrivers[driverName]) {
-                    // we don't need to wait for the promise,
-                    // since the default drivers can be defined
-                    // in a blocking manner
-                    this.defineDriver(driver);
-                }
-            }
-        }
-
-        this._defaultConfig = extend({}, DefaultConfig);
-        this._config = extend({}, this._defaultConfig, options);
-        this._driverSet = null;
-        this._initDriver = null;
-        this._ready = false;
-        this._dbInfo = null;
-
-        this._wrapLibraryMethodsWithReady();
-        this.setDriver(this._config.driver)["catch"](function () {});
+    __exports__.resolve = resolve;
+  });
+define("promise/utils", 
+  ["exports"],
+  function(__exports__) {
+    "use strict";
+    function objectOrFunction(x) {
+      return isFunction(x) || (typeof x === "object" && x !== null);
     }
 
-    // Set any config values for localForage; can be called anytime before
-    // the first API call (e.g. `getItem`, `setItem`).
-    // We loop through options so we don't overwrite existing config
-    // values.
-
-
-    LocalForage.prototype.config = function config(options) {
-        // If the options argument is an object, we use it to set values.
-        // Otherwise, we return either a specified config value or all
-        // config values.
-        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
-            // If localforage is ready and fully initialized, we can't set
-            // any new configuration values. Instead, we return an error.
-            if (this._ready) {
-                return new Error("Can't call config() after localforage " + 'has been used.');
-            }
-
-            for (var i in options) {
-                if (i === 'storeName') {
-                    options[i] = options[i].replace(/\W/g, '_');
-                }
-
-                if (i === 'version' && typeof options[i] !== 'number') {
-                    return new Error('Database version must be a number.');
-                }
-
-                this._config[i] = options[i];
-            }
-
-            // after all config options are set and
-            // the driver option is used, try setting it
-            if ('driver' in options && options.driver) {
-                return this.setDriver(this._config.driver);
-            }
-
-            return true;
-        } else if (typeof options === 'string') {
-            return this._config[options];
-        } else {
-            return this._config;
-        }
-    };
-
-    // Used to define a custom driver, shared across all instances of
-    // localForage.
-
-
-    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
-        var promise = new Promise$1(function (resolve, reject) {
-            try {
-                var driverName = driverObject._driver;
-                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');
-
-                // A driver name should be defined and not overlap with the
-                // library-defined, default drivers.
-                if (!driverObject._driver) {
-                    reject(complianceError);
-                    return;
-                }
-
-                var driverMethods = LibraryMethods.concat('_initStorage');
-                for (var i = 0, len = driverMethods.length; i < len; i++) {
-                    var driverMethodName = driverMethods[i];
-
-                    // when the property is there,
-                    // it should be a method even when optional
-                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
-                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
-                        reject(complianceError);
-                        return;
-                    }
-                }
-
-                var configureMissingMethods = function configureMissingMethods() {
-                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
-                        return function () {
-                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
-                            var promise = Promise$1.reject(error);
-                            executeCallback(promise, arguments[arguments.length - 1]);
-                            return promise;
-                        };
-                    };
-
-                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
-                        var optionalDriverMethod = OptionalDriverMethods[_i];
-                        if (!driverObject[optionalDriverMethod]) {
-                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
-                        }
-                    }
-                };
-
-                configureMissingMethods();
-
-                var setDriverSupport = function setDriverSupport(support) {
-                    if (DefinedDrivers[driverName]) {
-                        console.info('Redefining LocalForage driver: ' + driverName);
-                    }
-                    DefinedDrivers[driverName] = driverObject;
-                    DriverSupport[driverName] = support;
-                    // don't use a then, so that we can define
-                    // drivers that have simple _support methods
-                    // in a blocking manner
-                    resolve();
-                };
-
-                if ('_support' in driverObject) {
-                    if (driverObject._support && typeof driverObject._support === 'function') {
-                        driverObject._support().then(setDriverSupport, reject);
-                    } else {
-                        setDriverSupport(!!driverObject._support);
-                    }
-                } else {
-                    setDriverSupport(true);
-                }
-            } catch (e) {
-                reject(e);
-            }
-        });
-
-        executeTwoCallbacks(promise, callback, errorCallback);
-        return promise;
-    };
-
-    LocalForage.prototype.driver = function driver() {
-        return this._driver || null;
-    };
-
-    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
-        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));
-
-        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
-        return getDriverPromise;
-    };
-
-    LocalForage.prototype.getSerializer = function getSerializer(callback) {
-        var serializerPromise = Promise$1.resolve(localforageSerializer);
-        executeTwoCallbacks(serializerPromise, callback);
-        return serializerPromise;
-    };
-
-    LocalForage.prototype.ready = function ready(callback) {
-        var self = this;
-
-        var promise = self._driverSet.then(function () {
-            if (self._ready === null) {
-                self._ready = self._initDriver();
-            }
-
-            return self._ready;
-        });
-
-        executeTwoCallbacks(promise, callback, callback);
-        return promise;
-    };
-
-    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
-        var self = this;
-
-        if (!isArray(drivers)) {
-            drivers = [drivers];
-        }
-
-        var supportedDrivers = this._getSupportedDrivers(drivers);
-
-        function setDriverToConfig() {
-            self._config.driver = self.driver();
-        }
-
-        function extendSelfWithDriver(driver) {
-            self._extend(driver);
-            setDriverToConfig();
-
-            self._ready = self._initStorage(self._config);
-            return self._ready;
-        }
-
-        function initDriver(supportedDrivers) {
-            return function () {
-                var currentDriverIndex = 0;
-
-                function driverPromiseLoop() {
-                    while (currentDriverIndex < supportedDrivers.length) {
-                        var driverName = supportedDrivers[currentDriverIndex];
-                        currentDriverIndex++;
-
-                        self._dbInfo = null;
-                        self._ready = null;
-
-                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
-                    }
-
-                    setDriverToConfig();
-                    var error = new Error('No available storage method found.');
-                    self._driverSet = Promise$1.reject(error);
-                    return self._driverSet;
-                }
-
-                return driverPromiseLoop();
-            };
-        }
-
-        // There might be a driver initialization in progress
-        // so wait for it to finish in order to avoid a possible
-        // race condition to set _dbInfo
-        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
-            return Promise$1.resolve();
-        }) : Promise$1.resolve();
-
-        this._driverSet = oldDriverSetDone.then(function () {
-            var driverName = supportedDrivers[0];
-            self._dbInfo = null;
-            self._ready = null;
-
-            return self.getDriver(driverName).then(function (driver) {
-                self._driver = driver._driver;
-                setDriverToConfig();
-                self._wrapLibraryMethodsWithReady();
-                self._initDriver = initDriver(supportedDrivers);
-            });
-        })["catch"](function () {
-            setDriverToConfig();
-            var error = new Error('No available storage method found.');
-            self._driverSet = Promise$1.reject(error);
-            return self._driverSet;
-        });
-
-        executeTwoCallbacks(this._driverSet, callback, errorCallback);
-        return this._driverSet;
-    };
-
-    LocalForage.prototype.supports = function supports(driverName) {
-        return !!DriverSupport[driverName];
-    };
-
-    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
-        extend(this, libraryMethodsAndProperties);
-    };
-
-    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
-        var supportedDrivers = [];
-        for (var i = 0, len = drivers.length; i < len; i++) {
-            var driverName = drivers[i];
-            if (this.supports(driverName)) {
-                supportedDrivers.push(driverName);
-            }
-        }
-        return supportedDrivers;
-    };
-
-    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
-        // Add a stub for each driver API method that delays the call to the
-        // corresponding driver method until localForage is ready. These stubs
-        // will be replaced by the driver methods as soon as the driver is
-        // loaded, so there is no performance impact.
-        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
-            callWhenReady(this, LibraryMethods[i]);
-        }
-    };
-
-    LocalForage.prototype.createInstance = function createInstance(options) {
-        return new LocalForage(options);
-    };
-
-    return LocalForage;
-}();
-
-// The actual localForage object that we expose as a module or via a
-// global. It's extended by pulling in one of our other libraries.
+    function isFunction(x) {
+      return typeof x === "function";
+    }
 
+    function isArray(x) {
+      return Object.prototype.toString.call(x) === "[object Array]";
+    }
 
-var localforage_js = new LocalForage();
+    // Date.now is not available in browsers < IE9
+    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
+    var now = Date.now || function() { return new Date().getTime(); };
 
-module.exports = localforage_js;
 
-},{"3":3}]},{},[4])(4)
+    __exports__.objectOrFunction = objectOrFunction;
+    __exports__.isFunction = isFunction;
+    __exports__.isArray = isArray;
+    __exports__.now = now;
+  });
+requireModule('promise/polyfill').polyfill();
+}());(function webpackUniversalModuleDefinition(root, factory) {
+	if(typeof exports === 'object' && typeof module === 'object')
+		module.exports = factory();
+	else if(typeof define === 'function' && define.amd)
+		define([], factory);
+	else if(typeof exports === 'object')
+		exports["localforage"] = factory();
+	else
+		root["localforage"] = factory();
+})(this, function() {
+return /******/ (function(modules) { // webpackBootstrap
+/******/ 	// The module cache
+/******/ 	var installedModules = {};
+
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+
+/******/ 		// Check if module is in cache
+/******/ 		if(installedModules[moduleId])
+/******/ 			return installedModules[moduleId].exports;
+
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = installedModules[moduleId] = {
+/******/ 			exports: {},
+/******/ 			id: moduleId,
+/******/ 			loaded: false
+/******/ 		};
+
+/******/ 		// Execute the module function
+/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
+
+/******/ 		// Flag the module as loaded
+/******/ 		module.loaded = true;
+
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+
+
+/******/ 	// expose the modules object (__webpack_modules__)
+/******/ 	__webpack_require__.m = modules;
+
+/******/ 	// expose the module cache
+/******/ 	__webpack_require__.c = installedModules;
+
+/******/ 	// __webpack_public_path__
+/******/ 	__webpack_require__.p = "";
+
+/******/ 	// Load entry module and return exports
+/******/ 	return __webpack_require__(0);
+/******/ })
+/************************************************************************/
+/******/ ([
+/* 0 */
+/***/ function(module, exports, __webpack_require__) {
+
+	'use strict';
+
+	exports.__esModule = true;
+
+	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
+
+	(function () {
+	    'use strict';
+
+	    // Custom drivers are stored here when `defineDriver()` is called.
+	    // They are shared across all instances of localForage.
+	    var CustomDrivers = {};
+
+	    var DriverType = {
+	        INDEXEDDB: 'asyncStorage',
+	        LOCALSTORAGE: 'localStorageWrapper',
+	        WEBSQL: 'webSQLStorage'
+	    };
+
+	    var DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];
+
+	    var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];
+
+	    var DefaultConfig = {
+	        description: '',
+	        driver: DefaultDriverOrder.slice(),
+	        name: 'localforage',
+	        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
+	        // we can use without a prompt.
+	        size: 4980736,
+	        storeName: 'keyvaluepairs',
+	        version: 1.0
+	    };
+
+	    // Check to see if IndexedDB is available and if it is the latest
+	    // implementation; it's our preferred backend library. We use "_spec_test"
+	    // as the name of the database because it's not the one we'll operate on,
+	    // but it's useful to make sure its using the right spec.
+	    // See: https://github.com/mozilla/localForage/issues/128
+	    var driverSupport = (function (self) {
+	        // Initialize IndexedDB; fall back to vendor-prefixed versions
+	        // if needed.
+	        var indexedDB = indexedDB || self.indexedDB || self.webkitIndexedDB || self.mozIndexedDB || self.OIndexedDB || self.msIndexedDB;
+
+	        var result = {};
+
+	        result[DriverType.WEBSQL] = !!self.openDatabase;
+	        result[DriverType.INDEXEDDB] = !!(function () {
+	            // We mimic PouchDB here; just UA test for Safari (which, as of
+	            // iOS 8/Yosemite, doesn't properly support IndexedDB).
+	            // IndexedDB support is broken and different from Blink's.
+	            // This is faster than the test case (and it's sync), so we just
+	            // do this. *SIGH*
+	            // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/
+	            //
+	            // We test for openDatabase because IE Mobile identifies itself
+	            // as Safari. Oh the lulz...
+	            if (typeof self.openDatabase !== 'undefined' && self.navigator && self.navigator.userAgent && /Safari/.test(self.navigator.userAgent) && !/Chrome/.test(self.navigator.userAgent)) {
+	                return false;
+	            }
+	            try {
+	                return indexedDB && typeof indexedDB.open === 'function' &&
+	                // Some Samsung/HTC Android 4.0-4.3 devices
+	                // have older IndexedDB specs; if this isn't available
+	                // their IndexedDB is too old for us to use.
+	                // (Replaces the onupgradeneeded test.)
+	                typeof self.IDBKeyRange !== 'undefined';
+	            } catch (e) {
+	                return false;
+	            }
+	        })();
+
+	        result[DriverType.LOCALSTORAGE] = !!(function () {
+	            try {
+	                return self.localStorage && 'setItem' in self.localStorage && self.localStorage.setItem;
+	            } catch (e) {
+	                return false;
+	            }
+	        })();
+
+	        return result;
+	    })(this);
+
+	    var isArray = Array.isArray || function (arg) {
+	        return Object.prototype.toString.call(arg) === '[object Array]';
+	    };
+
+	    function callWhenReady(localForageInstance, libraryMethod) {
+	        localForageInstance[libraryMethod] = function () {
+	            var _args = arguments;
+	            return localForageInstance.ready().then(function () {
+	                return localForageInstance[libraryMethod].apply(localForageInstance, _args);
+	            });
+	        };
+	    }
+
+	    function extend() {
+	        for (var i = 1; i < arguments.length; i++) {
+	            var arg = arguments[i];
+
+	            if (arg) {
+	                for (var key in arg) {
+	                    if (arg.hasOwnProperty(key)) {
+	                        if (isArray(arg[key])) {
+	                            arguments[0][key] = arg[key].slice();
+	                        } else {
+	                            arguments[0][key] = arg[key];
+	                        }
+	                    }
+	                }
+	            }
+	        }
+
+	        return arguments[0];
+	    }
+
+	    function isLibraryDriver(driverName) {
+	        for (var driver in DriverType) {
+	            if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {
+	                return true;
+	            }
+	        }
+
+	        return false;
+	    }
+
+	    var LocalForage = (function () {
+	        function LocalForage(options) {
+	            _classCallCheck(this, LocalForage);
+
+	            this.INDEXEDDB = DriverType.INDEXEDDB;
+	            this.LOCALSTORAGE = DriverType.LOCALSTORAGE;
+	            this.WEBSQL = DriverType.WEBSQL;
+
+	            this._defaultConfig = extend({}, DefaultConfig);
+	            this._config = extend({}, this._defaultConfig, options);
+	            this._driverSet = null;
+	            this._initDriver = null;
+	            this._ready = false;
+	            this._dbInfo = null;
+
+	            this._wrapLibraryMethodsWithReady();
+	            this.setDriver(this._config.driver);
+	        }
+
+	        // The actual localForage object that we expose as a module or via a
+	        // global. It's extended by pulling in one of our other libraries.
+
+	        // Set any config values for localForage; can be called anytime before
+	        // the first API call (e.g. `getItem`, `setItem`).
+	        // We loop through options so we don't overwrite existing config
+	        // values.
+
+	        LocalForage.prototype.config = function config(options) {
+	            // If the options argument is an object, we use it to set values.
+	            // Otherwise, we return either a specified config value or all
+	            // config values.
+	            if (typeof options === 'object') {
+	                // If localforage is ready and fully initialized, we can't set
+	                // any new configuration values. Instead, we return an error.
+	                if (this._ready) {
+	                    return new Error("Can't call config() after localforage " + 'has been used.');
+	                }
+
+	                for (var i in options) {
+	                    if (i === 'storeName') {
+	                        options[i] = options[i].replace(/\W/g, '_');
+	                    }
+
+	                    this._config[i] = options[i];
+	                }
+
+	                // after all config options are set and
+	                // the driver option is used, try setting it
+	                if ('driver' in options && options.driver) {
+	                    this.setDriver(this._config.driver);
+	                }
+
+	                return true;
+	            } else if (typeof options === 'string') {
+	                return this._config[options];
+	            } else {
+	                return this._config;
+	            }
+	        };
+
+	        // Used to define a custom driver, shared across all instances of
+	        // localForage.
+
+	        LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
+	            var promise = new Promise(function (resolve, reject) {
+	                try {
+	                    var driverName = driverObject._driver;
+	                    var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');
+	                    var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);
+
+	                    // A driver name should be defined and not overlap with the
+	                    // library-defined, default drivers.
+	                    if (!driverObject._driver) {
+	                        reject(complianceError);
+	                        return;
+	                    }
+	                    if (isLibraryDriver(driverObject._driver)) {
+	                        reject(namingError);
+	                        return;
+	                    }
+
+	                    var customDriverMethods = LibraryMethods.concat('_initStorage');
+	                    for (var i = 0; i < customDriverMethods.length; i++) {
+	                        var customDriverMethod = customDriverMethods[i];
+	                        if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {
+	                            reject(complianceError);
+	                            return;
+	                        }
+	                    }
+
+	                    var supportPromise = Promise.resolve(true);
+	                    if ('_support' in driverObject) {
+	                        if (driverObject._support && typeof driverObject._support === 'function') {
+	                            supportPromise = driverObject._support();
+	                        } else {
+	                            supportPromise = Promise.resolve(!!driverObject._support);
+	                        }
+	                    }
+
+	                    supportPromise.then(function (supportResult) {
+	                        driverSupport[driverName] = supportResult;
+	                        CustomDrivers[driverName] = driverObject;
+	                        resolve();
+	                    }, reject);
+	                } catch (e) {
+	                    reject(e);
+	                }
+	            });
+
+	            promise.then(callback, errorCallback);
+	            return promise;
+	        };
+
+	        LocalForage.prototype.driver = function driver() {
+	            return this._driver || null;
+	        };
+
+	        LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
+	            var self = this;
+	            var getDriverPromise = (function () {
+	                if (isLibraryDriver(driverName)) {
+	                    switch (driverName) {
+	                        case self.INDEXEDDB:
+	                            return new Promise(function (resolve, reject) {
+	                                resolve(__webpack_require__(1));
+	                            });
+	                        case self.LOCALSTORAGE:
+	                            return new Promise(function (resolve, reject) {
+	                                resolve(__webpack_require__(2));
+	                            });
+	                        case self.WEBSQL:
+	                            return new Promise(function (resolve, reject) {
+	                                resolve(__webpack_require__(4));
+	                            });
+	                    }
+	                } else if (CustomDrivers[driverName]) {
+	                    return Promise.resolve(CustomDrivers[driverName]);
+	                }
+
+	                return Promise.reject(new Error('Driver not found.'));
+	            })();
+
+	            getDriverPromise.then(callback, errorCallback);
+	            return getDriverPromise;
+	        };
+
+	        LocalForage.prototype.getSerializer = function getSerializer(callback) {
+	            var serializerPromise = new Promise(function (resolve, reject) {
+	                resolve(__webpack_require__(3));
+	            });
+	            if (callback && typeof callback === 'function') {
+	                serializerPromise.then(function (result) {
+	                    callback(result);
+	                });
+	            }
+	            return serializerPromise;
+	        };
+
+	        LocalForage.prototype.ready = function ready(callback) {
+	            var self = this;
+
+	            var promise = self._driverSet.then(function () {
+	                if (self._ready === null) {
+	                    self._ready = self._initDriver();
+	                }
+
+	                return self._ready;
+	            });
+
+	            promise.then(callback, callback);
+	            return promise;
+	        };
+
+	        LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
+	            var self = this;
+
+	            if (!isArray(drivers)) {
+	                drivers = [drivers];
+	            }
+
+	            var supportedDrivers = this._getSupportedDrivers(drivers);
+
+	            function setDriverToConfig() {
+	                self._config.driver = self.driver();
+	            }
+
+	            function initDriver(supportedDrivers) {
+	                return function () {
+	                    var currentDriverIndex = 0;
+
+	                    function driverPromiseLoop() {
+	                        while (currentDriverIndex < supportedDrivers.length) {
+	                            var driverName = supportedDrivers[currentDriverIndex];
+	                            currentDriverIndex++;
+
+	                            self._dbInfo = null;
+	                            self._ready = null;
+
+	                            return self.getDriver(driverName).then(function (driver) {
+	                                self._extend(driver);
+	                                setDriverToConfig();
+
+	                                self._ready = self._initStorage(self._config);
+	                                return self._ready;
+	                            })['catch'](driverPromiseLoop);
+	                        }
+
+	                        setDriverToConfig();
+	                        var error = new Error('No available storage method found.');
+	                        self._driverSet = Promise.reject(error);
+	                        return self._driverSet;
+	                    }
+
+	                    return driverPromiseLoop();
+	                };
+	            }
+
+	            // There might be a driver initialization in progress
+	            // so wait for it to finish in order to avoid a possible
+	            // race condition to set _dbInfo
+	            var oldDriverSetDone = this._driverSet !== null ? this._driverSet['catch'](function () {
+	                return Promise.resolve();
+	            }) : Promise.resolve();
+
+	            this._driverSet = oldDriverSetDone.then(function () {
+	                var driverName = supportedDrivers[0];
+	                self._dbInfo = null;
+	                self._ready = null;
+
+	                return self.getDriver(driverName).then(function (driver) {
+	                    self._driver = driver._driver;
+	                    setDriverToConfig();
+	                    self._wrapLibraryMethodsWithReady();
+	                    self._initDriver = initDriver(supportedDrivers);
+	                });
+	            })['catch'](function () {
+	                setDriverToConfig();
+	                var error = new Error('No available storage method found.');
+	                self._driverSet = Promise.reject(error);
+	                return self._driverSet;
+	            });
+
+	            this._driverSet.then(callback, errorCallback);
+	            return this._driverSet;
+	        };
+
+	        LocalForage.prototype.supports = function supports(driverName) {
+	            return !!driverSupport[driverName];
+	        };
+
+	        LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
+	            extend(this, libraryMethodsAndProperties);
+	        };
+
+	        LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
+	            var supportedDrivers = [];
+	            for (var i = 0, len = drivers.length; i < len; i++) {
+	                var driverName = drivers[i];
+	                if (this.supports(driverName)) {
+	                    supportedDrivers.push(driverName);
+	                }
+	            }
+	            return supportedDrivers;
+	        };
+
+	        LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
+	            // Add a stub for each driver API method that delays the call to the
+	            // corresponding driver method until localForage is ready. These stubs
+	            // will be replaced by the driver methods as soon as the driver is
+	            // loaded, so there is no performance impact.
+	            for (var i = 0; i < LibraryMethods.length; i++) {
+	                callWhenReady(this, LibraryMethods[i]);
+	            }
+	        };
+
+	        LocalForage.prototype.createInstance = function createInstance(options) {
+	            return new LocalForage(options);
+	        };
+
+	        return LocalForage;
+	    })();
+
+	    var localForage = new LocalForage();
+
+	    exports['default'] = localForage;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 1 */
+/***/ function(module, exports) {
+
+	// Some code originally from async_storage.js in
+	// [Gaia](https://github.com/mozilla-b2g/gaia).
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    var globalObject = this;
+	    // Initialize IndexedDB; fall back to vendor-prefixed versions if needed.
+	    var indexedDB = indexedDB || this.indexedDB || this.webkitIndexedDB || this.mozIndexedDB || this.OIndexedDB || this.msIndexedDB;
+
+	    // If IndexedDB isn't available, we get outta here!
+	    if (!indexedDB) {
+	        return;
+	    }
+
+	    var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
+	    var supportsBlobs;
+	    var dbContexts;
+
+	    // Abstracts constructing a Blob object, so it also works in older
+	    // browsers that don't support the native Blob constructor. (i.e.
+	    // old QtWebKit versions, at least).
+	    function _createBlob(parts, properties) {
+	        parts = parts || [];
+	        properties = properties || {};
+	        try {
+	            return new Blob(parts, properties);
+	        } catch (e) {
+	            if (e.name !== 'TypeError') {
+	                throw e;
+	            }
+	            var BlobBuilder = globalObject.BlobBuilder || globalObject.MSBlobBuilder || globalObject.MozBlobBuilder || globalObject.WebKitBlobBuilder;
+	            var builder = new BlobBuilder();
+	            for (var i = 0; i < parts.length; i += 1) {
+	                builder.append(parts[i]);
+	            }
+	            return builder.getBlob(properties.type);
+	        }
+	    }
+
+	    // Transform a binary string to an array buffer, because otherwise
+	    // weird stuff happens when you try to work with the binary string directly.
+	    // It is known.
+	    // From http://stackoverflow.com/questions/14967647/ (continues on next line)
+	    // encode-decode-image-with-base64-breaks-image (2013-04-21)
+	    function _binStringToArrayBuffer(bin) {
+	        var length = bin.length;
+	        var buf = new ArrayBuffer(length);
+	        var arr = new Uint8Array(buf);
+	        for (var i = 0; i < length; i++) {
+	            arr[i] = bin.charCodeAt(i);
+	        }
+	        return buf;
+	    }
+
+	    // Fetch a blob using ajax. This reveals bugs in Chrome < 43.
+	    // For details on all this junk:
+	    // https://github.com/nolanlawson/state-of-binary-data-in-the-browser#readme
+	    function _blobAjax(url) {
+	        return new Promise(function (resolve, reject) {
+	            var xhr = new XMLHttpRequest();
+	            xhr.open('GET', url);
+	            xhr.withCredentials = true;
+	            xhr.responseType = 'arraybuffer';
+
+	            xhr.onreadystatechange = function () {
+	                if (xhr.readyState !== 4) {
+	                    return;
+	                }
+	                if (xhr.status === 200) {
+	                    return resolve({
+	                        response: xhr.response,
+	                        type: xhr.getResponseHeader('Content-Type')
+	                    });
+	                }
+	                reject({ status: xhr.status, response: xhr.response });
+	            };
+	            xhr.send();
+	        });
+	    }
+
+	    //
+	    // Detect blob support. Chrome didn't support it until version 38.
+	    // In version 37 they had a broken version where PNGs (and possibly
+	    // other binary types) aren't stored correctly, because when you fetch
+	    // them, the content type is always null.
+	    //
+	    // Furthermore, they have some outstanding bugs where blobs occasionally
+	    // are read by FileReader as null, or by ajax as 404s.
+	    //
+	    // Sadly we use the 404 bug to detect the FileReader bug, so if they
+	    // get fixed independently and released in different versions of Chrome,
+	    // then the bug could come back. So it's worthwhile to watch these issues:
+	    // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
+	    // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
+	    //
+	    function _checkBlobSupportWithoutCaching(idb) {
+	        return new Promise(function (resolve, reject) {
+	            var blob = _createBlob([''], { type: 'image/png' });
+	            var txn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');
+	            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
+	            txn.oncomplete = function () {
+	                // have to do it in a separate transaction, else the correct
+	                // content type is always returned
+	                var blobTxn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');
+	                var getBlobReq = blobTxn.objectStore(DETECT_BLOB_SUPPORT_STORE).get('key');
+	                getBlobReq.onerror = reject;
+	                getBlobReq.onsuccess = function (e) {
+
+	                    var storedBlob = e.target.result;
+	                    var url = URL.createObjectURL(storedBlob);
+
+	                    _blobAjax(url).then(function (res) {
+	                        resolve(!!(res && res.type === 'image/png'));
+	                    }, function () {
+	                        resolve(false);
+	                    }).then(function () {
+	                        URL.revokeObjectURL(url);
+	                    });
+	                };
+	            };
+	        })['catch'](function () {
+	            return false; // error, so assume unsupported
+	        });
+	    }
+
+	    function _checkBlobSupport(idb) {
+	        if (typeof supportsBlobs === 'boolean') {
+	            return Promise.resolve(supportsBlobs);
+	        }
+	        return _checkBlobSupportWithoutCaching(idb).then(function (value) {
+	            supportsBlobs = value;
+	            return supportsBlobs;
+	        });
+	    }
+
+	    // encode a blob for indexeddb engines that don't support blobs
+	    function _encodeBlob(blob) {
+	        return new Promise(function (resolve, reject) {
+	            var reader = new FileReader();
+	            reader.onerror = reject;
+	            reader.onloadend = function (e) {
+	                var base64 = btoa(e.target.result || '');
+	                resolve({
+	                    __local_forage_encoded_blob: true,
+	                    data: base64,
+	                    type: blob.type
+	                });
+	            };
+	            reader.readAsBinaryString(blob);
+	        });
+	    }
+
+	    // decode an encoded blob
+	    function _decodeBlob(encodedBlob) {
+	        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
+	        return _createBlob([arrayBuff], { type: encodedBlob.type });
+	    }
+
+	    // is this one of our fancy encoded blobs?
+	    function _isEncodedBlob(value) {
+	        return value && value.__local_forage_encoded_blob;
+	    }
+
+	    // Open the IndexedDB database (automatically creates one if one didn't
+	    // previously exist), using any options set in the config.
+	    function _initStorage(options) {
+	        var self = this;
+	        var dbInfo = {
+	            db: null
+	        };
+
+	        if (options) {
+	            for (var i in options) {
+	                dbInfo[i] = options[i];
+	            }
+	        }
+
+	        // Initialize a singleton container for all running localForages.
+	        if (!dbContexts) {
+	            dbContexts = {};
+	        }
+
+	        // Get the current context of the database;
+	        var dbContext = dbContexts[dbInfo.name];
+
+	        // ...or create a new context.
+	        if (!dbContext) {
+	            dbContext = {
+	                // Running localForages sharing a database.
+	                forages: [],
+	                // Shared database.
+	                db: null
+	            };
+	            // Register the new context in the global container.
+	            dbContexts[dbInfo.name] = dbContext;
+	        }
+
+	        // Register itself as a running localForage in the current context.
+	        dbContext.forages.push(this);
+
+	        // Create an array of readiness of the related localForages.
+	        var readyPromises = [];
+
+	        function ignoreErrors() {
+	            // Don't handle errors here,
+	            // just makes sure related localForages aren't pending.
+	            return Promise.resolve();
+	        }
+
+	        for (var j = 0; j < dbContext.forages.length; j++) {
+	            var forage = dbContext.forages[j];
+	            if (forage !== this) {
+	                // Don't wait for itself...
+	                readyPromises.push(forage.ready()['catch'](ignoreErrors));
+	            }
+	        }
+
+	        // Take a snapshot of the related localForages.
+	        var forages = dbContext.forages.slice(0);
+
+	        // Initialize the connection process only when
+	        // all the related localForages aren't pending.
+	        return Promise.all(readyPromises).then(function () {
+	            dbInfo.db = dbContext.db;
+	            // Get the connection or open a new one without upgrade.
+	            return _getOriginalConnection(dbInfo);
+	        }).then(function (db) {
+	            dbInfo.db = db;
+	            if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
+	                // Reopen the database for upgrading.
+	                return _getUpgradedConnection(dbInfo);
+	            }
+	            return db;
+	        }).then(function (db) {
+	            dbInfo.db = dbContext.db = db;
+	            self._dbInfo = dbInfo;
+	            // Share the final connection amongst related localForages.
+	            for (var k in forages) {
+	                var forage = forages[k];
+	                if (forage !== self) {
+	                    // Self is already up-to-date.
+	                    forage._dbInfo.db = dbInfo.db;
+	                    forage._dbInfo.version = dbInfo.version;
+	                }
+	            }
+	        });
+	    }
+
+	    function _getOriginalConnection(dbInfo) {
+	        return _getConnection(dbInfo, false);
+	    }
+
+	    function _getUpgradedConnection(dbInfo) {
+	        return _getConnection(dbInfo, true);
+	    }
+
+	    function _getConnection(dbInfo, upgradeNeeded) {
+	        return new Promise(function (resolve, reject) {
+	            if (dbInfo.db) {
+	                if (upgradeNeeded) {
+	                    dbInfo.db.close();
+	                } else {
+	                    return resolve(dbInfo.db);
+	                }
+	            }
+
+	            var dbArgs = [dbInfo.name];
+
+	            if (upgradeNeeded) {
+	                dbArgs.push(dbInfo.version);
+	            }
+
+	            var openreq = indexedDB.open.apply(indexedDB, dbArgs);
+
+	            if (upgradeNeeded) {
+	                openreq.onupgradeneeded = function (e) {
+	                    var db = openreq.result;
+	                    try {
+	                        db.createObjectStore(dbInfo.storeName);
+	                        if (e.oldVersion <= 1) {
+	                            // Added when support for blob shims was added
+	                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
+	                        }
+	                    } catch (ex) {
+	                        if (ex.name === 'ConstraintError') {
+	                            globalObject.console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
+	                        } else {
+	                            throw ex;
+	                        }
+	                    }
+	                };
+	            }
+
+	            openreq.onerror = function () {
+	                reject(openreq.error);
+	            };
+
+	            openreq.onsuccess = function () {
+	                resolve(openreq.result);
+	            };
+	        });
+	    }
+
+	    function _isUpgradeNeeded(dbInfo, defaultVersion) {
+	        if (!dbInfo.db) {
+	            return true;
+	        }
+
+	        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
+	        var isDowngrade = dbInfo.version < dbInfo.db.version;
+	        var isUpgrade = dbInfo.version > dbInfo.db.version;
+
+	        if (isDowngrade) {
+	            // If the version is not the default one
+	            // then warn for impossible downgrade.
+	            if (dbInfo.version !== defaultVersion) {
+	                globalObject.console.warn('The database "' + dbInfo.name + '"' + ' can\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
+	            }
+	            // Align the versions to prevent errors.
+	            dbInfo.version = dbInfo.db.version;
+	        }
+
+	        if (isUpgrade || isNewStore) {
+	            // If the store is new then increment the version (if needed).
+	            // This will trigger an "upgradeneeded" event which is required
+	            // for creating a store.
+	            if (isNewStore) {
+	                var incVersion = dbInfo.db.version + 1;
+	                if (incVersion > dbInfo.version) {
+	                    dbInfo.version = incVersion;
+	                }
+	            }
+
+	            return true;
+	        }
+
+	        return false;
+	    }
+
+	    function getItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+	                var req = store.get(key);
+
+	                req.onsuccess = function () {
+	                    var value = req.result;
+	                    if (value === undefined) {
+	                        value = null;
+	                    }
+	                    if (_isEncodedBlob(value)) {
+	                        value = _decodeBlob(value);
+	                    }
+	                    resolve(value);
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Iterate over all items stored in database.
+	    function iterate(iterator, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+
+	                var req = store.openCursor();
+	                var iterationNumber = 1;
+
+	                req.onsuccess = function () {
+	                    var cursor = req.result;
+
+	                    if (cursor) {
+	                        var value = cursor.value;
+	                        if (_isEncodedBlob(value)) {
+	                            value = _decodeBlob(value);
+	                        }
+	                        var result = iterator(value, cursor.key, iterationNumber++);
+
+	                        if (result !== void 0) {
+	                            resolve(result);
+	                        } else {
+	                            cursor['continue']();
+	                        }
+	                    } else {
+	                        resolve();
+	                    }
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+
+	        return promise;
+	    }
+
+	    function setItem(key, value, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            var dbInfo;
+	            self.ready().then(function () {
+	                dbInfo = self._dbInfo;
+	                return _checkBlobSupport(dbInfo.db);
+	            }).then(function (blobSupport) {
+	                if (!blobSupport && value instanceof Blob) {
+	                    return _encodeBlob(value);
+	                }
+	                return value;
+	            }).then(function (value) {
+	                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
+	                var store = transaction.objectStore(dbInfo.storeName);
+
+	                // The reason we don't _save_ null is because IE 10 does
+	                // not support saving the `null` type in IndexedDB. How
+	                // ironic, given the bug below!
+	                // See: https://github.com/mozilla/localForage/issues/161
+	                if (value === null) {
+	                    value = undefined;
+	                }
+
+	                var req = store.put(value, key);
+	                transaction.oncomplete = function () {
+	                    // Cast to undefined so the value passed to
+	                    // callback/promise is the same as what one would get out
+	                    // of `getItem()` later. This leads to some weirdness
+	                    // (setItem('foo', undefined) will return `null`), but
+	                    // it's not my fault localStorage is our baseline and that
+	                    // it's weird.
+	                    if (value === undefined) {
+	                        value = null;
+	                    }
+
+	                    resolve(value);
+	                };
+	                transaction.onabort = transaction.onerror = function () {
+	                    var err = req.error ? req.error : req.transaction.error;
+	                    reject(err);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function removeItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
+	                var store = transaction.objectStore(dbInfo.storeName);
+
+	                // We use a Grunt task to make this safe for IE and some
+	                // versions of Android (including those used by Cordova).
+	                // Normally IE won't like `.delete()` and will insist on
+	                // using `['delete']()`, but we have a build step that
+	                // fixes this for us now.
+	                var req = store['delete'](key);
+	                transaction.oncomplete = function () {
+	                    resolve();
+	                };
+
+	                transaction.onerror = function () {
+	                    reject(req.error);
+	                };
+
+	                // The request will be also be aborted if we've exceeded our storage
+	                // space.
+	                transaction.onabort = function () {
+	                    var err = req.error ? req.error : req.transaction.error;
+	                    reject(err);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function clear(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
+	                var store = transaction.objectStore(dbInfo.storeName);
+	                var req = store.clear();
+
+	                transaction.oncomplete = function () {
+	                    resolve();
+	                };
+
+	                transaction.onabort = transaction.onerror = function () {
+	                    var err = req.error ? req.error : req.transaction.error;
+	                    reject(err);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function length(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+	                var req = store.count();
+
+	                req.onsuccess = function () {
+	                    resolve(req.result);
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function key(n, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            if (n < 0) {
+	                resolve(null);
+
+	                return;
+	            }
+
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+
+	                var advanced = false;
+	                var req = store.openCursor();
+	                req.onsuccess = function () {
+	                    var cursor = req.result;
+	                    if (!cursor) {
+	                        // this means there weren't enough keys
+	                        resolve(null);
+
+	                        return;
+	                    }
+
+	                    if (n === 0) {
+	                        // We have the first key, return it if that's what they
+	                        // wanted.
+	                        resolve(cursor.key);
+	                    } else {
+	                        if (!advanced) {
+	                            // Otherwise, ask the cursor to skip ahead n
+	                            // records.
+	                            advanced = true;
+	                            cursor.advance(n);
+	                        } else {
+	                            // When we get here, we've got the nth key.
+	                            resolve(cursor.key);
+	                        }
+	                    }
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function keys(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
+
+	                var req = store.openCursor();
+	                var keys = [];
+
+	                req.onsuccess = function () {
+	                    var cursor = req.result;
+
+	                    if (!cursor) {
+	                        resolve(keys);
+	                        return;
+	                    }
+
+	                    keys.push(cursor.key);
+	                    cursor['continue']();
+	                };
+
+	                req.onerror = function () {
+	                    reject(req.error);
+	                };
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function executeCallback(promise, callback) {
+	        if (callback) {
+	            promise.then(function (result) {
+	                callback(null, result);
+	            }, function (error) {
+	                callback(error);
+	            });
+	        }
+	    }
+
+	    var asyncStorage = {
+	        _driver: 'asyncStorage',
+	        _initStorage: _initStorage,
+	        iterate: iterate,
+	        getItem: getItem,
+	        setItem: setItem,
+	        removeItem: removeItem,
+	        clear: clear,
+	        length: length,
+	        key: key,
+	        keys: keys
+	    };
+
+	    exports['default'] = asyncStorage;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 2 */
+/***/ function(module, exports, __webpack_require__) {
+
+	// If IndexedDB isn't available, we'll fall back to localStorage.
+	// Note that this will have considerable performance and storage
+	// side-effects (all data will be serialized on save and only data that
+	// can be converted to a string via `JSON.stringify()` will be saved).
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    var globalObject = this;
+	    var localStorage = null;
+
+	    // If the app is running inside a Google Chrome packaged webapp, or some
+	    // other context where localStorage isn't available, we don't use
+	    // localStorage. This feature detection is preferred over the old
+	    // `if (window.chrome && window.chrome.runtime)` code.
+	    // See: https://github.com/mozilla/localForage/issues/68
+	    try {
+	        // If localStorage isn't available, we get outta here!
+	        // This should be inside a try catch
+	        if (!this.localStorage || !('setItem' in this.localStorage)) {
+	            return;
+	        }
+	        // Initialize localStorage and create a variable to use throughout
+	        // the code.
+	        localStorage = this.localStorage;
+	    } catch (e) {
+	        return;
+	    }
+
+	    // Config the localStorage backend, using options set in the config.
+	    function _initStorage(options) {
+	        var self = this;
+	        var dbInfo = {};
+	        if (options) {
+	            for (var i in options) {
+	                dbInfo[i] = options[i];
+	            }
+	        }
+
+	        dbInfo.keyPrefix = dbInfo.name + '/';
+
+	        if (dbInfo.storeName !== self._defaultConfig.storeName) {
+	            dbInfo.keyPrefix += dbInfo.storeName + '/';
+	        }
+
+	        self._dbInfo = dbInfo;
+
+	        return new Promise(function (resolve, reject) {
+	            resolve(__webpack_require__(3));
+	        }).then(function (lib) {
+	            dbInfo.serializer = lib;
+	            return Promise.resolve();
+	        });
+	    }
+
+	    // Remove all keys from the datastore, effectively destroying all data in
+	    // the app's key/value store!
+	    function clear(callback) {
+	        var self = this;
+	        var promise = self.ready().then(function () {
+	            var keyPrefix = self._dbInfo.keyPrefix;
+
+	            for (var i = localStorage.length - 1; i >= 0; i--) {
+	                var key = localStorage.key(i);
+
+	                if (key.indexOf(keyPrefix) === 0) {
+	                    localStorage.removeItem(key);
+	                }
+	            }
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Retrieve an item from the store. Unlike the original async_storage
+	    // library in Gaia, we don't modify return values at all. If a key's value
+	    // is `undefined`, we pass that value to the callback function.
+	    function getItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var result = localStorage.getItem(dbInfo.keyPrefix + key);
+
+	            // If a result was found, parse it from the serialized
+	            // string into a JS object. If result isn't truthy, the key
+	            // is likely undefined and we'll pass it straight to the
+	            // callback.
+	            if (result) {
+	                result = dbInfo.serializer.deserialize(result);
+	            }
+
+	            return result;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Iterate over all items in the store.
+	    function iterate(iterator, callback) {
+	        var self = this;
+
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var keyPrefix = dbInfo.keyPrefix;
+	            var keyPrefixLength = keyPrefix.length;
+	            var length = localStorage.length;
+
+	            // We use a dedicated iterator instead of the `i` variable below
+	            // so other keys we fetch in localStorage aren't counted in
+	            // the `iterationNumber` argument passed to the `iterate()`
+	            // callback.
+	            //
+	            // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
+	            var iterationNumber = 1;
+
+	            for (var i = 0; i < length; i++) {
+	                var key = localStorage.key(i);
+	                if (key.indexOf(keyPrefix) !== 0) {
+	                    continue;
+	                }
+	                var value = localStorage.getItem(key);
+
+	                // If a result was found, parse it from the serialized
+	                // string into a JS object. If result isn't truthy, the
+	                // key is likely undefined and we'll pass it straight
+	                // to the iterator.
+	                if (value) {
+	                    value = dbInfo.serializer.deserialize(value);
+	                }
+
+	                value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);
+
+	                if (value !== void 0) {
+	                    return value;
+	                }
+	            }
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Same as localStorage's key() method, except takes a callback.
+	    function key(n, callback) {
+	        var self = this;
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var result;
+	            try {
+	                result = localStorage.key(n);
+	            } catch (error) {
+	                result = null;
+	            }
+
+	            // Remove the prefix from the key, if a key is found.
+	            if (result) {
+	                result = result.substring(dbInfo.keyPrefix.length);
+	            }
+
+	            return result;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function keys(callback) {
+	        var self = this;
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            var length = localStorage.length;
+	            var keys = [];
+
+	            for (var i = 0; i < length; i++) {
+	                if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {
+	                    keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));
+	                }
+	            }
+
+	            return keys;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Supply the number of keys in the datastore to the callback function.
+	    function length(callback) {
+	        var self = this;
+	        var promise = self.keys().then(function (keys) {
+	            return keys.length;
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Remove an item from the store, nice and simple.
+	    function removeItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = self.ready().then(function () {
+	            var dbInfo = self._dbInfo;
+	            localStorage.removeItem(dbInfo.keyPrefix + key);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Set a key's value and run an optional callback once the value is set.
+	    // Unlike Gaia's implementation, the callback function is passed the value,
+	    // in case you want to operate on that value only after you're sure it
+	    // saved, or something like that.
+	    function setItem(key, value, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = self.ready().then(function () {
+	            // Convert undefined values to null.
+	            // https://github.com/mozilla/localForage/pull/42
+	            if (value === undefined) {
+	                value = null;
+	            }
+
+	            // Save the original value to pass to the callback.
+	            var originalValue = value;
+
+	            return new Promise(function (resolve, reject) {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.serializer.serialize(value, function (value, error) {
+	                    if (error) {
+	                        reject(error);
+	                    } else {
+	                        try {
+	                            localStorage.setItem(dbInfo.keyPrefix + key, value);
+	                            resolve(originalValue);
+	                        } catch (e) {
+	                            // localStorage capacity exceeded.
+	                            // TODO: Make this a specific error/event.
+	                            if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
+	                                reject(e);
+	                            }
+	                            reject(e);
+	                        }
+	                    }
+	                });
+	            });
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function executeCallback(promise, callback) {
+	        if (callback) {
+	            promise.then(function (result) {
+	                callback(null, result);
+	            }, function (error) {
+	                callback(error);
+	            });
+	        }
+	    }
+
+	    var localStorageWrapper = {
+	        _driver: 'localStorageWrapper',
+	        _initStorage: _initStorage,
+	        // Default API, from Gaia/localStorage.
+	        iterate: iterate,
+	        getItem: getItem,
+	        setItem: setItem,
+	        removeItem: removeItem,
+	        clear: clear,
+	        length: length,
+	        key: key,
+	        keys: keys
+	    };
+
+	    exports['default'] = localStorageWrapper;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 3 */
+/***/ function(module, exports) {
+
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    // Sadly, the best way to save binary data in WebSQL/localStorage is serializing
+	    // it to Base64, so this is how we store it to prevent very strange errors with less
+	    // verbose ways of binary <-> string data storage.
+	    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+
+	    var BLOB_TYPE_PREFIX = '~~local_forage_type~';
+	    var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
+
+	    var SERIALIZED_MARKER = '__lfsc__:';
+	    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
+
+	    // OMG the serializations!
+	    var TYPE_ARRAYBUFFER = 'arbf';
+	    var TYPE_BLOB = 'blob';
+	    var TYPE_INT8ARRAY = 'si08';
+	    var TYPE_UINT8ARRAY = 'ui08';
+	    var TYPE_UINT8CLAMPEDARRAY = 'uic8';
+	    var TYPE_INT16ARRAY = 'si16';
+	    var TYPE_INT32ARRAY = 'si32';
+	    var TYPE_UINT16ARRAY = 'ur16';
+	    var TYPE_UINT32ARRAY = 'ui32';
+	    var TYPE_FLOAT32ARRAY = 'fl32';
+	    var TYPE_FLOAT64ARRAY = 'fl64';
+	    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
+
+	    // Get out of our habit of using `window` inline, at least.
+	    var globalObject = this;
+
+	    // Abstracts constructing a Blob object, so it also works in older
+	    // browsers that don't support the native Blob constructor. (i.e.
+	    // old QtWebKit versions, at least).
+	    function _createBlob(parts, properties) {
+	        parts = parts || [];
+	        properties = properties || {};
+
+	        try {
+	            return new Blob(parts, properties);
+	        } catch (err) {
+	            if (err.name !== 'TypeError') {
+	                throw err;
+	            }
+
+	            var BlobBuilder = globalObject.BlobBuilder || globalObject.MSBlobBuilder || globalObject.MozBlobBuilder || globalObject.WebKitBlobBuilder;
+
+	            var builder = new BlobBuilder();
+	            for (var i = 0; i < parts.length; i += 1) {
+	                builder.append(parts[i]);
+	            }
+
+	            return builder.getBlob(properties.type);
+	        }
+	    }
+
+	    // Serialize a value, afterwards executing a callback (which usually
+	    // instructs the `setItem()` callback/promise to be executed). This is how
+	    // we store binary data with localStorage.
+	    function serialize(value, callback) {
+	        var valueString = '';
+	        if (value) {
+	            valueString = value.toString();
+	        }
+
+	        // Cannot use `value instanceof ArrayBuffer` or such here, as these
+	        // checks fail when running the tests using casper.js...
+	        //
+	        // TODO: See why those tests fail and use a better solution.
+	        if (value && (value.toString() === '[object ArrayBuffer]' || value.buffer && value.buffer.toString() === '[object ArrayBuffer]')) {
+	            // Convert binary arrays to a string and prefix the string with
+	            // a special marker.
+	            var buffer;
+	            var marker = SERIALIZED_MARKER;
+
+	            if (value instanceof ArrayBuffer) {
+	                buffer = value;
+	                marker += TYPE_ARRAYBUFFER;
+	            } else {
+	                buffer = value.buffer;
+
+	                if (valueString === '[object Int8Array]') {
+	                    marker += TYPE_INT8ARRAY;
+	                } else if (valueString === '[object Uint8Array]') {
+	                    marker += TYPE_UINT8ARRAY;
+	                } else if (valueString === '[object Uint8ClampedArray]') {
+	                    marker += TYPE_UINT8CLAMPEDARRAY;
+	                } else if (valueString === '[object Int16Array]') {
+	                    marker += TYPE_INT16ARRAY;
+	                } else if (valueString === '[object Uint16Array]') {
+	                    marker += TYPE_UINT16ARRAY;
+	                } else if (valueString === '[object Int32Array]') {
+	                    marker += TYPE_INT32ARRAY;
+	                } else if (valueString === '[object Uint32Array]') {
+	                    marker += TYPE_UINT32ARRAY;
+	                } else if (valueString === '[object Float32Array]') {
+	                    marker += TYPE_FLOAT32ARRAY;
+	                } else if (valueString === '[object Float64Array]') {
+	                    marker += TYPE_FLOAT64ARRAY;
+	                } else {
+	                    callback(new Error('Failed to get type for BinaryArray'));
+	                }
+	            }
+
+	            callback(marker + bufferToString(buffer));
+	        } else if (valueString === '[object Blob]') {
+	            // Conver the blob to a binaryArray and then to a string.
+	            var fileReader = new FileReader();
+
+	            fileReader.onload = function () {
+	                // Backwards-compatible prefix for the blob type.
+	                var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);
+
+	                callback(SERIALIZED_MARKER + TYPE_BLOB + str);
+	            };
+
+	            fileReader.readAsArrayBuffer(value);
+	        } else {
+	            try {
+	                callback(JSON.stringify(value));
+	            } catch (e) {
+	                console.error("Couldn't convert value into a JSON string: ", value);
+
+	                callback(null, e);
+	            }
+	        }
+	    }
+
+	    // Deserialize data we've inserted into a value column/field. We place
+	    // special markers into our strings to mark them as encoded; this isn't
+	    // as nice as a meta field, but it's the only sane thing we can do whilst
+	    // keeping localStorage support intact.
+	    //
+	    // Oftentimes this will just deserialize JSON content, but if we have a
+	    // special marker (SERIALIZED_MARKER, defined above), we will extract
+	    // some kind of arraybuffer/binary data/typed array out of the string.
+	    function deserialize(value) {
+	        // If we haven't marked this string as being specially serialized (i.e.
+	        // something other than serialized JSON), we can just return it and be
+	        // done with it.
+	        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
+	            return JSON.parse(value);
+	        }
+
+	        // The following code deals with deserializing some kind of Blob or
+	        // TypedArray. First we separate out the type of data we're dealing
+	        // with from the data itself.
+	        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
+	        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
+
+	        var blobType;
+	        // Backwards-compatible blob type serialization strategy.
+	        // DBs created with older versions of localForage will simply not have the blob type.
+	        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
+	            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
+	            blobType = matcher[1];
+	            serializedString = serializedString.substring(matcher[0].length);
+	        }
+	        var buffer = stringToBuffer(serializedString);
+
+	        // Return the right type based on the code/type set during
+	        // serialization.
+	        switch (type) {
+	            case TYPE_ARRAYBUFFER:
+	                return buffer;
+	            case TYPE_BLOB:
+	                return _createBlob([buffer], { type: blobType });
+	            case TYPE_INT8ARRAY:
+	                return new Int8Array(buffer);
+	            case TYPE_UINT8ARRAY:
+	                return new Uint8Array(buffer);
+	            case TYPE_UINT8CLAMPEDARRAY:
+	                return new Uint8ClampedArray(buffer);
+	            case TYPE_INT16ARRAY:
+	                return new Int16Array(buffer);
+	            case TYPE_UINT16ARRAY:
+	                return new Uint16Array(buffer);
+	            case TYPE_INT32ARRAY:
+	                return new Int32Array(buffer);
+	            case TYPE_UINT32ARRAY:
+	                return new Uint32Array(buffer);
+	            case TYPE_FLOAT32ARRAY:
+	                return new Float32Array(buffer);
+	            case TYPE_FLOAT64ARRAY:
+	                return new Float64Array(buffer);
+	            default:
+	                throw new Error('Unkown type: ' + type);
+	        }
+	    }
+
+	    function stringToBuffer(serializedString) {
+	        // Fill the string into a ArrayBuffer.
+	        var bufferLength = serializedString.length * 0.75;
+	        var len = serializedString.length;
+	        var i;
+	        var p = 0;
+	        var encoded1, encoded2, encoded3, encoded4;
+
+	        if (serializedString[serializedString.length - 1] === '=') {
+	            bufferLength--;
+	            if (serializedString[serializedString.length - 2] === '=') {
+	                bufferLength--;
+	            }
+	        }
+
+	        var buffer = new ArrayBuffer(bufferLength);
+	        var bytes = new Uint8Array(buffer);
+
+	        for (i = 0; i < len; i += 4) {
+	            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
+	            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
+	            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
+	            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
+
+	            /*jslint bitwise: true */
+	            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
+	            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
+	            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
+	        }
+	        return buffer;
+	    }
+
+	    // Converts a buffer to a string to store, serialized, in the backend
+	    // storage library.
+	    function bufferToString(buffer) {
+	        // base64-arraybuffer
+	        var bytes = new Uint8Array(buffer);
+	        var base64String = '';
+	        var i;
+
+	        for (i = 0; i < bytes.length; i += 3) {
+	            /*jslint bitwise: true */
+	            base64String += BASE_CHARS[bytes[i] >> 2];
+	            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
+	            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
+	            base64String += BASE_CHARS[bytes[i + 2] & 63];
+	        }
+
+	        if (bytes.length % 3 === 2) {
+	            base64String = base64String.substring(0, base64String.length - 1) + '=';
+	        } else if (bytes.length % 3 === 1) {
+	            base64String = base64String.substring(0, base64String.length - 2) + '==';
+	        }
+
+	        return base64String;
+	    }
+
+	    var localforageSerializer = {
+	        serialize: serialize,
+	        deserialize: deserialize,
+	        stringToBuffer: stringToBuffer,
+	        bufferToString: bufferToString
+	    };
+
+	    exports['default'] = localforageSerializer;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ },
+/* 4 */
+/***/ function(module, exports, __webpack_require__) {
+
+	/*
+	 * Includes code from:
+	 *
+	 * base64-arraybuffer
+	 * https://github.com/niklasvh/base64-arraybuffer
+	 *
+	 * Copyright (c) 2012 Niklas von Hertzen
+	 * Licensed under the MIT license.
+	 */
+	'use strict';
+
+	exports.__esModule = true;
+	(function () {
+	    'use strict';
+
+	    var globalObject = this;
+	    var openDatabase = this.openDatabase;
+
+	    // If WebSQL methods aren't available, we can stop now.
+	    if (!openDatabase) {
+	        return;
+	    }
+
+	    // Open the WebSQL database (automatically creates one if one didn't
+	    // previously exist), using any options set in the config.
+	    function _initStorage(options) {
+	        var self = this;
+	        var dbInfo = {
+	            db: null
+	        };
+
+	        if (options) {
+	            for (var i in options) {
+	                dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
+	            }
+	        }
+
+	        var dbInfoPromise = new Promise(function (resolve, reject) {
+	            // Open the database; the openDatabase API will automatically
+	            // create it for us if it doesn't exist.
+	            try {
+	                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
+	            } catch (e) {
+	                return self.setDriver(self.LOCALSTORAGE).then(function () {
+	                    return self._initStorage(options);
+	                }).then(resolve)['catch'](reject);
+	            }
+
+	            // Create our key/value table if it doesn't exist.
+	            dbInfo.db.transaction(function (t) {
+	                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {
+	                    self._dbInfo = dbInfo;
+	                    resolve();
+	                }, function (t, error) {
+	                    reject(error);
+	                });
+	            });
+	        });
+
+	        return new Promise(function (resolve, reject) {
+	            resolve(__webpack_require__(3));
+	        }).then(function (lib) {
+	            dbInfo.serializer = lib;
+	            return dbInfoPromise;
+	        });
+	    }
+
+	    function getItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
+	                        var result = results.rows.length ? results.rows.item(0).value : null;
+
+	                        // Check to see if this is serialized content we need to
+	                        // unpack.
+	                        if (result) {
+	                            result = dbInfo.serializer.deserialize(result);
+	                        }
+
+	                        resolve(result);
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function iterate(iterator, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
+	                        var rows = results.rows;
+	                        var length = rows.length;
+
+	                        for (var i = 0; i < length; i++) {
+	                            var item = rows.item(i);
+	                            var result = item.value;
+
+	                            // Check to see if this is serialized content
+	                            // we need to unpack.
+	                            if (result) {
+	                                result = dbInfo.serializer.deserialize(result);
+	                            }
+
+	                            result = iterator(result, item.key, i + 1);
+
+	                            // void(0) prevents problems with redefinition
+	                            // of `undefined`.
+	                            if (result !== void 0) {
+	                                resolve(result);
+	                                return;
+	                            }
+	                        }
+
+	                        resolve();
+	                    }, function (t, error) {
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function setItem(key, value, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                // The localStorage API doesn't return undefined values in an
+	                // "expected" way, so undefined is always cast to null in all
+	                // drivers. See: https://github.com/mozilla/localForage/pull/42
+	                if (value === undefined) {
+	                    value = null;
+	                }
+
+	                // Save the original value to pass to the callback.
+	                var originalValue = value;
+
+	                var dbInfo = self._dbInfo;
+	                dbInfo.serializer.serialize(value, function (value, error) {
+	                    if (error) {
+	                        reject(error);
+	                    } else {
+	                        dbInfo.db.transaction(function (t) {
+	                            t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {
+	                                resolve(originalValue);
+	                            }, function (t, error) {
+	                                reject(error);
+	                            });
+	                        }, function (sqlError) {
+	                            // The transaction failed; check
+	                            // to see if it's a quota error.
+	                            if (sqlError.code === sqlError.QUOTA_ERR) {
+	                                // We reject the callback outright for now, but
+	                                // it's worth trying to re-run the transaction.
+	                                // Even if the user accepts the prompt to use
+	                                // more storage on Safari, this error will
+	                                // be called.
+	                                //
+	                                // TODO: Try to re-run the transaction.
+	                                reject(sqlError);
+	                            }
+	                        });
+	                    }
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function removeItem(key, callback) {
+	        var self = this;
+
+	        // Cast the key to a string, as that's all we can set as a key.
+	        if (typeof key !== 'string') {
+	            globalObject.console.warn(key + ' used as a key, but it is not a string.');
+	            key = String(key);
+	        }
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
+	                        resolve();
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Deletes every item in the table.
+	    // TODO: Find out if this resets the AUTO_INCREMENT number.
+	    function clear(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {
+	                        resolve();
+	                    }, function (t, error) {
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Does a simple `COUNT(key)` to get the number of items stored in
+	    // localForage.
+	    function length(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    // Ahhh, SQL makes this one soooooo easy.
+	                    t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
+	                        var result = results.rows.item(0).c;
+
+	                        resolve(result);
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    // Return the key located at key index X; essentially gets the key from a
+	    // `WHERE id = ?`. This is the most efficient way I can think to implement
+	    // this rarely-used (in my experience) part of the API, but it can seem
+	    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
+	    // the ID of each key will change every time it's updated. Perhaps a stored
+	    // procedure for the `setItem()` SQL would solve this problem?
+	    // TODO: Don't change ID on `setItem()`.
+	    function key(n, callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
+	                        var result = results.rows.length ? results.rows.item(0).key : null;
+	                        resolve(result);
+	                    }, function (t, error) {
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function keys(callback) {
+	        var self = this;
+
+	        var promise = new Promise(function (resolve, reject) {
+	            self.ready().then(function () {
+	                var dbInfo = self._dbInfo;
+	                dbInfo.db.transaction(function (t) {
+	                    t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
+	                        var keys = [];
+
+	                        for (var i = 0; i < results.rows.length; i++) {
+	                            keys.push(results.rows.item(i).key);
+	                        }
+
+	                        resolve(keys);
+	                    }, function (t, error) {
+
+	                        reject(error);
+	                    });
+	                });
+	            })['catch'](reject);
+	        });
+
+	        executeCallback(promise, callback);
+	        return promise;
+	    }
+
+	    function executeCallback(promise, callback) {
+	        if (callback) {
+	            promise.then(function (result) {
+	                callback(null, result);
+	            }, function (error) {
+	                callback(error);
+	            });
+	        }
+	    }
+
+	    var webSQLStorage = {
+	        _driver: 'webSQLStorage',
+	        _initStorage: _initStorage,
+	        iterate: iterate,
+	        getItem: getItem,
+	        setItem: setItem,
+	        removeItem: removeItem,
+	        clear: clear,
+	        length: length,
+	        key: key,
+	        keys: keys
+	    };
+
+	    exports['default'] = webSQLStorage;
+	}).call(typeof window !== 'undefined' ? window : self);
+	module.exports = exports['default'];
+
+/***/ }
+/******/ ])
 });
+;
diff --git a/browser-version/test/nedb-browser.js b/browser-version/test/nedb-browser.js
index f451f42..e7e903a 100755
--- a/browser-version/test/nedb-browser.js
+++ b/browser-version/test/nedb-browser.js
@@ -254,22 +254,19 @@ describe('Indexing', function () {
     db.insert({ a: 4 }, function () {
       db.insert({ a: 6 }, function () {
         db.insert({ a: 7 }, function () {
-          db.getCandidates({ a: 6 }, function (err, candidates) {
-            console.log(candidates);
-            assert.equal(candidates.length, 3);
-            assert.isDefined(_.find(candidates, function (doc) { return doc.a === 4; }));
-            assert.isDefined(_.find(candidates, function (doc) { return doc.a === 6; }));
-            assert.isDefined(_.find(candidates, function (doc) { return doc.a === 7; }));
+          var candidates = db.getCandidates({ a: 6 })
+          assert.equal(candidates.length, 3);
+          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 4; }));
+          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 6; }));
+          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 7; }));
 
-            db.ensureIndex({ fieldName: 'a' });
+          db.ensureIndex({ fieldName: 'a' });
 
-            db.getCandidates({ a: 6 }, function (err, candidates) {
-              assert.equal(candidates.length, 1);
-              assert.isDefined(_.find(candidates, function (doc) { return doc.a === 6; }));
+          candidates = db.getCandidates({ a: 6 })
+          assert.equal(candidates.length, 1);
+          assert.isDefined(_.find(candidates, function (doc) { return doc.a === 6; }));
 
-              done();
-            });
-          });
+          done();
         });
       });
     });
diff --git a/browser-version/test/testBlob.html b/browser-version/test/testBlob.html
deleted file mode 100755
index f36e60f..0000000
--- a/browser-version/test/testBlob.html
+++ /dev/null
@@ -1,14 +0,0 @@
-<!DOCTYPE html>
-<html>
-<head>
-  <meta charset="utf-8">
-  <title>Test NeDB persistence in the browser</title>
-  <link rel="stylesheet" href="mocha.css">
-</head>
-<body>
-  <div id="results"></div>
-  <script src="../out/nedb.js"></script>
-  <script src="../node_modules/localforage/dist/localforage.js"></script>
-  <script src="./testBlob.js"></script>
-</body>
-</html>
diff --git a/browser-version/test/testBlob.js b/browser-version/test/testBlob.js
deleted file mode 100755
index 15d0f29..0000000
--- a/browser-version/test/testBlob.js
+++ /dev/null
@@ -1,50 +0,0 @@
-console.log('Beginning tests');
-console.log('Please note these tests work on Chrome latest, might not work on other browsers due to discrepancies in how local storage works for the file:// protocol');
-
-function testsFailed () {
-  document.getElementById('results').innerHTML = 'TESTS FAILED';
-}
-
-var filename = 'blob';
-var store = localforage.createInstance({
-  name: 'test',
-  storeName: 'blobs'
-});
-var item = { hello: 'world', _id: '1' };
-
-var db = new Nedb({ filename: filename, autoload: true });
-
-function loadXHR (url) {
-  return new Promise(function (resolve, reject) {
-    try {
-      var xhr = new XMLHttpRequest();
-      xhr.open('GET', url);
-      xhr.responseType = 'blob';
-      xhr.onerror = function () {reject('Network error.');};
-      xhr.onload = function () {
-        if (xhr.status === 200) {resolve(xhr.response);}else {reject('Loading error:' + xhr.statusText);}
-      };
-      xhr.send();
-    } catch(err) {reject(err.message); }
-  });
-}
-
-loadXHR('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQOCi1uZzynmYhuAbLg6YLVENsiNI6uTpqpBU9EqTerEPbUrgij')
-  .then(function (b) {
-    item.blob = b;
-    store.setItem(item._id, item)
-      .then(function (r) {
-        console.log(r);
-      })
-      .catch(function (e) {
-        console.error(e);
-      });
-
-    db.update({_id: item._id}, item, { upsert: true }, function (err) {
-      if (err) {
-        console.log(err);
-        testsFailed();
-        return;
-      }
-    });
-  });
diff --git a/lib/cursor.js b/lib/cursor.js
index 673d7a4..430a9b4 100755
--- a/lib/cursor.js
+++ b/lib/cursor.js
@@ -11,7 +11,7 @@ var model = require('./model')
  * Create a new cursor for this collection
  * @param {Datastore} db - The datastore this cursor is bound to
  * @param {Query} query - The query this cursor will operate on
- * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove
+ * @param {Function} execDn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove
  */
 function Cursor (db, query, execFn) {
   this.db = db;
@@ -83,19 +83,7 @@ Cursor.prototype.project = function (candidates) {
 
   // Do the actual projection
   candidates.forEach(function (candidate) {
-    var toPush;
-    if (action === 1) {   // pick-type projection
-      toPush = { $set: {} };
-      keys.forEach(function (k) {
-        toPush.$set[k] = model.getDotValue(candidate, k);
-        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
-      });
-      toPush = model.modify({}, toPush);
-    } else {   // omit-type projection
-      toPush = { $unset: {} };
-      keys.forEach(function (k) { toPush.$unset[k] = true });
-      toPush = model.modify(candidate, toPush);
-    }
+    var toPush = action === 1 ? _.pick(candidate, keys) : _.omit(candidate, keys);
     if (keepId) {
       toPush._id = candidate._id;
     } else {
@@ -115,83 +103,76 @@ Cursor.prototype.project = function (candidates) {
  *
  * @param {Function} callback - Signature: err, results
  */
-Cursor.prototype._exec = function(_callback) {
-  var res = [], added = 0, skipped = 0, self = this
+Cursor.prototype._exec = function(callback) {
+  var candidates = this.db.getCandidates(this.query)
+    , res = [], added = 0, skipped = 0, self = this
     , error = null
     , i, keys, key
     ;
 
-  function callback (error, res) {
-    if (self.execFn) {
-      return self.execFn(error, res, _callback);
-    } else {
-      return _callback(error, res);
-    }
-  }
-
-  this.db.getCandidates(this.query, function (err, candidates) {
-    if (err) { return callback(err); }
-
-    try {
-      for (i = 0; i < candidates.length; i += 1) {
-        if (model.match(candidates[i], self.query)) {
-          // If a sort is defined, wait for the results to be sorted before applying limit and skip
-          if (!self._sort) {
-            if (self._skip && self._skip > skipped) {
-              skipped += 1;
-            } else {
-              res.push(candidates[i]);
-              added += 1;
-              if (self._limit && self._limit <= added) { break; }
-            }
+  try {
+    for (i = 0; i < candidates.length; i += 1) {
+      if (model.match(candidates[i], this.query)) {
+        // If a sort is defined, wait for the results to be sorted before applying limit and skip
+        if (!this._sort) {
+          if (this._skip && this._skip > skipped) {
+            skipped += 1;
           } else {
             res.push(candidates[i]);
+            added += 1;
+            if (this._limit && this._limit <= added) { break; }
           }
+        } else {
+          res.push(candidates[i]);
         }
       }
-    } catch (err) {
-      return callback(err);
     }
+  } catch (err) {
+    return callback(err);
+  }
 
-    // Apply all sorts
-    if (self._sort) {
-      keys = Object.keys(self._sort);
+  // Apply all sorts
+  if (this._sort) {
+    keys = Object.keys(this._sort);
 
-      // Sorting
-      var criteria = [];
-      for (i = 0; i < keys.length; i++) {
-        key = keys[i];
-        criteria.push({ key: key, direction: self._sort[key] });
-      }
-      res.sort(function(a, b) {
-        var criterion, compare, i;
-        for (i = 0; i < criteria.length; i++) {
-          criterion = criteria[i];
-          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);
-          if (compare !== 0) {
-            return compare;
-          }
+    // Sorting
+    var criteria = [];
+    for (i = 0; i < keys.length; i++) {
+      key = keys[i];
+      criteria.push({ key: key, direction: self._sort[key] });
+    }
+    res.sort(function(a, b) {
+      var criterion, compare, i;
+      for (i = 0; i < criteria.length; i++) {
+        criterion = criteria[i];
+        compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key));
+        if (compare !== 0) {
+          return compare;
         }
-        return 0;
-      });
+      }
+      return 0;
+    });
 
-      // Applying limit and skip
-      var limit = self._limit || res.length
-        , skip = self._skip || 0;
+    // Applying limit and skip
+    var limit = this._limit || res.length
+      , skip = this._skip || 0;
 
-      res = res.slice(skip, skip + limit);
-    }
+    res = res.slice(skip, skip + limit);
+  }
 
-    // Apply projection
-    try {
-      res = self.project(res);
-    } catch (e) {
-      error = e;
-      res = undefined;
-    }
+  // Apply projection
+  try {
+    res = this.project(res);
+  } catch (e) {
+    error = e;
+    res = undefined;
+  }
 
+  if (this.execFn) {
+    return this.execFn(error, res, callback);
+  } else {
     return callback(error, res);
-  });
+  }
 };
 
 Cursor.prototype.exec = function () {
diff --git a/lib/datastore.js b/lib/datastore.js
index 6b59217..c5856f1 100755
--- a/lib/datastore.js
+++ b/lib/datastore.js
@@ -21,10 +21,6 @@ var customUtils = require('./customUtils')
  * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown
  * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks
  * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt
- * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting
- *
- * Event Emitter - Events
- * * compaction.done - Fired whenever a compaction operation was finished
  */
 function Datastore (options) {
   var filename;
@@ -49,9 +45,6 @@ function Datastore (options) {
     this.filename = filename;
   }
 
-  // String comparison function
-  this.compareStrings = options.compareStrings;
-
   // Persistence handling
   this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName
                                       , afterSerialization: options.afterSerialization
@@ -69,7 +62,6 @@ function Datastore (options) {
   // binary is always well-balanced
   this.indexes = {};
   this.indexes._id = new Index({ fieldName: '_id', unique: true });
-  this.ttlIndexes = {};
 
   // Queue a load of the database right away and call the onload handler
   // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception
@@ -78,8 +70,6 @@ function Datastore (options) {
   }); }
 }
 
-util.inherits(Datastore, require('events').EventEmitter);
-
 
 /**
  * Load the database from the datafile, and trigger the execution of buffered commands if any
@@ -116,7 +106,6 @@ Datastore.prototype.resetIndexes = function (newData) {
  * @param {String} options.fieldName
  * @param {Boolean} options.unique
  * @param {Boolean} options.sparse
- * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)
  * @param {Function} cb Optional callback, signature: err
  */
 Datastore.prototype.ensureIndex = function (options, cb) {
@@ -133,7 +122,6 @@ Datastore.prototype.ensureIndex = function (options, cb) {
   if (this.indexes[options.fieldName]) { return callback(null); }
 
   this.indexes[options.fieldName] = new Index(options);
-  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here
 
   try {
     this.indexes[options.fieldName].insert(this.getAllData());
@@ -246,90 +234,50 @@ Datastore.prototype.updateIndexes = function (oldDoc, newDoc) {
  * One way to make it better would be to enable the use of multiple indexes if the first usable index
  * returns too much data. I may do it in the future.
  *
- * Returned candidates will be scanned to find and remove all expired documents
- *
- * @param {Query} query
- * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations
- * @param {Function} callback Signature err, candidates
+ * TODO: needs to be moved to the Cursor module
  */
-Datastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {
+Datastore.prototype.getCandidates = function (query) {
   var indexNames = Object.keys(this.indexes)
-    , self = this
     , usableQueryKeys;
 
-  if (typeof dontExpireStaleDocs === 'function') {
-    callback = dontExpireStaleDocs;
-    dontExpireStaleDocs = false;
-  }
-
-
-  async.waterfall([
-  // STEP 1: get candidates list by checking indexes from most to least frequent usecase
-  function (cb) {
-    // For a basic match
-    usableQueryKeys = [];
-    Object.keys(query).forEach(function (k) {
-      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {
-        usableQueryKeys.push(k);
-      }
-    });
-    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
-    if (usableQueryKeys.length > 0) {
-      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));
+  // For a basic match
+  usableQueryKeys = [];
+  Object.keys(query).forEach(function (k) {
+    if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {
+      usableQueryKeys.push(k);
     }
+  });
+  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
+  if (usableQueryKeys.length > 0) {
+    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]);
+  }
 
-    // For a $in match
-    usableQueryKeys = [];
-    Object.keys(query).forEach(function (k) {
-      if (query[k] && query[k].hasOwnProperty('$in')) {
-        usableQueryKeys.push(k);
-      }
-    });
-    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
-    if (usableQueryKeys.length > 0) {
-      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));
+  // For a $in match
+  usableQueryKeys = [];
+  Object.keys(query).forEach(function (k) {
+    if (query[k] && query[k].hasOwnProperty('$in')) {
+      usableQueryKeys.push(k);
     }
+  });
+  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
+  if (usableQueryKeys.length > 0) {
+    return this.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in);
+  }
 
-    // For a comparison match
-    usableQueryKeys = [];
-    Object.keys(query).forEach(function (k) {
-      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {
-        usableQueryKeys.push(k);
-      }
-    });
-    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
-    if (usableQueryKeys.length > 0) {
-      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));
+  // For a comparison match
+  usableQueryKeys = [];
+  Object.keys(query).forEach(function (k) {
+    if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {
+      usableQueryKeys.push(k);
     }
-
-    // By default, return all the DB data
-    return cb(null, self.getAllData());
+  });
+  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
+  if (usableQueryKeys.length > 0) {
+    return this.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]);
   }
-  // STEP 2: remove all expired documents
-  , function (docs) {
-    if (dontExpireStaleDocs) { return callback(null, docs); }
-
-    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);
 
-    docs.forEach(function (doc) {
-      var valid = true;
-      ttlIndexesFieldNames.forEach(function (i) {
-        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {
-          valid = false;
-        }
-      });
-      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }
-    });
-
-    async.eachSeries(expiredDocsIds, function (_id, cb) {
-      self._remove({ _id: _id }, {}, function (err) {
-        if (err) { return callback(err); }
-        return cb();
-      });
-    }, function (err) {
-      return callback(null, validDocs);
-    });
-  }]);
+  // By default, return all the DB data
+  return this.getAllData();
 };
 
 
@@ -345,7 +293,7 @@ Datastore.prototype._insert = function (newDoc, cb) {
     ;
 
   try {
-    preparedDoc = this.prepareDocumentForInsertion(newDoc);
+    preparedDoc = this.prepareDocumentForInsertion(newDoc)
     this._insertInCache(preparedDoc);
   } catch (e) {
     return callback(e);
@@ -380,7 +328,7 @@ Datastore.prototype.prepareDocumentForInsertion = function (newDoc) {
   if (util.isArray(newDoc)) {
     preparedDoc = [];
     newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });
-  } else {    
+  } else {
     preparedDoc = model.deepCopy(newDoc);
     if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }
     var now = new Date();
@@ -539,20 +487,7 @@ Datastore.prototype.findOne = function (query, projection, callback) {
  *                 options.multi If true, can update multiple documents (defaults to false)
  *                 options.upsert If true, document is inserted if the query doesn't match anything
  *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)
- * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)
- *                      If update was an upsert, upsert flag is set to true
- *                      affectedDocuments can be one of the following:
- *                        * For an upsert, the upserted document
- *                        * For an update with returnUpdatedDocs option false, null
- *                        * For an update with returnUpdatedDocs true and multi false, the updated document
- *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents
- *
- * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,
- *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert
- *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of
- *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the
- *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on
- *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.
+ * @param {Function} cb Optional callback, signature: err, numReplaced, upsert (set to true if the update was in fact an upsert)
  *
  * @api private Use Datastore.update which has the same signature
  */
@@ -598,60 +533,54 @@ Datastore.prototype._update = function (query, updateQuery, options, cb) {
 
         return self._insert(toBeInserted, function (err, newDoc) {
           if (err) { return callback(err); }
-          return callback(null, 1, newDoc, true);
+          return callback(null, 1, newDoc);
         });
       }
     });
   }
   , function () {   // Perform the update
-    var modifiedDoc , modifications = [], createdAt;
+    var modifiedDoc
+      , candidates = self.getCandidates(query)
+      , modifications = []
+      ;
 
-    self.getCandidates(query, function (err, candidates) {
-      if (err) { return callback(err); }
-
-      // Preparing update (if an error is thrown here neither the datafile nor
-      // the in-memory indexes are affected)
-      try {
-        for (i = 0; i < candidates.length; i += 1) {
-          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {
-            numReplaced += 1;
-            if (self.timestampData) { createdAt = candidates[i].createdAt; }
-            modifiedDoc = model.modify(candidates[i], updateQuery);
-            if (self.timestampData) {
-              modifiedDoc.createdAt = createdAt;
-              modifiedDoc.updatedAt = new Date();
-            }
-            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });
-          }
+    // Preparing update (if an error is thrown here neither the datafile nor
+    // the in-memory indexes are affected)
+    try {
+      for (i = 0; i < candidates.length; i += 1) {
+        if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {
+          numReplaced += 1;
+          modifiedDoc = model.modify(candidates[i], updateQuery);
+          if (self.timestampData) { modifiedDoc.updatedAt = new Date(); }
+          modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });
         }
-      } catch (err) {
-        return callback(err);
       }
+    } catch (err) {
+      return callback(err);
+    }
 
-      // Change the docs in memory
-      try {
+    // Change the docs in memory
+    try {
         self.updateIndexes(modifications);
-      } catch (err) {
-        return callback(err);
-      }
+    } catch (err) {
+      return callback(err);
+    }
 
-      // Update the datafile
-      var updatedDocs = _.pluck(modifications, 'newDoc');
-      self.persistence.persistNewState(updatedDocs, function (err) {
-        if (err) { return callback(err); }
-        if (!options.returnUpdatedDocs) {
-          return callback(null, numReplaced);
-        } else {
-          var updatedDocsDC = [];
-          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });
-          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }
-          return callback(null, numReplaced, updatedDocsDC);
-        }
-      });
+    // Update the datafile
+    var updatedDocs = _.pluck(modifications, 'newDoc');
+    self.persistence.persistNewState(updatedDocs, function (err) {
+      if (err) { return callback(err); }
+      if (!options.returnUpdatedDocs) {
+        return callback(null, numReplaced);
+      } else {
+        var updatedDocsDC = [];
+        updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });
+        return callback(null, numReplaced, updatedDocsDC);
+      }
     });
-  }]);
+  }
+  ]);
 };
-
 Datastore.prototype.update = function () {
   this.executor.push({ this: this, fn: this._update, arguments: arguments });
 };
@@ -669,37 +598,39 @@ Datastore.prototype.update = function () {
  */
 Datastore.prototype._remove = function (query, options, cb) {
   var callback
-    , self = this, numRemoved = 0, removedDocs = [], multi
+    , self = this
+    , numRemoved = 0
+    , multi
+    , removedDocs = []
+    , candidates = this.getCandidates(query)
     ;
 
   if (typeof options === 'function') { cb = options; options = {}; }
   callback = cb || function () {};
   multi = options.multi !== undefined ? options.multi : false;
 
-  this.getCandidates(query, true, function (err, candidates) {
-    if (err) { return callback(err); }
-
-    try {
-      candidates.forEach(function (d) {
-        if (model.match(d, query) && (multi || numRemoved === 0)) {
-          numRemoved += 1;
-          removedDocs.push({ $$deleted: true, _id: d._id });
-          self.removeFromIndexes(d);
-        }
-      });
-    } catch (err) { return callback(err); }
-
-    self.persistence.persistNewState(removedDocs, function (err) {
-      if (err) { return callback(err); }
-      return callback(null, numRemoved);
+  try {
+    candidates.forEach(function (d) {
+      if (model.match(d, query) && (multi || numRemoved === 0)) {
+        numRemoved += 1;
+        removedDocs.push({ $$deleted: true, _id: d._id });
+        self.removeFromIndexes(d);
+      }
     });
+  } catch (err) { return callback(err); }
+
+  self.persistence.persistNewState(removedDocs, function (err) {
+    if (err) { return callback(err); }
+    return callback(null, numRemoved);
   });
 };
-
 Datastore.prototype.remove = function () {
   this.executor.push({ this: this, fn: this._remove, arguments: arguments });
 };
 
 
 
+
+
+
 module.exports = Datastore;
diff --git a/lib/executor.js b/lib/executor.js
index 979ca7d..a555bd3 100755
--- a/lib/executor.js
+++ b/lib/executor.js
@@ -11,16 +11,17 @@ function Executor () {
 
   // This queue will execute all commands, one-by-one in order
   this.queue = async.queue(function (task, cb) {
-    var newArguments = [];
+    var callback
+      , lastArg = task.arguments[task.arguments.length - 1]
+      , i, newArguments = []
+      ;
 
     // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array
-    for (var i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
-    var lastArg = task.arguments[task.arguments.length - 1];
+    for (i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
 
     // Always tell the queue task is complete. Execute callback if any was given.
     if (typeof lastArg === 'function') {
-      // Callback was supplied
-      newArguments[newArguments.length - 1] = function () {
+      callback = function () {
         if (typeof setImmediate === 'function') {
            setImmediate(cb);
         } else {
@@ -28,12 +29,11 @@ function Executor () {
         }
         lastArg.apply(null, arguments);
       };
-    } else if (!lastArg && task.arguments.length !== 0) {
-      // false/undefined/null supplied as callbback
-      newArguments[newArguments.length - 1] = function () { cb(); };
+
+      newArguments[newArguments.length - 1] = callback;
     } else {
-      // Nothing supplied as callback
-      newArguments.push(function () { cb(); });
+      callback = function () { cb(); };
+      newArguments.push(callback);
     }
 
 
@@ -48,8 +48,7 @@ function Executor () {
  * @param {Object} task
  *                 task.this - Object to use as this
  *                 task.fn - Function to execute
- *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)
- *                                                                 and the last argument cannot be false/undefined/null
+ *                 task.arguments - Array of arguments
  * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready
  */
 Executor.prototype.push = function (task, forceQueuing) {
diff --git a/lib/indexes.js b/lib/indexes.js
index 391837b..09952fb 100755
--- a/lib/indexes.js
+++ b/lib/indexes.js
@@ -88,12 +88,12 @@ Index.prototype.insert = function (doc) {
         break;
       }
     }
-
+    
     if (error) {
       for (i = 0; i < failingI; i += 1) {
         this.tree.delete(keys[i], doc);
       }
-
+      
       throw error;
     }
   }
diff --git a/lib/model.js b/lib/model.js
index 3dd1e66..6d7b950 100755
--- a/lib/model.js
+++ b/lib/model.js
@@ -124,24 +124,6 @@ function deepCopy (obj, strictKeys) {
   }
 
   if (typeof obj === 'object') {
-    var toString = Object.prototype.toString;
-    switch(toString.call(obj)) {
-        case '[object Blob]':
-        case '[object ArrayBuffer]':
-        case '[object Int8Array]':
-        case '[object Uint8Array]':
-        case '[object Uint8ClampedArray]':
-        case '[object Int16Array]':
-        case '[object Uint16Array]':
-        case '[object Int32Array]':
-        case '[object Uint32Array]':
-        case '[object Float32Array]':
-        case '[object Float64Array]':
-        {
-            return obj;
-        }
-        break;
-    }
     res = {};
     Object.keys(obj).forEach(function (k) {
       if (!strictKeys || (k[0] !== '$' && k.indexOf('.') === -1)) {
@@ -201,12 +183,9 @@ function compareArrays (a, b) {
  * In the case of objects and arrays, we deep-compare
  * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects
  * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)
- *
- * @param {Function} _compareStrings String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)
  */
-function compareThings (a, b, _compareStrings) {
-  var aKeys, bKeys, comp, i
-    , compareStrings = _compareStrings || compareNSB;
+function compareThings (a, b) {
+  var aKeys, bKeys, comp, i;
 
   // undefined
   if (a === undefined) { return b === undefined ? 0 : -1; }
@@ -221,8 +200,8 @@ function compareThings (a, b, _compareStrings) {
   if (typeof b === 'number') { return typeof a === 'number' ? compareNSB(a, b) : 1; }
 
   // Strings
-  if (typeof a === 'string') { return typeof b === 'string' ? compareStrings(a, b) : -1; }
-  if (typeof b === 'string') { return typeof a === 'string' ? compareStrings(a, b) : 1; }
+  if (typeof a === 'string') { return typeof b === 'string' ? compareNSB(a, b) : -1; }
+  if (typeof b === 'string') { return typeof a === 'string' ? compareNSB(a, b) : 1; }
 
   // Booleans
   if (typeof a === 'boolean') { return typeof b === 'boolean' ? compareNSB(a, b) : -1; }
@@ -282,9 +261,6 @@ lastStepModifierFunctions.$unset = function (obj, field, value) {
 
 /**
  * Push an element to the end of an array field
- * Optional modifier $each instead of value to push several values
- * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/
- * Différeence with MongoDB: if $slice is specified and not $each, we act as if value is an empty array
  */
 lastStepModifierFunctions.$push = function (obj, field, value) {
   // Create the array if it doesn't exist
@@ -292,33 +268,13 @@ lastStepModifierFunctions.$push = function (obj, field, value) {
 
   if (!util.isArray(obj[field])) { throw new Error("Can't $push an element on non-array values"); }
 
-  if (value !== null && typeof value === 'object' && value.$slice && value.$each === undefined) {
-    value.$each = [];
-  }
-
   if (value !== null && typeof value === 'object' && value.$each) {
-    if (Object.keys(value).length >= 3 || (Object.keys(value).length === 2 && value.$slice === undefined)) { throw new Error("Can only use $slice in cunjunction with $each when $push to array"); }
+    if (Object.keys(value).length > 1) { throw new Error("Can't use another field in conjunction with $each"); }
     if (!util.isArray(value.$each)) { throw new Error("$each requires an array value"); }
 
     value.$each.forEach(function (v) {
       obj[field].push(v);
     });
-
-    if (value.$slice === undefined || typeof value.$slice !== 'number') { return; }
-
-    if (value.$slice === 0) {
-      obj[field] = [];
-    } else {
-      var start, end, n = obj[field].length;
-      if (value.$slice < 0) {
-        start = Math.max(0, n + value.$slice);
-        end = n;
-      } else if (value.$slice > 0) {
-        start = 0;
-        end = Math.min(n, value.$slice);
-      }
-      obj[field] = obj[field].slice(start, end);
-    }
   } else {
     obj[field].push(value);
   }
@@ -404,28 +360,6 @@ lastStepModifierFunctions.$inc = function (obj, field, value) {
   }
 };
 
-/**
- * Updates the value of the field, only if specified field is greater than the current value of the field
- */
-lastStepModifierFunctions.$max = function (obj, field, value) {
-  if (typeof obj[field] === 'undefined') {
-    obj[field] = value;
-  } else if (value > obj[field]) {
-    obj[field] = value;
-  }
-};
-
-/**
- * Updates the value of the field, only if specified field is smaller than the current value of the field
- */
-lastStepModifierFunctions.$min = function (obj, field, value) {
-  if (typeof obj[field] === 'undefined') { 
-    obj[field] = value;
-  } else if (value < obj[field]) {
-    obj[field] = value;
-  }
-};
-
 // Given its name, create the complete modifier function
 function createModifierFunction (modifier) {
   return function (obj, field, value) {
@@ -434,10 +368,7 @@ function createModifierFunction (modifier) {
     if (fieldParts.length === 1) {
       lastStepModifierFunctions[modifier](obj, field, value);
     } else {
-      if (obj[fieldParts[0]] === undefined) {
-        if (modifier === '$unset') { return; }   // Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented
-        obj[fieldParts[0]] = {};
-      }
+      obj[fieldParts[0]] = obj[fieldParts[0]] || {};
       modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);
     }
   };
@@ -478,7 +409,7 @@ function modify (obj, updateQuery) {
 
       if (!modifierFunctions[m]) { throw new Error("Unknown modifier " + m); }
 
-      // Can't rely on Object.keys throwing on non objects since ES6
+      // Can't rely on Object.keys throwing on non objects since ES6{
       // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it
       if (typeof updateQuery[m] !== 'object') {
         throw new Error("Modifier " + m + "'s argument must be an object");
@@ -555,7 +486,7 @@ function areThingsEqual (a, b) {
 
   // Arrays (no match since arrays are used as a $in)
   // undefined (no match since they mean field doesn't exist and can't be serialized)
-  if ((!(util.isArray(a) && util.isArray(b)) && (util.isArray(a) || util.isArray(b))) || a === undefined || b === undefined) { return false; }
+  if (util.isArray(a) || util.isArray(b) || a === undefined || b === undefined) { return false; }
 
   // General objects (check for deep equality)
   // a and b should be objects at this point
@@ -665,20 +596,7 @@ comparisonFunctions.$size = function (obj, value) {
 
     return (obj.length == value);
 };
-comparisonFunctions.$elemMatch = function (obj, value) {
-  if (!util.isArray(obj)) { return false; }
-  var i = obj.length;
-  var result = false;   // Initialize result
-  while (i--) {
-    if (match(obj[i], value)) {   // If match for array element, return true
-      result = true;
-      break;
-    }
-  }
-  return result;
-};
 arrayComparisonFunctions.$size = true;
-arrayComparisonFunctions.$elemMatch = true;
 
 
 /**
@@ -787,11 +705,6 @@ function matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {
 
   // Check if the value is an array if we don't force a treatment as value
   if (util.isArray(objValue) && !treatObjAsValue) {
-    // If the queryValue is an array, try to perform an exact match
-    if (util.isArray(queryValue)) {
-      return matchQueryPart(obj, queryKey, queryValue, true);
-    }
-
     // Check if we are using an array-specific comparison function
     if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {
       keys = Object.keys(queryValue);
@@ -809,7 +722,7 @@ function matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {
 
   // queryValue is an actual object. Determine whether it contains comparison operators
   // or only normal fields. Mixed objects are not allowed
-  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue) && !util.isArray(queryValue)) {
+  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {
     keys = Object.keys(queryValue);
     firstChars = _.map(keys, function (item) { return item[0]; });
     dollarFirstChars = _.filter(firstChars, function (c) { return c === '$'; });
diff --git a/lib/persistence.js b/lib/persistence.js
index 670a211..a83563a 100755
--- a/lib/persistence.js
+++ b/lib/persistence.js
@@ -13,20 +13,7 @@ var storage = require('./storage')
   , Index = require('./indexes')
   ;
 
-if (storage.forage && storage.forage.supports('asyncStorage')) {   
-    model.serialize = function(d) {return d;};
-    oldDeserialize = model.deserialize;
-    model.deserialize = function(d) {
-        if (typeof(d) == 'string') {
-            return oldDeserialize(d);
-        }
-        return d;
-    };
-    if (storage) {
-        model.noSerialize = true;
-        storage.setNoSerialize(true);
-    }
-}
+
 /**
  * Create a new Persistence object for database options.db
  * @param {Datastore} options.db
@@ -123,14 +110,6 @@ Persistence.getNWAppFilename = function (appName, relativeFilename) {
   return path.join(home, 'nedb-data', relativeFilename);
 }
 
-Persistence.prototype.addToPersist = function(persist, data) {
-    if (model.noSerialize) {
-        persist.push(data);
-    } else {
-        persist += data + '\n';
-    }
-    return persist;
-};
 
 /**
  * Persist cached database
@@ -141,26 +120,21 @@ Persistence.prototype.addToPersist = function(persist, data) {
 Persistence.prototype.persistCachedDatabase = function (cb) {
   var callback = cb || function () {}
     , toPersist = ''
-    , self = this;
+    , self = this
+    ;
 
   if (this.inMemoryOnly) { return callback(null); }
-  if (!!model.noSerialize) {
-    toPersist = [];
-  }
+
   this.db.getAllData().forEach(function (doc) {
-    toPersist = self.addToPersist(toPersist, self.afterSerialization(model.serialize(doc)));
+    toPersist += self.afterSerialization(model.serialize(doc)) + '\n';
   });
   Object.keys(this.db.indexes).forEach(function (fieldName) {
     if (fieldName != "_id") {   // The special _id index is managed by datastore.js, the others need to be persisted
-      toPersist = self.addToPersist(toPersist, self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})));
+      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})) + '\n';
     }
   });
-  
-  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {
-    if (err) { return callback(err); }
-    self.db.emit('compaction.done');
-    return callback(null);
-  });
+
+  storage.crashSafeWriteFile(this.filename, toPersist, callback);
 };
 
 
@@ -212,14 +186,11 @@ Persistence.prototype.persistNewState = function (newDocs, cb) {
 
   // In-memory only datastore
   if (self.inMemoryOnly) { return callback(null); }
-  if (!!model.noSerialize) {
-    toPersist = [];
-  }
 
   newDocs.forEach(function (doc) {
-    toPersist = self.addToPersist(toPersist, self.afterSerialization(model.serialize(doc)));
+    toPersist += self.afterSerialization(model.serialize(doc)) + '\n';
   });
-  
+
   if (toPersist.length === 0) { return callback(null); }
 
   storage.appendFile(self.filename, toPersist, 'utf8', function (err) {
@@ -227,28 +198,13 @@ Persistence.prototype.persistNewState = function (newDocs, cb) {
   });
 };
 
-Persistence.prototype.split = function (data) {
-    if (model.noSerialize) {
-        if (typeof(data) == 'string') {
-            return data.split('\n');
-        }
-
-        return data;
-    }
-
-    if (typeof(data) == 'string') {
-        return data.split('\n');
-    }
-
-    return data;
-};
 
 /**
  * From a database's raw data, return the corresponding
  * machine understandable collection
  */
 Persistence.prototype.treatRawData = function (rawData) {
-  var data = this.split(rawData)
+  var data = rawData.split('\n')
     , dataById = {}
     , tdata = []
     , i
diff --git a/package-lock.json b/package-lock.json
deleted file mode 100644
index b75a01e..0000000
--- a/package-lock.json
+++ /dev/null
@@ -1,221 +0,0 @@
-{
-  "name": "nedb",
-  "version": "1.7.1",
-  "lockfileVersion": 1,
-  "requires": true,
-  "dependencies": {
-    "assertion-error": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz",
-      "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==",
-      "dev": true
-    },
-    "async": {
-      "version": "0.2.10",
-      "resolved": "https://registry.npmjs.org/async/-/async-0.2.10.tgz",
-      "integrity": "sha1-trvgsGdLnXGXCMo43owjfLUmw9E="
-    },
-    "binary-search-tree": {
-      "version": "0.2.5",
-      "resolved": "https://registry.npmjs.org/binary-search-tree/-/binary-search-tree-0.2.5.tgz",
-      "integrity": "sha1-fbs7IQ/coIJFDa0jNMMErzm9x4Q=",
-      "requires": {
-        "underscore": "~1.4.4"
-      }
-    },
-    "chai": {
-      "version": "3.5.0",
-      "resolved": "https://registry.npmjs.org/chai/-/chai-3.5.0.tgz",
-      "integrity": "sha1-TQJjewZ/6Vi9v906QOxW/vc3Mkc=",
-      "dev": true,
-      "requires": {
-        "assertion-error": "^1.0.1",
-        "deep-eql": "^0.1.3",
-        "type-detect": "^1.0.0"
-      }
-    },
-    "commander": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/commander/-/commander-1.1.1.tgz",
-      "integrity": "sha1-UNFlGGiuYOzP8KLZ80WVN2vGsEE=",
-      "dev": true,
-      "requires": {
-        "keypress": "0.1.x"
-      }
-    },
-    "debug": {
-      "version": "3.1.0",
-      "resolved": "https://registry.npmjs.org/debug/-/debug-3.1.0.tgz",
-      "integrity": "sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==",
-      "dev": true,
-      "requires": {
-        "ms": "2.0.0"
-      },
-      "dependencies": {
-        "ms": {
-          "version": "2.0.0",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
-          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
-          "dev": true
-        }
-      }
-    },
-    "deep-eql": {
-      "version": "0.1.3",
-      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-0.1.3.tgz",
-      "integrity": "sha1-71WKyrjeJSBs1xOQbXTlaTDrafI=",
-      "dev": true,
-      "requires": {
-        "type-detect": "0.1.1"
-      },
-      "dependencies": {
-        "type-detect": {
-          "version": "0.1.1",
-          "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-0.1.1.tgz",
-          "integrity": "sha1-C6XsKohWQORw6k6FBZcZANrFiCI=",
-          "dev": true
-        }
-      }
-    },
-    "diff": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/diff/-/diff-1.0.2.tgz",
-      "integrity": "sha1-Suc/Gu6Nb89ITxoc53zmUdm38Mk=",
-      "dev": true
-    },
-    "exec-time": {
-      "version": "0.0.2",
-      "resolved": "https://registry.npmjs.org/exec-time/-/exec-time-0.0.2.tgz",
-      "integrity": "sha1-YzHchgzFqpemPZVuD9hH34sVcIw=",
-      "dev": true
-    },
-    "growl": {
-      "version": "1.5.1",
-      "resolved": "https://registry.npmjs.org/growl/-/growl-1.5.1.tgz",
-      "integrity": "sha1-HezR8ipLMNrn02N5nsYkz0DMAHA=",
-      "dev": true
-    },
-    "immediate": {
-      "version": "3.0.6",
-      "resolved": "https://registry.npmjs.org/immediate/-/immediate-3.0.6.tgz",
-      "integrity": "sha1-nbHb0Pr43m++D13V5Wu2BigN5ps="
-    },
-    "jade": {
-      "version": "0.26.3",
-      "resolved": "https://registry.npmjs.org/jade/-/jade-0.26.3.tgz",
-      "integrity": "sha1-jxDXl32NefL2/4YqgbBRPMslaGw=",
-      "dev": true,
-      "requires": {
-        "commander": "0.6.1",
-        "mkdirp": "0.3.0"
-      },
-      "dependencies": {
-        "commander": {
-          "version": "0.6.1",
-          "resolved": "https://registry.npmjs.org/commander/-/commander-0.6.1.tgz",
-          "integrity": "sha1-+mihT2qUXVTbvlDYzbMyDp47GgY=",
-          "dev": true
-        },
-        "mkdirp": {
-          "version": "0.3.0",
-          "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.3.0.tgz",
-          "integrity": "sha1-G79asbqCevI1dRQ0kEJkVfSB/h4=",
-          "dev": true
-        }
-      }
-    },
-    "keypress": {
-      "version": "0.1.0",
-      "resolved": "https://registry.npmjs.org/keypress/-/keypress-0.1.0.tgz",
-      "integrity": "sha1-SjGI1CkbZrT2XtuZ+AaqmuKTWSo=",
-      "dev": true
-    },
-    "lie": {
-      "version": "3.1.1",
-      "resolved": "https://registry.npmjs.org/lie/-/lie-3.1.1.tgz",
-      "integrity": "sha1-mkNrLMd0bKWd56QfpGmz77dr2H4=",
-      "requires": {
-        "immediate": "~3.0.5"
-      }
-    },
-    "localforage": {
-      "version": "1.7.1",
-      "resolved": "https://registry.npmjs.org/localforage/-/localforage-1.7.1.tgz",
-      "integrity": "sha1-5JJ+BCMCuGTbMPMhHxO1xvDell0=",
-      "requires": {
-        "lie": "3.1.1"
-      }
-    },
-    "minimist": {
-      "version": "0.0.8",
-      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz",
-      "integrity": "sha1-hX/Kv8M5fSYluCKCYuhqp6ARsF0="
-    },
-    "mkdirp": {
-      "version": "0.5.1",
-      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.1.tgz",
-      "integrity": "sha1-MAV0OOrGz3+MR2fzhkjWaX11yQM=",
-      "requires": {
-        "minimist": "0.0.8"
-      }
-    },
-    "mocha": {
-      "version": "1.4.3",
-      "resolved": "https://registry.npmjs.org/mocha/-/mocha-1.4.3.tgz",
-      "integrity": "sha1-82YwZR4Ghv4oPRvKyCC1KswJFAc=",
-      "dev": true,
-      "requires": {
-        "commander": "0.6.1",
-        "debug": "*",
-        "diff": "1.0.2",
-        "growl": "1.5.x",
-        "jade": "0.26.3",
-        "mkdirp": "0.3.3",
-        "ms": "0.3.0"
-      },
-      "dependencies": {
-        "commander": {
-          "version": "0.6.1",
-          "resolved": "https://registry.npmjs.org/commander/-/commander-0.6.1.tgz",
-          "integrity": "sha1-+mihT2qUXVTbvlDYzbMyDp47GgY=",
-          "dev": true
-        },
-        "mkdirp": {
-          "version": "0.3.3",
-          "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.3.3.tgz",
-          "integrity": "sha1-WV4lHBNww6aLqyE20ONIuBBa3xM=",
-          "dev": true
-        }
-      }
-    },
-    "ms": {
-      "version": "0.3.0",
-      "resolved": "https://registry.npmjs.org/ms/-/ms-0.3.0.tgz",
-      "integrity": "sha1-A+3DSNYT5mpWSGz9rFO8vomcvWE=",
-      "dev": true
-    },
-    "request": {
-      "version": "2.9.203",
-      "resolved": "https://registry.npmjs.org/request/-/request-2.9.203.tgz",
-      "integrity": "sha1-bBcRpUB/uUoRQhlWPkQUW8v0cjo=",
-      "dev": true
-    },
-    "sinon": {
-      "version": "1.3.4",
-      "resolved": "https://registry.npmjs.org/sinon/-/sinon-1.3.4.tgz",
-      "integrity": "sha1-n+XXRqy14Hjyb2WYoYsTz6BmxKs=",
-      "dev": true
-    },
-    "type-detect": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-1.0.0.tgz",
-      "integrity": "sha1-diIXzAbbJY7EiQihKY6LlRIejqI=",
-      "dev": true
-    },
-    "underscore": {
-      "version": "1.4.4",
-      "resolved": "https://registry.npmjs.org/underscore/-/underscore-1.4.4.tgz",
-      "integrity": "sha1-YaajIBBiKvoHljvzJSA88SI51gQ="
-    }
-  }
-}
diff --git a/package.json b/package.json
index ada5406..ee73d05 100755
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "nedb",
-  "version": "1.7.3",
+  "version": "1.6.0",
   "author": {
     "name": "Louis Chatriot",
     "email": "louis.chatriot@gmail.com"
@@ -22,7 +22,7 @@
   "dependencies": {
     "async": "0.2.10",
     "binary-search-tree": "0.2.5",
-    "localforage": "^1.7.1",
+    "localforage": "^1.3.0",
     "mkdirp": "~0.5.1",
     "underscore": "~1.4.4"
   },
diff --git a/test/cursor.test.js b/test/cursor.test.js
index 3bffa4a..103161f 100755
--- a/test/cursor.test.js
+++ b/test/cursor.test.js
@@ -97,7 +97,7 @@ describe('Cursor', function () {
       }
       ], done);
     });
-
+    
     it('With an empty collection', function (done) {
       async.waterfall([
         function (cb) {
@@ -113,7 +113,7 @@ describe('Cursor', function () {
         }
       ], done);
     });
-
+    
     it('With a limit', function (done) {
       var cursor = new Cursor(d);
       cursor.limit(3);
@@ -177,7 +177,7 @@ describe('Cursor', function () {
         for (i = 0; i < docs.length - 1; i += 1) {
           assert(docs[i].age < docs[i + 1].age)
         }
-
+        
         cursor.sort({ age: -1 });
         cursor.exec(function (err, docs) {
           assert.isNull(err);
@@ -187,54 +187,29 @@ describe('Cursor', function () {
           }
 
           done();
-        });
+        });          
       });
     });
-
-    it("Sorting strings with custom string comparison function", function (done) {
-      var db = new Datastore({ inMemoryOnly: true, autoload: true
-                             , compareStrings: function (a, b) { return a.length - b.length; }
-                             });
-
-      db.insert({ name: 'alpha' });
-      db.insert({ name: 'charlie' });
-      db.insert({ name: 'zulu' });
-
-      db.find({}).sort({ name: 1 }).exec(function (err, docs) {
-        _.pluck(docs, 'name')[0].should.equal('zulu');
-        _.pluck(docs, 'name')[1].should.equal('alpha');
-        _.pluck(docs, 'name')[2].should.equal('charlie');
-
-        delete db.compareStrings;
-        db.find({}).sort({ name: 1 }).exec(function (err, docs) {
-          _.pluck(docs, 'name')[0].should.equal('alpha');
-          _.pluck(docs, 'name')[1].should.equal('charlie');
-          _.pluck(docs, 'name')[2].should.equal('zulu');
-
-          done();
-        });
-      });
-    });
-
+    
     it('With an empty collection', function (done) {
       async.waterfall([
         function (cb) {
           d.remove({}, { multi: true }, function(err) { return cb(err); })
         }
       , function (cb) {
-    var cursor = new Cursor(d);
-    cursor.sort({ age: 1 });
-    cursor.exec(function (err, docs) {
-      assert.isNull(err);
-      docs.length.should.equal(0);
-      cb();
-    });
-      }
+          var cursor = new Cursor(d);
+          cursor.sort({ age: 1 });
+          cursor.exec(function (err, docs) {
+            assert.isNull(err);
+            docs.length.should.equal(0);
+            cb();
+          });
+        }
       ], done);
     });
-
+    
     it('Ability to chain sorting and exec', function (done) {
-      var i;
+      var i;    
       async.waterfall([
         function (cb) {
           var cursor = new Cursor(d);
@@ -248,21 +223,21 @@ describe('Cursor', function () {
           });
         }
       , function (cb) {
-    var cursor = new Cursor(d);
-    cursor.sort({ age: -1 }).exec(function (err, docs) {
-      assert.isNull(err);
-      // Results are in descending order
-      for (i = 0; i < docs.length - 1; i += 1) {
-        assert(docs[i].age > docs[i + 1].age)
-      }
-      cb();
-    });
-      }
+          var cursor = new Cursor(d);
+          cursor.sort({ age: -1 }).exec(function (err, docs) {
+            assert.isNull(err);
+            // Results are in descending order
+            for (i = 0; i < docs.length - 1; i += 1) {
+              assert(docs[i].age > docs[i + 1].age)
+            }
+            cb();
+          });
+        }
       ], done);
     });
 
     it('Using limit and sort', function (done) {
-      var i;
+      var i;    
       async.waterfall([
         function (cb) {
           var cursor = new Cursor(d);
@@ -276,20 +251,20 @@ describe('Cursor', function () {
           });
         }
       , function (cb) {
-    var cursor = new Cursor(d);
-    cursor.sort({ age: -1 }).limit(2).exec(function (err, docs) {
-      assert.isNull(err);
-      docs.length.should.equal(2);
-      docs[0].age.should.equal(89);
-      docs[1].age.should.equal(57);
-      cb();
-    });
-      }
+          var cursor = new Cursor(d);
+          cursor.sort({ age: -1 }).limit(2).exec(function (err, docs) {
+            assert.isNull(err);
+            docs.length.should.equal(2);
+            docs[0].age.should.equal(89);
+            docs[1].age.should.equal(57);
+            cb();
+          });
+        }
       ], done);
     });
 
     it('Using a limit higher than total number of docs shouldnt cause an error', function (done) {
-      var i;
+      var i;    
       async.waterfall([
         function (cb) {
           var cursor = new Cursor(d);
@@ -308,7 +283,7 @@ describe('Cursor', function () {
     });
 
     it('Using limit and skip with sort', function (done) {
-      var i;
+      var i;    
       async.waterfall([
         function (cb) {
           var cursor = new Cursor(d);
@@ -684,11 +659,11 @@ describe('Cursor', function () {
 
     beforeEach(function (done) {
       // We don't know the order in which docs wil be inserted but we ensure correctness by testing both sort orders
-      d.insert({ age: 5, name: 'Jo', planet: 'B', toys: { bebe: true, ballon: 'much' } }, function (err, _doc0) {
+      d.insert({ age: 5, name: 'Jo', planet: 'B' }, function (err, _doc0) {
         doc0 = _doc0;
-        d.insert({ age: 57, name: 'Louis', planet: 'R', toys: { ballon: 'yeah', bebe: false } }, function (err, _doc1) {
+        d.insert({ age: 57, name: 'Louis', planet: 'R' }, function (err, _doc1) {
           doc1 = _doc1;
-          d.insert({ age: 52, name: 'Grafitti', planet: 'C', toys: { bebe: 'kind of' } }, function (err, _doc2) {
+          d.insert({ age: 52, name: 'Grafitti', planet: 'C' }, function (err, _doc2) {
             doc2 = _doc2;
             d.insert({ age: 23, name: 'LM', planet: 'S' }, function (err, _doc3) {
               doc3 = _doc3;
@@ -766,20 +741,20 @@ describe('Cursor', function () {
         assert.isNull(err);
         docs.length.should.equal(5);
         // Takes the _id by default
-        assert.deepEqual(docs[0], { planet: 'B', _id: doc0._id, toys: { bebe: true, ballon: 'much' } });
+        assert.deepEqual(docs[0], { planet: 'B', _id: doc0._id });
         assert.deepEqual(docs[1], { planet: 'S', _id: doc3._id });
-        assert.deepEqual(docs[2], { planet: 'C', _id: doc2._id, toys: { bebe: 'kind of' } });
-        assert.deepEqual(docs[3], { planet: 'R', _id: doc1._id, toys: { bebe: false, ballon: 'yeah' } });
+        assert.deepEqual(docs[2], { planet: 'C', _id: doc2._id });
+        assert.deepEqual(docs[3], { planet: 'R', _id: doc1._id });
         assert.deepEqual(docs[4], { planet: 'Earth', _id: doc4._id });
 
         cursor.projection({ age: 0, name: 0, _id: 0 });
         cursor.exec(function (err, docs) {
           assert.isNull(err);
           docs.length.should.equal(5);
-          assert.deepEqual(docs[0], { planet: 'B', toys: { bebe: true, ballon: 'much' } });
+          assert.deepEqual(docs[0], { planet: 'B' });
           assert.deepEqual(docs[1], { planet: 'S' });
-          assert.deepEqual(docs[2], { planet: 'C', toys: { bebe: 'kind of' } });
-          assert.deepEqual(docs[3], { planet: 'R', toys: { bebe: false, ballon: 'yeah' } });
+          assert.deepEqual(docs[2], { planet: 'C' });
+          assert.deepEqual(docs[3], { planet: 'R' });
           assert.deepEqual(docs[4], { planet: 'Earth' });
 
           done();
@@ -794,57 +769,6 @@ describe('Cursor', function () {
       cursor.exec(function (err, docs) {
         assert.isNotNull(err);
         assert.isUndefined(docs);
-
-        cursor.projection({ age: 1, _id: 0 });
-        cursor.exec(function (err, docs) {
-          assert.isNull(err);
-          assert.deepEqual(docs[0], { age: 5 });
-          assert.deepEqual(docs[1], { age: 23 });
-          assert.deepEqual(docs[2], { age: 52 });
-          assert.deepEqual(docs[3], { age: 57 });
-          assert.deepEqual(docs[4], { age: 89 });
-
-          cursor.projection({ age: 0, toys: 0, planet: 0, _id: 1 });
-          cursor.exec(function (err, docs) {
-            assert.isNull(err);
-            assert.deepEqual(docs[0], { name: 'Jo', _id: doc0._id });
-            assert.deepEqual(docs[1], { name: 'LM', _id: doc3._id });
-            assert.deepEqual(docs[2], { name: 'Grafitti', _id: doc2._id });
-            assert.deepEqual(docs[3], { name: 'Louis', _id: doc1._id });
-            assert.deepEqual(docs[4], { _id: doc4._id });
-
-            done();
-          });
-        });
-      });
-    });
-
-    it("Projections on embedded documents - omit type", function (done) {
-      var cursor = new Cursor(d, {});
-      cursor.sort({ age: 1 });   // For easier finding
-      cursor.projection({ name: 0, planet: 0, 'toys.bebe': 0, _id: 0 });
-      cursor.exec(function (err, docs) {
-        assert.deepEqual(docs[0], { age: 5, toys: { ballon: 'much' } });
-        assert.deepEqual(docs[1], { age: 23 });
-        assert.deepEqual(docs[2], { age: 52, toys: {} });
-        assert.deepEqual(docs[3], { age: 57, toys: { ballon: 'yeah' } });
-        assert.deepEqual(docs[4], { age: 89 });
-
-        done();
-      });
-    });
-
-    it("Projections on embedded documents - pick type", function (done) {
-      var cursor = new Cursor(d, {});
-      cursor.sort({ age: 1 });   // For easier finding
-      cursor.projection({ name: 1, 'toys.ballon': 1, _id: 0 });
-      cursor.exec(function (err, docs) {
-        assert.deepEqual(docs[0], { name: 'Jo', toys: { ballon: 'much' } });
-        assert.deepEqual(docs[1], { name: 'LM' });
-        assert.deepEqual(docs[2], { name: 'Grafitti' });
-        assert.deepEqual(docs[3], { name: 'Louis', toys: { ballon: 'yeah' } });
-        assert.deepEqual(docs[4], {});
-
         done();
       });
     });
diff --git a/test/db.test.js b/test/db.test.js
index ab68788..cb3a74c 100755
--- a/test/db.test.js
+++ b/test/db.test.js
@@ -432,17 +432,16 @@ describe('Database', function () {
           d.insert({ tf: 6 }, function () {
             d.insert({ tf: 4, an: 'other' }, function (err, _doc2) {
               d.insert({ tf: 9 }, function () {
-                d.getCandidates({ r: 6, tf: 4 }, function (err, data) {
-                  var doc1 = _.find(data, function (d) { return d._id === _doc1._id; })
-                    , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
-                    ;
+                var data = d.getCandidates({ r: 6, tf: 4 })
+                  , doc1 = _.find(data, function (d) { return d._id === _doc1._id; })
+                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
+                  ;
 
-                  data.length.should.equal(2);
-                  assert.deepEqual(doc1, { _id: doc1._id, tf: 4 });
-                  assert.deepEqual(doc2, { _id: doc2._id, tf: 4, an: 'other' });
+                data.length.should.equal(2);
+                assert.deepEqual(doc1, { _id: doc1._id, tf: 4 });
+                assert.deepEqual(doc2, { _id: doc2._id, tf: 4, an: 'other' });
 
-                  done();
-                });
+                done();
               });
             });
           });
@@ -456,17 +455,16 @@ describe('Database', function () {
           d.insert({ tf: 6 }, function (err, _doc1) {
             d.insert({ tf: 4, an: 'other' }, function (err) {
               d.insert({ tf: 9 }, function (err, _doc2) {
-                d.getCandidates({ r: 6, tf: { $in: [6, 9, 5] } }, function (err, data) {
-                  var doc1 = _.find(data, function (d) { return d._id === _doc1._id; })
-                    , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
-                    ;
+                var data = d.getCandidates({ r: 6, tf: { $in: [6, 9, 5] } })
+                  , doc1 = _.find(data, function (d) { return d._id === _doc1._id; })
+                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
+                  ;
 
-                  data.length.should.equal(2);
-                  assert.deepEqual(doc1, { _id: doc1._id, tf: 6 });
-                  assert.deepEqual(doc2, { _id: doc2._id, tf: 9 });
+                data.length.should.equal(2);
+                assert.deepEqual(doc1, { _id: doc1._id, tf: 6 });
+                assert.deepEqual(doc2, { _id: doc2._id, tf: 9 });
 
-                  done();
-                });
+                done();
               });
             });
           });
@@ -480,21 +478,20 @@ describe('Database', function () {
           d.insert({ tf: 6 }, function (err, _doc2) {
             d.insert({ tf: 4, an: 'other' }, function (err, _doc3) {
               d.insert({ tf: 9 }, function (err, _doc4) {
-                d.getCandidates({ r: 6, notf: { $in: [6, 9, 5] } }, function (err, data) {
-                  var doc1 = _.find(data, function (d) { return d._id === _doc1._id; })
-                    , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
-                    , doc3 = _.find(data, function (d) { return d._id === _doc3._id; })
-                    , doc4 = _.find(data, function (d) { return d._id === _doc4._id; })
-                    ;
-
-                  data.length.should.equal(4);
-                  assert.deepEqual(doc1, { _id: doc1._id, tf: 4 });
-                  assert.deepEqual(doc2, { _id: doc2._id, tf: 6 });
-                  assert.deepEqual(doc3, { _id: doc3._id, tf: 4, an: 'other' });
-                  assert.deepEqual(doc4, { _id: doc4._id, tf: 9 });
+                var data = d.getCandidates({ r: 6, notf: { $in: [6, 9, 5] } })
+                  , doc1 = _.find(data, function (d) { return d._id === _doc1._id; })
+                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
+                  , doc3 = _.find(data, function (d) { return d._id === _doc3._id; })
+                  , doc4 = _.find(data, function (d) { return d._id === _doc4._id; })
+                  ;
 
-                  done();
-                });
+                data.length.should.equal(4);
+                assert.deepEqual(doc1, { _id: doc1._id, tf: 4 });
+                assert.deepEqual(doc2, { _id: doc2._id, tf: 6 });
+                assert.deepEqual(doc3, { _id: doc3._id, tf: 4, an: 'other' });
+                assert.deepEqual(doc4, { _id: doc4._id, tf: 9 });
+
+                done();
               });
             });
           });
@@ -508,17 +505,16 @@ describe('Database', function () {
           d.insert({ tf: 6 }, function (err, _doc2) {
             d.insert({ tf: 4, an: 'other' }, function (err, _doc3) {
               d.insert({ tf: 9 }, function (err, _doc4) {
-                d.getCandidates({ r: 6, tf: { $lte: 9, $gte: 6 } }, function (err, data) {
-                  var doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
-                    , doc4 = _.find(data, function (d) { return d._id === _doc4._id; })
-                    ;
+                var data = d.getCandidates({ r: 6, tf: { $lte: 9, $gte: 6 } })
+                  , doc2 = _.find(data, function (d) { return d._id === _doc2._id; })
+                  , doc4 = _.find(data, function (d) { return d._id === _doc4._id; })
+                  ;
 
-                  data.length.should.equal(2);
-                  assert.deepEqual(doc2, { _id: doc2._id, tf: 6 });
-                  assert.deepEqual(doc4, { _id: doc4._id, tf: 9 });
+                data.length.should.equal(2);
+                assert.deepEqual(doc2, { _id: doc2._id, tf: 6 });
+                assert.deepEqual(doc4, { _id: doc4._id, tf: 9 });
 
-                  done();
-                });
+                done();
               });
             });
           });
@@ -526,108 +522,6 @@ describe('Database', function () {
       });
     });
 
-    it("Can set a TTL index that expires documents", function (done) {
-      d.ensureIndex({ fieldName: 'exp', expireAfterSeconds: 0.2 }, function () {
-        d.insert({ hello: 'world', exp: new Date() }, function () {
-          setTimeout(function () {
-            d.findOne({}, function (err, doc) {
-              assert.isNull(err);
-              doc.hello.should.equal('world');
-
-              setTimeout(function () {
-                d.findOne({}, function (err, doc) {
-                  assert.isNull(err);
-                  assert.isNull(doc);
-
-                  d.on('compaction.done', function () {
-                    // After compaction, no more mention of the document, correctly removed
-                    var datafileContents = fs.readFileSync(testDb, 'utf8');
-                    datafileContents.split('\n').length.should.equal(2);
-                    assert.isNull(datafileContents.match(/world/));
-
-                    // New datastore on same datafile is empty
-                    var d2 = new Datastore({ filename: testDb, autoload: true });
-                    d2.findOne({}, function (err, doc) {
-                      assert.isNull(err);
-                      assert.isNull(doc);
-
-                      done();
-                    });
-                  });
-
-                  d.persistence.compactDatafile();
-                });
-              }, 101);
-            });
-          }, 100);
-        });
-      });
-    });
-
-    it("TTL indexes can expire multiple documents and only what needs to be expired", function (done) {
-      d.ensureIndex({ fieldName: 'exp', expireAfterSeconds: 0.2 }, function () {
-        d.insert({ hello: 'world1', exp: new Date() }, function () {
-          d.insert({ hello: 'world2', exp: new Date() }, function () {
-            d.insert({ hello: 'world3', exp: new Date((new Date()).getTime() + 100) }, function () {
-              setTimeout(function () {
-                d.find({}, function (err, docs) {
-                  assert.isNull(err);
-                  docs.length.should.equal(3);
-
-                  setTimeout(function () {
-                    d.find({}, function (err, docs) {
-                      assert.isNull(err);
-                      docs.length.should.equal(1);
-                      docs[0].hello.should.equal('world3');
-
-                      setTimeout(function () {
-                        d.find({}, function (err, docs) {
-                          assert.isNull(err);
-                          docs.length.should.equal(0);
-
-                          done();
-                        });
-                      }, 101);
-                    });
-                  }, 101);
-                });
-              }, 100);
-            });
-          });
-        });
-      });
-    });
-
-    it("Document where indexed field is absent or not a date are ignored", function (done) {
-      d.ensureIndex({ fieldName: 'exp', expireAfterSeconds: 0.2 }, function () {
-        d.insert({ hello: 'world1', exp: new Date() }, function () {
-          d.insert({ hello: 'world2', exp: "not a date" }, function () {
-            d.insert({ hello: 'world3' }, function () {
-              setTimeout(function () {
-                d.find({}, function (err, docs) {
-                  assert.isNull(err);
-                  docs.length.should.equal(3);
-
-                  setTimeout(function () {
-                    d.find({}, function (err, docs) {
-                      assert.isNull(err);
-                      docs.length.should.equal(2);
-
-
-                      docs[0].hello.should.not.equal('world1');
-                      docs[1].hello.should.not.equal('world1');
-
-                      done();
-                    });
-                  }, 101);
-                });
-              }, 100);
-            });
-          });
-        });
-      });
-    });
-
   });   // ==== End of '#getCandidates' ==== //
 
 
@@ -1619,114 +1513,6 @@ describe('Database', function () {
       });
     });
 
-    it("createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement", function (done) {
-      var d2 = new Datastore({ inMemoryOnly: true, timestampData: true });
-      d2.insert({ a: 1 });
-      d2.findOne({ a: 1 }, function (err, doc) {
-        var createdAt = doc.createdAt.getTime();
-
-        // Modifying update
-        setTimeout(function () {
-          d2.update({ a: 1 }, { $set: { b: 2 } }, {});
-          d2.findOne({ a: 1 }, function (err, doc) {
-            doc.createdAt.getTime().should.equal(createdAt);
-            assert.isBelow(Date.now() - doc.updatedAt.getTime(), 5);
-
-            // Complete replacement
-            setTimeout(function () {
-              d2.update({ a: 1 }, { c: 3 }, {});
-              d2.findOne({ c: 3 }, function (err, doc) {
-                doc.createdAt.getTime().should.equal(createdAt);
-                assert.isBelow(Date.now() - doc.updatedAt.getTime(), 5);
-
-                done();
-              });
-            }, 20);
-          });
-        }, 20);
-      });
-    });
-
-
-    describe("Callback signature", function () {
-
-      it("Regular update, multi false", function (done) {
-        d.insert({ a: 1 });
-        d.insert({ a: 2 });
-
-        // returnUpdatedDocs set to false
-        d.update({ a: 1 }, { $set: { b: 20 } }, {}, function (err, numAffected, affectedDocuments, upsert) {
-          assert.isNull(err);
-          numAffected.should.equal(1);
-          assert.isUndefined(affectedDocuments);
-          assert.isUndefined(upsert);
-
-          // returnUpdatedDocs set to true
-          d.update({ a: 1 }, { $set: { b: 21 } }, { returnUpdatedDocs: true }, function (err, numAffected, affectedDocuments, upsert) {
-            assert.isNull(err);
-            numAffected.should.equal(1);
-            affectedDocuments.a.should.equal(1);
-            affectedDocuments.b.should.equal(21);
-            assert.isUndefined(upsert);
-
-            done();
-          });
-        });
-      });
-
-      it("Regular update, multi true", function (done) {
-        d.insert({ a: 1 });
-        d.insert({ a: 2 });
-
-        // returnUpdatedDocs set to false
-        d.update({}, { $set: { b: 20 } }, { multi: true }, function (err, numAffected, affectedDocuments, upsert) {
-          assert.isNull(err);
-          numAffected.should.equal(2);
-          assert.isUndefined(affectedDocuments);
-          assert.isUndefined(upsert);
-
-          // returnUpdatedDocs set to true
-          d.update({}, { $set: { b: 21 } }, { multi: true, returnUpdatedDocs: true }, function (err, numAffected, affectedDocuments, upsert) {
-            assert.isNull(err);
-            numAffected.should.equal(2);
-            affectedDocuments.length.should.equal(2);
-            assert.isUndefined(upsert);
-
-            done();
-          });
-        });
-      });
-
-      it("Upsert", function (done) {
-        d.insert({ a: 1 });
-        d.insert({ a: 2 });
-
-        // Upsert flag not set
-        d.update({ a: 3 }, { $set: { b: 20 } }, {}, function (err, numAffected, affectedDocuments, upsert) {
-          assert.isNull(err);
-          numAffected.should.equal(0);
-          assert.isUndefined(affectedDocuments);
-          assert.isUndefined(upsert);
-
-          // Upsert flag set
-          d.update({ a: 3 }, { $set: { b: 21 } }, { upsert: true }, function (err, numAffected, affectedDocuments, upsert) {
-            assert.isNull(err);
-            numAffected.should.equal(1);
-            affectedDocuments.a.should.equal(3);
-            affectedDocuments.b.should.equal(21);
-            upsert.should.equal(true);
-
-            d.find({}, function (err, docs) {
-              docs.length.should.equal(3);
-              done();
-            });
-          });
-        });
-      });
-
-
-    });   // ==== End of 'Update - Callback signature' ==== //
-
   });   // ==== End of 'Update' ==== //
 
 
@@ -2863,10 +2649,9 @@ describe('Database', function () {
     it('Results of getMatching should never contain duplicates', function (done) {
       d.ensureIndex({ fieldName: 'bad' });
       d.insert({ bad: ['a', 'b'] }, function () {
-        d.getCandidates({ bad: { $in: ['a', 'b'] } }, function (err, res) {
-          res.length.should.equal(1);
-          done();
-        });
+        var res = d.getCandidates({ bad: { $in: ['a', 'b'] } });
+        res.length.should.equal(1);
+        done();
       });
     });
 
diff --git a/test/executor.test.js b/test/executor.test.js
index ffea474..6bd1d23 100755
--- a/test/executor.test.js
+++ b/test/executor.test.js
@@ -38,31 +38,12 @@ function testThrowInCallback (d, done) {
   });
 }
 
-// Test that if the callback is falsy, the next DB operations will still be executed
-function testFalsyCallback (d, done) {
-  d.insert({ a: 1 }, null);
-  process.nextTick(function () {
-    d.update({ a: 1 }, { a: 2 }, {}, null);
-    process.nextTick(function () {
-      d.update({ a: 2 }, { a: 1 }, null);
-      process.nextTick(function () {
-        d.remove({ a: 2 }, {}, null);
-        process.nextTick(function () {
-          d.remove({ a: 2 }, null);
-          process.nextTick(function () {
-            d.find({}, done);
-          });
-        });
-      });
-    });
-  });
-}
 
 // Test that operations are executed in the right order
 // We prevent Mocha from catching the exception we throw on purpose by remembering all current handlers, remove them and register them back after test ends
 function testRightOrder (d, done) {
   var currentUncaughtExceptionHandlers = process.listeners('uncaughtException');
-
+  
   process.removeAllListeners('uncaughtException');
 
   process.on('uncaughtException', function (err) {
@@ -99,6 +80,8 @@ function testRightOrder (d, done) {
   });
 }
 
+
+
 // Note:  The following test does not have any assertion because it
 // is meant to address the deprecation warning:
 // (node) warning: Recursive process.nextTick detected. This will break in the next version of node. Please use setImmediate for recursive deferral.
@@ -112,18 +95,7 @@ var testEventLoopStarvation = function(d, done){
      });
    }
    done();
-};
-
-// Test that operations are executed in the right order even with no callback
-function testExecutorWorksWithoutCallback (d, done) {
-  d.insert({ a: 1 });
-  d.insert({ a: 2 }, false);
-  d.find({}, function (err, docs) {
-    docs.length.should.equal(2);
-    done();
-  });
-}
-
+ };
 
 describe('Executor', function () {
 
@@ -158,11 +130,7 @@ describe('Executor', function () {
     it('A throw in a callback doesnt prevent execution of next operations', function(done) {
       testThrowInCallback(d, done);
     });
-
-    it('A falsy callback doesnt prevent execution of next operations', function(done) {
-      testFalsyCallback(d, done);
-    });
-
+    
     it('Operations are executed in the right order', function(done) {
       testRightOrder(d, done);
     });
@@ -170,11 +138,7 @@ describe('Executor', function () {
     it('Does not starve event loop and raise warning when more than 1000 callbacks are in queue', function(done){
       testEventLoopStarvation(d, done);
     });
-
-    it('Works in the right order even with no supplied callback', function(done){
-      testExecutorWorksWithoutCallback(d, done);
-    });
-
+  
   });   // ==== End of 'With persistent database' ====
 
 
@@ -195,19 +159,11 @@ describe('Executor', function () {
     it('A throw in a callback doesnt prevent execution of next operations', function(done) {
       testThrowInCallback(d, done);
     });
-
-    it('A falsy callback doesnt prevent execution of next operations', function(done) {
-      testFalsyCallback(d, done);
-    });
-
+  
     it('Operations are executed in the right order', function(done) {
       testRightOrder(d, done);
     });
-
-    it('Works in the right order even with no supplied callback', function(done){
-      testExecutorWorksWithoutCallback(d, done);
-    });
-
+  
   });   // ==== End of 'With non persistent database' ====
 
 });
diff --git a/test/model.test.js b/test/model.test.js
index f7002ed..7e6a3cd 100755
--- a/test/model.test.js
+++ b/test/model.test.js
@@ -133,21 +133,21 @@ describe('Model', function () {
       b = model.serialize(e3);
       b = model.serialize(e4);
     });
-
+    
     it('Can serialize string fields with a new line without breaking the DB', function (done) {
       var db1, db2
         , badString = "world\r\nearth\nother\rline"
-      ;
-
+        ;
+      
       if (fs.existsSync('workspace/test1.db')) { fs.unlinkSync('workspace/test1.db'); }
       fs.existsSync('workspace/test1.db').should.equal(false);
       db1 = new Datastore({ filename: 'workspace/test1.db' });
-
+      
       db1.loadDatabase(function (err) {
         assert.isNull(err);
         db1.insert({ hello: badString }, function (err) {
           assert.isNull(err);
-
+        
           db2 = new Datastore({ filename: 'workspace/test1.db' });
           db2.loadDatabase(function (err) {
             assert.isNull(err);
@@ -208,7 +208,7 @@ describe('Model', function () {
 
       model.checkObject(obj);
     });
-
+    
     it('Can check if an object is a primitive or not', function () {
       model.isPrimitiveType(5).should.equal(true);
       model.isPrimitiveType('sdsfdfs').should.equal(true);
@@ -256,36 +256,36 @@ describe('Model', function () {
       res.subobj.a.should.equal('b');
       res.subobj.b.should.equal('c');
     });
-
+    
     it('Should deep copy the contents of an array', function () {
       var a = [{ hello: 'world' }]
         , b = model.deepCopy(a)
-      ;
-
+        ;
+        
       b[0].hello.should.equal('world');
       b[0].hello = 'another';
       b[0].hello.should.equal('another');
-      a[0].hello.should.equal('world');
+      a[0].hello.should.equal('world');      
     });
-
+    
     it('Without the strictKeys option, everything gets deep copied', function () {
       var a = { a: 4, $e: 'rrr', 'eee.rt': 42, nested: { yes: 1, 'tt.yy': 2, $nopenope: 3 }, array: [{ 'rr.hh': 1 }, { yes: true }, { $yes: false }] }
         , b = model.deepCopy(a)
-      ;
-
+        ;
+        
       assert.deepEqual(a, b);
     });
-
+    
     it('With the strictKeys option, only valid keys gets deep copied', function () {
       var a = { a: 4, $e: 'rrr', 'eee.rt': 42, nested: { yes: 1, 'tt.yy': 2, $nopenope: 3 }, array: [{ 'rr.hh': 1 }, { yes: true }, { $yes: false }] }
         , b = model.deepCopy(a, true)
-      ;
-
+        ;
+        
       assert.deepEqual(b, { a: 4, nested: { yes: 1 }, array: [{}, { yes: true }, {}] });
     });
 
   });   // ==== End of 'Deep copying' ==== //
-
+  
 
   describe('Modifying documents', function () {
 
@@ -380,21 +380,13 @@ describe('Model', function () {
 
         _.isEqual(modified, { yup: { subfield: 'changed', yop: 'yes indeed' }, totally: { doesnt: { exist: 'now it does' } } }).should.equal(true);
       });
-
-      it("Doesn't replace a falsy field by an object when recursively following dot notation", function () {
-        var obj = { nested: false }
-          , updateQuery = { $set: { "nested.now": 'it is' } }
-          , modified = model.modify(obj, updateQuery);
-
-        assert.deepEqual(modified, { nested: false });   // Object not modified as the nested field doesn't exist
-      });
     });   // End of '$set modifier'
-
+    
     describe('$unset modifier', function () {
-
+    
       it('Can delete a field, not throwing an error if the field doesnt exist', function () {
         var obj, updateQuery, modified;
-
+      
         obj = { yup: 'yes', other: 'also' }
         updateQuery = { $unset: { yup: true } }
         modified = model.modify(obj, updateQuery);
@@ -404,57 +396,46 @@ describe('Model', function () {
         updateQuery = { $unset: { nope: true } }
         modified = model.modify(obj, updateQuery);
         assert.deepEqual(modified, obj);
-
+        
         obj = { yup: 'yes', other: 'also' }
         updateQuery = { $unset: { nope: true, other: true } }
         modified = model.modify(obj, updateQuery);
         assert.deepEqual(modified, { yup: 'yes' });
       });
-
+      
       it('Can unset sub-fields and entire nested documents', function () {
         var obj, updateQuery, modified;
-
+      
         obj = { yup: 'yes', nested: { a: 'also', b: 'yeah' } }
         updateQuery = { $unset: { nested: true } }
         modified = model.modify(obj, updateQuery);
         assert.deepEqual(modified, { yup: 'yes' });
-
+      
         obj = { yup: 'yes', nested: { a: 'also', b: 'yeah' } }
         updateQuery = { $unset: { 'nested.a': true } }
         modified = model.modify(obj, updateQuery);
         assert.deepEqual(modified, { yup: 'yes', nested: { b: 'yeah' } });
-
+      
         obj = { yup: 'yes', nested: { a: 'also', b: 'yeah' } }
         updateQuery = { $unset: { 'nested.a': true, 'nested.b': true } }
         modified = model.modify(obj, updateQuery);
         assert.deepEqual(modified, { yup: 'yes', nested: {} });
       });
-
-      it("When unsetting nested fields, should not create an empty parent to nested field", function () {
-        var obj = model.modify({ argh: true }, { $unset: { 'bad.worse': true } });
-        assert.deepEqual(obj, { argh: true });
-
-        obj = model.modify({ argh: true, bad: { worse: 'oh' } }, { $unset: { 'bad.worse': true } });
-        assert.deepEqual(obj, { argh: true, bad: {} });
-
-        obj = model.modify({ argh: true, bad: {} }, { $unset: { 'bad.worse': true } });
-        assert.deepEqual(obj, { argh: true, bad: {} });
-      });
-
+      
     });   // End of '$unset modifier'
 
     describe('$inc modifier', function () {
       it('Throw an error if you try to use it with a non-number or on a non number field', function () {
         (function () {
-          var obj = { some: 'thing', yup: 'yes', nay: 2 }
-            , updateQuery = { $inc: { nay: 'notanumber' } }
-            , modified = model.modify(obj, updateQuery);
+        var obj = { some: 'thing', yup: 'yes', nay: 2 }
+          , updateQuery = { $inc: { nay: 'notanumber' } }
+          , modified = model.modify(obj, updateQuery);
         }).should.throw();
 
         (function () {
-          var obj = { some: 'thing', yup: 'yes', nay: 'nope' }
-            , updateQuery = { $inc: { nay: 1 } }
-            , modified = model.modify(obj, updateQuery);
+        var obj = { some: 'thing', yup: 'yes', nay: 'nope' }
+          , updateQuery = { $inc: { nay: 1 } }
+          , modified = model.modify(obj, updateQuery);
         }).should.throw();
       });
 
@@ -539,47 +520,6 @@ describe('Model', function () {
         }).should.throw();
       });
 
-      it('Can use the $slice modifier to limit the number of array elements', function () {
-        var obj = { arr: ['hello'] }
-          , modified;
-
-        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'], $slice: 1 } } });
-        assert.deepEqual(modified, { arr: ['hello'] });
-
-        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'], $slice: -1 } } });
-        assert.deepEqual(modified, { arr: ['everything'] });
-
-        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'], $slice: 0 } } });
-        assert.deepEqual(modified, { arr: [] });
-
-        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'], $slice: 2 } } });
-        assert.deepEqual(modified, { arr: ['hello', 'world'] });
-
-        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'], $slice: -2 } } });
-        assert.deepEqual(modified, { arr: ['earth', 'everything'] });
-
-        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'], $slice: -20 } } });
-        assert.deepEqual(modified, { arr: ['hello', 'world', 'earth', 'everything'] });
-
-        modified = model.modify(obj, { $push: { arr: { $each: ['world', 'earth', 'everything'], $slice: 20 } } });
-        assert.deepEqual(modified, { arr: ['hello', 'world', 'earth', 'everything'] });
-
-        modified = model.modify(obj, { $push: { arr: { $each: [], $slice: 1 } } });
-        assert.deepEqual(modified, { arr: ['hello'] });
-
-        // $each not specified, but $slice is
-        modified = model.modify(obj, { $push: { arr: { $slice: 1 } } });
-        assert.deepEqual(modified, { arr: ['hello'] });
-
-        (function () {
-          modified = model.modify(obj, { $push: { arr: { $slice: 1, unauthorized: true } } });
-        }).should.throw();
-
-        (function () {
-          modified = model.modify(obj, { $push: { arr: { $each: [], unauthorized: true } } });
-        }).should.throw();
-      });
-
     });   // End of '$push modifier'
 
     describe('$addToSet modifier', function () {
@@ -728,15 +668,15 @@ describe('Model', function () {
         modified = model.modify(obj, { $pull: { arr: { b: 3 } } });
         assert.deepEqual(modified, { arr: [{ b: 2 }] });
       });
-
+      
       it('Can use any kind of nedb query with $pull', function () {
         var obj = { arr: [4, 7, 12, 2], other: 'yup' }
           , modified
-        ;
-
+          ;
+      
         modified = model.modify(obj, { $pull: { arr: { $gte: 5 } } });
         assert.deepEqual(modified, { arr: [4, 2], other: 'yup' });
-
+        
         obj = { arr: [{ b: 4 }, { b: 7 }, { b: 1 }], other: 'yeah' };
         modified = model.modify(obj, { $pull: { arr: { b: { $gte: 5} } } });
         assert.deepEqual(modified, { arr: [{ b: 4 }, { b: 1 }], other: 'yeah' });
@@ -744,76 +684,6 @@ describe('Model', function () {
 
     });   // End of '$pull modifier'
 
-    describe('$max modifier', function () {
-      it('Will set the field to the updated value if value is greater than current one, without modifying the original object', function () {
-        var obj = { some:'thing', number: 10 }
-            , updateQuery = { $max: { number:12 } }
-            , modified = model.modify(obj, updateQuery);
-
-        modified.should.deep.equal({ some: 'thing', number: 12 });
-        obj.should.deep.equal({ some: 'thing', number: 10 });
-      });
-
-      it('Will not update the field if new value is smaller than current one', function () {
-        var obj = { some:'thing', number: 10 }
-            , updateQuery = { $max: { number: 9 } }
-            , modified = model.modify(obj, updateQuery);
-
-        modified.should.deep.equal({ some:'thing', number:10 });
-      });
-
-      it('Will create the field if it does not exist', function () {
-        var obj = { some: 'thing' }
-            , updateQuery = { $max: { number: 10 } }
-            , modified = model.modify(obj, updateQuery);
-
-        modified.should.deep.equal({ some: 'thing', number: 10 });
-      });
-
-      it('Works on embedded documents', function () {
-        var obj = { some: 'thing', somethingElse: { number:10 } }
-            , updateQuery = { $max: { 'somethingElse.number': 12 } }
-            , modified = model.modify(obj,updateQuery);
-
-        modified.should.deep.equal({ some: 'thing', somethingElse: { number:12 } });
-      });
-    });// End of '$max modifier'
-
-    describe('$min modifier', function () {
-      it('Will set the field to the updated value if value is smaller than current one, without modifying the original object', function () {
-        var obj = { some:'thing', number: 10 }
-            , updateQuery = { $min: { number: 8 } }
-            , modified = model.modify(obj, updateQuery);
-
-        modified.should.deep.equal({ some: 'thing', number: 8 });
-        obj.should.deep.equal({ some: 'thing', number: 10 });
-      });
-
-      it('Will not update the field if new value is greater than current one', function () {
-        var obj = { some: 'thing', number: 10 }
-            , updateQuery = { $min: { number: 12 } }
-            , modified = model.modify(obj, updateQuery);
-
-        modified.should.deep.equal({ some: 'thing', number: 10 });
-      });
-
-      it('Will create the field if it does not exist', function () {
-        var obj = { some: 'thing' }
-            , updateQuery = { $min: { number: 10 } }
-            , modified = model.modify(obj, updateQuery);
-
-        modified.should.deep.equal({ some: 'thing', number: 10 });
-      });
-
-      it('Works on embedded documents', function () {
-        var obj = { some: 'thing', somethingElse: { number: 10 } }
-            , updateQuery = { $min: { 'somethingElse.number': 8 } }
-            , modified = model.modify(obj, updateQuery);
-
-        modified.should.deep.equal({ some: 'thing', somethingElse: { number: 8 } } );
-      });
-    });// End of '$min modifier'
-
   });   // ==== End of 'Modifying documents' ==== //
 
 
@@ -943,11 +813,6 @@ describe('Model', function () {
       model.compareThings({ a: 42, b: 312, c: 54 }, { b: 313, a: 42 }).should.equal(-1);
     });
 
-    it('Can specify custom string comparison function', function () {
-      model.compareThings('hello', 'bloup', function (a, b) { return a < b ? -1 : 1; }).should.equal(1);
-      model.compareThings('hello', 'bloup', function (a, b) { return a > b ? -1 : 1; }).should.equal(-1);
-    });
-
   });   // ==== End of 'Comparing things' ==== //
 
 
@@ -1255,82 +1120,52 @@ describe('Model', function () {
 
     });
 
+    
+    describe('Query operator array $size', function () {
+
+        it('Can query on the size of an array field', function () {
+          // Non nested documents
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 0 } }).should.equal(false);
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 1 } }).should.equal(false);
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 2 } }).should.equal(false);
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 3 } }).should.equal(true);
+            
+          // Nested documents
+          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 0 } }).should.equal(false);
+          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 1 } }).should.equal(false);
+          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 2 } }).should.equal(true);
+          model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 3 } }).should.equal(false);
+
+          // Using a projected array
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 0 } }).should.equal(false);
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 1 } }).should.equal(false);
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 2 } }).should.equal(false);
+          model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 3 } }).should.equal(true);
+        });
 
-    describe('Comparing on arrays', function () {
-
-      it("Can perform a direct array match", function () {
-        model.match({ planets: ['Earth', 'Mars', 'Pluto'], something: 'else' }, { planets: ['Earth', 'Mars'] }).should.equal(false);
-        model.match({ planets: ['Earth', 'Mars', 'Pluto'], something: 'else' }, { planets: ['Earth', 'Mars', 'Pluto'] }).should.equal(true);
-        model.match({ planets: ['Earth', 'Mars', 'Pluto'], something: 'else' }, { planets: ['Earth', 'Pluto', 'Mars'] }).should.equal(false);
-      });
-
-      it('Can query on the size of an array field', function () {
-        // Non nested documents
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 0 } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 1 } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 2 } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $size: 3 } }).should.equal(true);
-
-        // Nested documents
-        model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 0 } }).should.equal(false);
-        model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 1 } }).should.equal(false);
-        model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 2 } }).should.equal(true);
-        model.match({ hello: 'world', description: { satellites: ['Moon', 'Hubble'], diameter: 6300 } }, { "description.satellites": { $size: 3 } }).should.equal(false);
-
-        // Using a projected array
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 0 } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 1 } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 2 } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens.names": { $size: 3 } }).should.equal(true);
-      });
-
-      it('$size operator works with empty arrays', function () {
-        model.match({ childrens: [] }, { "childrens": { $size: 0 } }).should.equal(true);
-        model.match({ childrens: [] }, { "childrens": { $size: 2 } }).should.equal(false);
-        model.match({ childrens: [] }, { "childrens": { $size: 3 } }).should.equal(false);
-      });
-
-      it('Should throw an error if a query operator is used without comparing to an integer', function () {
-        (function () { model.match({ a: [1, 5] }, { a: { $size: 1.4 } }); }).should.throw();
-        (function () { model.match({ a: [1, 5] }, { a: { $size: 'fdf' } }); }).should.throw();
-        (function () { model.match({ a: [1, 5] }, { a: { $size: { $lt: 5 } } }); }).should.throw();
-      });
-
-      it('Using $size operator on a non-array field should prevent match but not throw', function () {
-        model.match({ a: 5 }, { a: { $size: 1 } }).should.equal(false);
-      });
-
-      it('Can use $size several times in the same matcher', function () {
-        model.match({ childrens: [ 'Riri', 'Fifi', 'Loulou' ] }, { "childrens": { $size: 3, $size: 3 } }).should.equal(true);
-        model.match({ childrens: [ 'Riri', 'Fifi', 'Loulou' ] }, { "childrens": { $size: 3, $size: 4 } }).should.equal(false);   // Of course this can never be true
-      });
-
-      it('Can query array documents with multiple simultaneous conditions', function () {
-        // Non nested documents
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $elemMatch: { name: "Dewey", age: 7 } } }).should.equal(true);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $elemMatch: { name: "Dewey", age: 12 } } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $elemMatch: { name: "Louie", age: 3 } } }).should.equal(false);
-
-        // Nested documents
-        model.match({ outer: { childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] } }, { "outer.childrens": { $elemMatch: { name: "Dewey", age: 7 } } }).should.equal(true);
-        model.match({ outer: { childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] } }, { "outer.childrens": { $elemMatch: { name: "Dewey", age: 12 } } }).should.equal(false);
-        model.match({ outer: { childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] } }, { "outer.childrens": { $elemMatch: { name: "Louie", age: 3 } } }).should.equal(false);
-
-      });
+        it('$size operator works with empty arrays', function () {
+          model.match({ childrens: [] }, { "childrens": { $size: 0 } }).should.equal(true);
+          model.match({ childrens: [] }, { "childrens": { $size: 2 } }).should.equal(false);
+          model.match({ childrens: [] }, { "childrens": { $size: 3 } }).should.equal(false);
+        });
 
-      it('$elemMatch operator works with empty arrays', function () {
-        model.match({ childrens: [] }, { "childrens": { $elemMatch: { name: "Mitsos" } } }).should.equal(false);
-        model.match({ childrens: [] }, { "childrens": { $elemMatch: {} } }).should.equal(false);
-      });
+        it('Should throw an error if a query operator is used without comparing to an integer', function () {
+          (function () { model.match({ a: [1, 5] }, { a: { $size: 1.4 } }); }).should.throw();
+          (function () { model.match({ a: [1, 5] }, { a: { $size: 'fdf' } }); }).should.throw();
+          (function () { model.match({ a: [1, 5] }, { a: { $size: { $lt: 5 } } }); }).should.throw();
+        });
 
-      it('Can use more complex comparisons inside nested query documents', function () {
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $elemMatch: { name: "Dewey", age: { $gt: 6, $lt: 8 } } } }).should.equal(true);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $elemMatch: { name: "Dewey", age: { $in: [ 6, 7, 8 ] } } } } ).should.equal(true);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $elemMatch: { name: "Dewey", age: { $gt: 6, $lt: 7 } } } }).should.equal(false);
-        model.match({ childrens: [ { name: "Huey", age: 3 }, { name: "Dewey", age: 7 }, { name: "Louie", age: 12 } ] }, { "childrens": { $elemMatch: { name: "Louie", age: { $gt: 6, $lte: 7 } } } }).should.equal(false);
-      });
+        it('Using $size operator on a non-array field should prevent match but not throw', function () {
+          model.match({ a: 5 }, { a: { $size: 1 } }).should.equal(false);
+        });
+        
+        it('Can use $size several times in the same matcher', function () {
+          model.match({ childrens: [ 'Riri', 'Fifi', 'Loulou' ] }, { "childrens": { $size: 3, $size: 3 } }).should.equal(true);
+          model.match({ childrens: [ 'Riri', 'Fifi', 'Loulou' ] }, { "childrens": { $size: 3, $size: 4 } }).should.equal(false);   // Of course this can never be true
+        });
+        
     });
-
+    
 
     describe('Logical operators $or, $and, $not', function () {
 
diff --git a/test/persistence.test.js b/test/persistence.test.js
index ab1869a..e7d77ed 100755
--- a/test/persistence.test.js
+++ b/test/persistence.test.js
@@ -144,7 +144,7 @@ describe('Persistence', function () {
     treatedData.length.should.equal(2);
     _.isEqual(treatedData[0], { _id: "1", a: 2, ages: [1, 5, 12] }).should.equal(true);
     _.isEqual(treatedData[1], { _id: "3", today: now }).should.equal(true);
-  });
+  });  
 
   it('Compact database on load', function (done) {
     d.insert({ a: 2 }, function () {
@@ -299,15 +299,6 @@ describe('Persistence', function () {
     });
   });
 
-  it("Can listen to compaction events", function (done) {
-    d.on('compaction.done', function () {
-      d.removeAllListeners('compaction.done');   // Tidy up for next tests
-      done();
-    });
-
-    d.persistence.compactDatafile();
-  });
-
 
   describe('Serialization hooks', function () {
     var as = function (s) { return "before_" + s + "_after"; }
